#!/usr/bin/env python3
"""
AIT Complete CMMS - Computerized Maintenance Management System
Fully functional CMMS with automatic PM scheduling, technician assignment, and comprehensive reporting
"""
from datetime import datetime, timedelta
from mro_stock_module import MROStockManager
from cm_parts_integration import CMPartsIntegration
from manuals_module import ManualsManager
from database_utils import db_pool, UserManager, AuditLogger, OptimisticConcurrencyControl, TransactionManager
from kpi_database_migration import migrate_kpi_database
from kpi_manager import KPIManager
from user_management_ui import UserManagementDialog
from password_change_ui import show_password_change_dialog
from backup_ui import BackupUI
import shutil
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import pandas as pd
import psycopg2
from psycopg2 import sql, extras
from datetime import datetime, timedelta
import json
import os
import traceback
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib import colors
import calendar
import random
import math
import re
from pathlib import Path
from typing import List, Dict, Optional, Tuple, NamedTuple
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
import sys
try:
    from reportlab.lib.pagesizes import letter
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.lib import colors
    REPORTLAB_AVAILABLE = True
except ImportError:
    REPORTLAB_AVAILABLE = False
    print("ReportLab not installed. PDF generation will not work.")

try:
    from docx import Document
    DOCX_AVAILABLE = True
except ImportError:
    DOCX_AVAILABLE = False
    print("python-docx not installed. Word document import will not work.")

# ===== WINDOWS DPI AWARENESS =====
# This MUST be called before creating any Tkinter windows
# to prevent scaling issues on high-DPI displays
try:
    import ctypes
    # Tell Windows we are DPI aware
    # This prevents Windows from virtualizing our application
    # and causing scaling conflicts with Tkinter's own scaling
    if sys.platform == 'win32':
        try:
            # Try Windows 10/11 method first (per-monitor DPI aware v2)
            ctypes.windll.shcore.SetProcessDpiAwareness(2)
            print("Set DPI awareness: Per-Monitor DPI Aware V2")
        except:
            try:
                # Fall back to Windows 8.1 method (per-monitor DPI aware)
                ctypes.windll.shcore.SetProcessDpiAwareness(1)
                print("Set DPI awareness: Per-Monitor DPI Aware")
            except:
                try:
                    # Fall back to Windows Vista/7 method (system DPI aware)
                    ctypes.windll.user32.SetProcessDPIAware()
                    print("Set DPI awareness: System DPI Aware")
                except:
                    print("Could not set DPI awareness")
except Exception as e:
    print(f"DPI awareness setup error: {e}")

def get_scaling_factor():
    """
    Get appropriate UI scaling factor based on screen resolution.
    With Windows DPI awareness enabled, we get true screen pixels.
    Tkinter scaling is reduced since Windows handles most DPI scaling.
    """
    try:
        import tkinter as tk
        # Create temporary root to get screen dimensions
        temp_root = tk.Tk()
        temp_root.withdraw()  # Hide the window

        screen_width = temp_root.winfo_screenwidth()
        screen_height = temp_root.winfo_screenheight()

        temp_root.destroy()

        # With DPI awareness enabled, Windows reports true pixels
        # Aggressive scaling to ensure text is readable at all resolutions
        # User feedback: text was too small with previous conservative scaling
        if screen_width >= 3840 or screen_height >= 2160:
            # 4K or higher - strong scaling for readability
            scaling = 2.2
        elif screen_width >= 2560 or screen_height >= 1440:
            # 1440p - substantial scaling
            scaling = 1.9
        else:
            # 1080p or lower - moderate scaling to ensure readability
            scaling = 1.6

        print(f"Screen resolution: {screen_width}x{screen_height}, Tkinter scaling: {scaling}")
        return scaling
    except Exception as e:
        print(f"Could not detect screen resolution: {e}")
        return 1.0  # Default to no scaling

class PMType(Enum):
    WEEKLY = "Weekly"
    MONTHLY = "Monthly"
    SIX_MONTH = "Six Month"
    ANNUAL = "Annual"

class PMStatus(Enum):
    DUE = "due"
    NOT_DUE = "not_due"
    RECENTLY_COMPLETED = "recently_completed"
    CONFLICTED = "conflicted"

@dataclass
class Equipment:
    bfm_no: str
    description: str
    has_weekly: bool
    has_monthly: bool
    has_six_month: bool
    has_annual: bool
    last_weekly_date: Optional[str]
    last_monthly_date: Optional[str]
    last_six_month_date: Optional[str]
    last_annual_date: Optional[str]
    status: str
    priority: int = 99  # Default priority for assets not in priority lists

@dataclass
class CompletionRecord:
    bfm_no: str
    pm_type: PMType
    completion_date: datetime
    technician: str

@dataclass
class PMAssignment:
    bfm_no: str
    pm_type: PMType
    description: str
    priority_score: int
    reason: str

class PMEligibilityResult(NamedTuple):
    status: PMStatus
    reason: str
    priority_score: int = 0
    days_overdue: int = 0

class DateParser:
    """Responsible for parsing and standardizing dates"""
    
    def __init__(self, conn):
        self.conn = conn
    
    def parse_flexible(self, date_string: Optional[str]) -> Optional[datetime]:
        """Parse date string with flexible format handling"""
        if not date_string:
            return None
            
        try:
            # Use your existing DateStandardizer
            standardizer = DateStandardizer(self.conn)
            parsed_date = standardizer.parse_date_flexible(date_string)
            if parsed_date:
                return datetime.strptime(parsed_date, '%Y-%m-%d')
        except Exception as e:
            print(f"Date parsing error for '{date_string}': {e}")
            
        return None

class CompletionRecordRepository:
    """Responsible for retrieving completion records from database"""

    def __init__(self, conn):
        self.conn = conn
        self._completion_cache = None  # Cache for bulk loaded completions
        self._scheduled_cache = None   # Cache for scheduled PMs
        self._uncompleted_cache = None # Cache for uncompleted schedules (PERFORMANCE FIX)

    def get_recent_completions(self, bfm_no: str, days: int = 400) -> List[CompletionRecord]:
        """Get recent completion records for equipment - EXTENDED TO 400 DAYS FOR ANNUAL PMs"""
        # Use cache if available
        if self._completion_cache is not None:
            return self._completion_cache.get(bfm_no, [])

        # Fallback to individual query if cache not loaded
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT bfm_equipment_no, pm_type, completion_date, technician_name
            FROM pm_completions
            WHERE bfm_equipment_no = %s
            AND completion_date::DATE >= CURRENT_DATE - INTERVAL '%s days'
            ORDER BY completion_date DESC
        ''', (bfm_no, days))

        completions = []
        for row in cursor.fetchall():
            try:
                # Map string to PMType enum
                pm_type_str = row[1]
                if pm_type_str == "Weekly":
                    pm_type = PMType.WEEKLY
                elif pm_type_str == "Monthly":
                    pm_type = PMType.MONTHLY
                elif pm_type_str == "Six Month":
                    pm_type = PMType.SIX_MONTH
                else:
                    pm_type = PMType.ANNUAL

                completion_date = datetime.strptime(row[2], '%Y-%m-%d')

                completions.append(CompletionRecord(
                    bfm_no=row[0],
                    pm_type=pm_type,
                    completion_date=completion_date,
                    technician=row[3]
                ))
            except Exception as e:
                print(f"Error parsing completion record: {e}")

        return completions

    def bulk_load_completions(self, days: int = 400) -> None:
        """Load ALL completion records for ALL equipment in one query - MASSIVE PERFORMANCE BOOST"""
        print(f"DEBUG: Bulk loading completion records...")
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT bfm_equipment_no, pm_type, completion_date, technician_name
            FROM pm_completions
            WHERE completion_date::DATE >= CURRENT_DATE - INTERVAL '%s days'
            ORDER BY bfm_equipment_no, completion_date DESC
        ''', (days,))

        # Group completions by equipment
        self._completion_cache = {}
        for row in cursor.fetchall():
            try:
                bfm_no = row[0]
                # Map string to PMType enum
                pm_type_str = row[1]
                if pm_type_str == "Weekly":
                    pm_type = PMType.WEEKLY
                elif pm_type_str == "Monthly":
                    pm_type = PMType.MONTHLY
                elif pm_type_str == "Six Month":
                    pm_type = PMType.SIX_MONTH
                else:
                    pm_type = PMType.ANNUAL

                completion_date = datetime.strptime(row[2], '%Y-%m-%d')

                if bfm_no not in self._completion_cache:
                    self._completion_cache[bfm_no] = []

                self._completion_cache[bfm_no].append(CompletionRecord(
                    bfm_no=bfm_no,
                    pm_type=pm_type,
                    completion_date=completion_date,
                    technician=row[3]
                ))
            except Exception as e:
                print(f"Error parsing completion record: {e}")

        print(f"DEBUG: Loaded completion records for {len(self._completion_cache)} equipment items")

    def get_scheduled_pms(self, week_start: datetime, bfm_no: Optional[str] = None) -> List[Dict]:
        """Get currently scheduled PMs for the week"""
        # Use cache if available and no specific equipment requested
        if self._scheduled_cache is not None and bfm_no:
            return self._scheduled_cache.get(bfm_no, [])

        # Fallback to individual query
        cursor = self.conn.cursor()

        if bfm_no:
            cursor.execute('''
                SELECT bfm_equipment_no, pm_type, assigned_technician, status
                FROM weekly_pm_schedules
                WHERE week_start_date = %s AND bfm_equipment_no = %s
            ''', (week_start.strftime('%Y-%m-%d'), bfm_no))
        else:
            cursor.execute('''
                SELECT bfm_equipment_no, pm_type, assigned_technician, status
                FROM weekly_pm_schedules
                WHERE week_start_date = %s
            ''', (week_start.strftime('%Y-%m-%d'),))

        return [{'bfm_no': row[0], 'pm_type': row[1], 'technician': row[2], 'status': row[3]}
                for row in cursor.fetchall()]

    def bulk_load_scheduled(self, week_start: datetime) -> None:
        """Load ALL scheduled PMs for the week in one query"""
        print(f"DEBUG: Bulk loading scheduled PMs...")
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT bfm_equipment_no, pm_type, assigned_technician, status
            FROM weekly_pm_schedules
            WHERE week_start_date = %s
        ''', (week_start.strftime('%Y-%m-%d'),))

        # Group scheduled PMs by equipment
        self._scheduled_cache = {}
        for row in cursor.fetchall():
            bfm_no = row[0]
            if bfm_no not in self._scheduled_cache:
                self._scheduled_cache[bfm_no] = []

            self._scheduled_cache[bfm_no].append({
                'bfm_no': bfm_no,
                'pm_type': row[1],
                'technician': row[2],
                'status': row[3]
            })

        print(f"DEBUG: Loaded scheduled PMs for {len(self._scheduled_cache)} equipment items")

    def bulk_load_uncompleted_schedules(self, before_week: datetime) -> None:
        """Load ALL uncompleted schedules from PREVIOUS weeks in one query - CRITICAL PERFORMANCE FIX

        This fixes the N+1 query problem where get_uncompleted_schedules() was called
        individually for each equipment item, causing thousands of queries.
        """
        print(f"DEBUG: Bulk loading uncompleted schedules from previous weeks...")
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT bfm_equipment_no, pm_type, week_start_date, assigned_technician, status, scheduled_date
            FROM weekly_pm_schedules
            WHERE week_start_date < %s
            AND status = 'Scheduled'
            ORDER BY bfm_equipment_no, pm_type, week_start_date DESC
        ''', (before_week.strftime('%Y-%m-%d'),))

        # Group uncompleted schedules by equipment + PM type
        self._uncompleted_cache = {}
        for row in cursor.fetchall():
            bfm_no = row[0]
            pm_type = row[1]
            cache_key = f"{bfm_no}_{pm_type}"

            if cache_key not in self._uncompleted_cache:
                self._uncompleted_cache[cache_key] = []

            # Only keep the 5 most recent for each equipment+PM type combination
            if len(self._uncompleted_cache[cache_key]) < 5:
                self._uncompleted_cache[cache_key].append({
                    'week_start': row[2],
                    'technician': row[3],
                    'status': row[4],
                    'scheduled_date': row[5]
                })

        print(f"DEBUG: Loaded uncompleted schedules for {len(self._uncompleted_cache)} equipment+PM type combinations")

    def get_uncompleted_schedules(self, bfm_no: str, pm_type: PMType, before_week: datetime) -> List[Dict]:
        """Get uncompleted scheduled PMs for equipment from PREVIOUS weeks (before the specified week)

        This is CRITICAL to prevent duplicate scheduling:
        - If equipment was scheduled in a previous week but NOT completed
        - It should NOT be scheduled again in the current week

        PERFORMANCE FIX: Use cache if available to avoid N+1 query problem
        """
        # Use cache if available
        if self._uncompleted_cache is not None:
            cache_key = f"{bfm_no}_{pm_type.value}"
            return self._uncompleted_cache.get(cache_key, [])

        # Fallback to individual query if cache not loaded
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT week_start_date, assigned_technician, status, scheduled_date
            FROM weekly_pm_schedules
            WHERE bfm_equipment_no = %s
            AND pm_type = %s
            AND week_start_date < %s
            AND status = 'Scheduled'
            ORDER BY week_start_date DESC
            LIMIT 5
        ''', (bfm_no, pm_type.value, before_week.strftime('%Y-%m-%d')))

        uncompleted = []
        for row in cursor.fetchall():
            uncompleted.append({
                'week_start': row[0],
                'technician': row[1],
                'status': row[2],
                'scheduled_date': row[3]
            })

        return uncompleted

    def check_week_has_completions(self, week_start: datetime) -> int:
        """Check if a week already has completed PMs - used to warn before regeneration"""
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT COUNT(*)
            FROM weekly_pm_schedules
            WHERE week_start_date = %s AND status = 'Completed'
        ''', (week_start.strftime('%Y-%m-%d'),))

        result = cursor.fetchone()
        return result[0] if result else 0

    def clear_cache(self):
        """Clear the caches"""
        self._completion_cache = None
        self._scheduled_cache = None
        self._uncompleted_cache = None

class PMEligibilityChecker:
    """Responsible for determining if a PM is eligible for scheduling"""

    PM_FREQUENCIES = {
        PMType.WEEKLY: 7,
        PMType.MONTHLY: 30,
        PMType.SIX_MONTH: 180,
        PMType.ANNUAL: 365
    }

    def __init__(self, date_parser: DateParser, completion_repo: CompletionRecordRepository):
        self.date_parser = date_parser
        self.completion_repo = completion_repo
        self._next_annual_cache = None  # Cache for next annual PM dates
    
    def check_eligibility(self, equipment: Equipment, pm_type: PMType,
                         week_start: datetime) -> PMEligibilityResult:
        """Check if equipment is eligible for PM assignment"""

        # Check if equipment supports this PM type
        if pm_type == PMType.WEEKLY and not equipment.has_weekly:
            return PMEligibilityResult(PMStatus.NOT_DUE, "Equipment doesn't require Weekly PM")
        if pm_type == PMType.MONTHLY and not equipment.has_monthly:
            return PMEligibilityResult(PMStatus.NOT_DUE, "Equipment doesn't require Monthly PM")
        if pm_type == PMType.SIX_MONTH and not equipment.has_six_month:
            return PMEligibilityResult(PMStatus.NOT_DUE, "Equipment doesn't require 6-month PM")
        if pm_type == PMType.ANNUAL and not equipment.has_annual:
            return PMEligibilityResult(PMStatus.NOT_DUE, "Equipment doesn't require Annual PM")

        # CRITICAL FIX #1: Check for uncompleted schedules from PREVIOUS weeks
        # This prevents duplicate scheduling of equipment that's already scheduled but not completed
        uncompleted_schedules = self.completion_repo.get_uncompleted_schedules(
            equipment.bfm_no, pm_type, week_start
        )
        if uncompleted_schedules:
            oldest_uncompleted = uncompleted_schedules[-1]  # Get the oldest one
            return PMEligibilityResult(
                PMStatus.CONFLICTED,
                f"Already scheduled for week {oldest_uncompleted['week_start']} (uncompleted) - assigned to {oldest_uncompleted['technician']}"
            )

        # WARNING: NEW: For Annual PMs, check if there's a Next Annual PM Date specified
        if pm_type == PMType.ANNUAL:
            # Use cache if available, otherwise query database
            if self._next_annual_cache is not None:
                next_annual_str = self._next_annual_cache.get(equipment.bfm_no)
            else:
                cursor = self.completion_repo.conn.cursor()
                cursor.execute('SELECT next_annual_pm FROM equipment WHERE bfm_equipment_no = %s', (equipment.bfm_no,))
                result = cursor.fetchone()
                next_annual_str = result[0] if result and result[0] else None

            if next_annual_str:
                next_annual_date = self.date_parser.parse_flexible(next_annual_str)
                if next_annual_date:
                    days_until_next_annual = (next_annual_date - datetime.now()).days

                    # If Next Annual PM Date is in the future and more than 7 days away, not due yet
                    if days_until_next_annual > 7:
                        return PMEligibilityResult(
                            PMStatus.NOT_DUE,
                            f"Annual PM scheduled for {next_annual_date.strftime('%Y-%m-%d')} ({days_until_next_annual} days from now)"
                        )
                    # If within 7 days or past due based on Next Annual PM Date
                    elif days_until_next_annual >= -30:  # Allow 30 days past due
                        priority = 500 + abs(min(days_until_next_annual, 0)) * 10
                        return PMEligibilityResult(
                            PMStatus.DUE,
                            f"Annual PM due by Next Annual PM Date: {next_annual_date.strftime('%Y-%m-%d')}",
                            priority_score=priority,
                            days_overdue=abs(min(days_until_next_annual, 0))
                        )





        # Get recent completions
        recent_completions = self.completion_repo.get_recent_completions(equipment.bfm_no, days=400)
        
        # Check for recent completions of same type
        same_type_completions = [c for c in recent_completions if c.pm_type == pm_type]
        if same_type_completions:
            latest_completion = max(same_type_completions, key=lambda x: x.completion_date)
            days_since = (datetime.now() - latest_completion.completion_date).days
            
            min_interval = self._get_minimum_interval(pm_type)
            if days_since < min_interval:
                return PMEligibilityResult(
                    PMStatus.RECENTLY_COMPLETED, 
                    f"{pm_type.value} PM completed {days_since} days ago (min interval: {min_interval})"
                )
        
        # Check for cross-PM conflicts
        conflict_result = self._check_cross_pm_conflicts(recent_completions, pm_type)
        if conflict_result.status == PMStatus.CONFLICTED:
            return conflict_result
        
        # Check if already scheduled
        scheduled_pms = self.completion_repo.get_scheduled_pms(week_start, equipment.bfm_no)
        if any(s['pm_type'] == pm_type.value for s in scheduled_pms):
            return PMEligibilityResult(PMStatus.CONFLICTED, f"Already scheduled for this week")
        
        # Check if due based on equipment table dates
        return self._check_due_date(equipment, pm_type, recent_completions)
    
    def _get_minimum_interval(self, pm_type: PMType) -> int:
        """Get minimum interval before rescheduling same PM type - ALIGNED WITH BUSINESS RULES"""
        if pm_type == PMType.WEEKLY:
            return 7  # Weekly PMs: minimum 7 days between completions
        elif pm_type == PMType.MONTHLY:
            return 30  # Monthly PMs: minimum 30 days between completions
        elif pm_type == PMType.SIX_MONTH:
            return 180  # 6-month PMs: minimum 180 days between completions
        else:  # PMType.ANNUAL
            return 365  # Annual PMs: minimum 365 days between completions
    
    def _check_cross_pm_conflicts(self, recent_completions: List[CompletionRecord], 
                                 pm_type: PMType) -> PMEligibilityResult:
        """Check for conflicts between Monthly and Annual PMs"""
        
        if pm_type == PMType.ANNUAL:
            # Don't schedule Annual if Monthly was done very recently
            monthly_completions = [c for c in recent_completions if c.pm_type == PMType.MONTHLY]
            if monthly_completions:
                latest_monthly = max(monthly_completions, key=lambda x: x.completion_date)
                days_since_monthly = (datetime.now() - latest_monthly.completion_date).days
                
                if days_since_monthly < 7:
                    return PMEligibilityResult(
                        PMStatus.CONFLICTED,
                        f"Annual blocked - Monthly PM completed {days_since_monthly} days ago"
                    )
        
        elif pm_type == PMType.MONTHLY:
            # Don't schedule Monthly if Annual was done recently
            annual_completions = [c for c in recent_completions if c.pm_type == PMType.ANNUAL]
            if annual_completions:
                latest_annual = max(annual_completions, key=lambda x: x.completion_date)
                days_since_annual = (datetime.now() - latest_annual.completion_date).days
                
                if days_since_annual < 30:
                    return PMEligibilityResult(
                        PMStatus.CONFLICTED,
                        f"Monthly blocked - Annual PM completed {days_since_annual} days ago"
                    )
        
        return PMEligibilityResult(PMStatus.DUE, "No cross-PM conflicts")
    
    def _check_due_date(self, equipment: Equipment, pm_type: PMType, 
                       recent_completions: List[CompletionRecord]) -> PMEligibilityResult:
        """Check if PM is due based on last completion date - CORRECTED TO USE ACTUAL COMPLETION DATES"""
    
        # CRITICAL: Get the MOST RECENT completion date from pm_completions table
        # This ensures we're always using the LATEST completion, not outdated equipment table data
        same_type_completions = [c for c in recent_completions if c.pm_type == pm_type]
        
        if same_type_completions:
            # Use the most recent completion record - THIS IS THE SOURCE OF TRUTH
            latest_completion = max(same_type_completions, key=lambda x: x.completion_date)
            last_completion_date = latest_completion.completion_date
            source = "pm_completions_table"
        else:
            # Fall back to equipment table only if no completion records exist
            if pm_type == PMType.WEEKLY:
                last_date_str = equipment.last_weekly_date
            elif pm_type == PMType.MONTHLY:
                last_date_str = equipment.last_monthly_date
            elif pm_type == PMType.SIX_MONTH:
                last_date_str = equipment.last_six_month_date
            else:
                last_date_str = equipment.last_annual_date
            last_completion_date = self.date_parser.parse_flexible(last_date_str)
            source = "equipment_table"

        # Never completed = high priority
        if not last_completion_date:
            if pm_type == PMType.WEEKLY:
                priority = 1100
            elif pm_type == PMType.MONTHLY:
                priority = 1000
            elif pm_type == PMType.SIX_MONTH:
                priority = 950
            else:
                priority = 900
            return PMEligibilityResult(
                PMStatus.DUE,
                f"{pm_type.value} PM never completed - HIGH PRIORITY",
                priority_score=priority
            )

        # Calculate days since last completion
        days_since_completion = (datetime.now() - last_completion_date).days

        # CRITICAL FIX: Use your actual business rules
        if pm_type == PMType.WEEKLY:
            # Weekly PMs: Schedule 7-10 days AFTER last completion
            min_days = 7
            max_days = 10
            ideal_frequency = 7
        elif pm_type == PMType.MONTHLY:
            # Monthly PMs: Schedule 30-35 days AFTER last completion
            min_days = 30
            max_days = 35
            ideal_frequency = 30
        elif pm_type == PMType.SIX_MONTH:
            # 6-month PMs: Schedule 180-185 days AFTER last completion
            min_days = 180
            max_days = 185
            ideal_frequency = 180
        else:  # PMType.ANNUAL
            # Annual PMs: Schedule 365-370 days AFTER last completion
            min_days = 365
            max_days = 370
            ideal_frequency = 365
    
        # PM is DUE if it's been at least min_days since completion
        if days_since_completion >= min_days:
            # Calculate priority based on how overdue
            days_overdue = days_since_completion - ideal_frequency
        
            if days_overdue > 0:
                # Overdue - highest priority
                priority = min(500 + (days_overdue * 10), 999)
                return PMEligibilityResult(
                    PMStatus.DUE,
                    f"{pm_type.value} PM OVERDUE by {days_overdue} days (last: {last_completion_date.strftime('%Y-%m-%d')}, source: {source})",
                    priority_score=priority,
                    days_overdue=days_overdue
                )
            elif days_since_completion <= max_days:
                # Within scheduling window (30-35 for monthly, 365-370 for annual)
                priority = 300 - abs(days_since_completion - ideal_frequency)
                return PMEligibilityResult(
                    PMStatus.DUE,
                    f"{pm_type.value} PM due now ({days_since_completion} days since last, last: {last_completion_date.strftime('%Y-%m-%d')}, source: {source})",
                    priority_score=priority
                )
            else:
                # Past the ideal window but still technically "due"
                priority = 200
                return PMEligibilityResult(
                    PMStatus.DUE,
                    f"{pm_type.value} PM due ({days_since_completion} days since last, last: {last_completion_date.strftime('%Y-%m-%d')}, source: {source})",
                    priority_score=priority
                )
        else:
            # Not yet due - completed too recently
            days_until_due = min_days - days_since_completion
            return PMEligibilityResult(
                PMStatus.NOT_DUE,
                f"{pm_type.value} PM not due for {days_until_due} days (last: {last_completion_date.strftime('%Y-%m-%d')}, source: {source})"
            )

    def bulk_load_next_annual(self) -> None:
        """Load ALL next_annual_pm dates for ALL equipment in one query - PERFORMANCE BOOST"""
        print(f"DEBUG: Bulk loading next annual PM dates...")
        cursor = self.completion_repo.conn.cursor()
        cursor.execute('''
            SELECT bfm_equipment_no, next_annual_pm
            FROM equipment
            WHERE next_annual_pm IS NOT NULL AND next_annual_pm != ''
        ''')

        # Store next annual dates by equipment
        self._next_annual_cache = {}
        for row in cursor.fetchall():
            bfm_no = row[0]
            next_annual_pm = row[1]
            if next_annual_pm:
                self._next_annual_cache[bfm_no] = next_annual_pm

        print(f"DEBUG: Loaded next annual PM dates for {len(self._next_annual_cache)} equipment items")

    def clear_cache(self):
        """Clear the cache"""
        self._next_annual_cache = None

class PMAssignmentGenerator:
    """Responsible for generating PM assignments"""

    def __init__(self, eligibility_checker: PMEligibilityChecker, root=None):
        self.eligibility_checker = eligibility_checker
        self.root = root  # Store root window for UI updates

    def generate_assignments(self, equipment_list: List[Equipment],
                           week_start: datetime, max_assignments: int) -> List[PMAssignment]:
        """Generate prioritized list of PM assignments based on priority level and last completion date"""

        potential_assignments = []
        equipment_priority_map = {}  # Map to store equipment priority

        total_equipment = len(equipment_list)
        print(f"DEBUG: Processing {total_equipment} equipment items...")

        for idx, equipment in enumerate(equipment_list):
            # Yield to event loop every 200 items to prevent UI freeze
            # (Increased from 50 due to cached data optimization - processing is now much faster)
            if idx > 0 and idx % 200 == 0:
                print(f"DEBUG: Progress: {idx}/{total_equipment} equipment processed ({idx*100//total_equipment}%)")
                if self.root:
                    self.root.update_idletasks()  # Yield to tkinter event loop

            # Skip inactive equipment
            if equipment.status not in ['Active']:
                continue

            # Store equipment priority for later sorting
            equipment_priority_map[equipment.bfm_no] = equipment.priority

            # Check Weekly PM eligibility
            if equipment.has_weekly:
                weekly_result = self.eligibility_checker.check_eligibility(
                    equipment, PMType.WEEKLY, week_start
                )
                if weekly_result.status == PMStatus.DUE:
                    potential_assignments.append(PMAssignment(
                        equipment.bfm_no,
                        PMType.WEEKLY,
                        equipment.description,
                        weekly_result.priority_score,
                        weekly_result.reason
                    ))

            # Check Monthly PM eligibility (only if Weekly isn't being assigned)
            if equipment.has_monthly:
                # Don't assign both Weekly and Monthly to same equipment in same week
                has_weekly_assignment = any(
                    a.bfm_no == equipment.bfm_no and a.pm_type == PMType.WEEKLY
                    for a in potential_assignments
                )

                if not has_weekly_assignment:
                    monthly_result = self.eligibility_checker.check_eligibility(
                        equipment, PMType.MONTHLY, week_start
                    )
                    if monthly_result.status == PMStatus.DUE:
                        potential_assignments.append(PMAssignment(
                            equipment.bfm_no,
                            PMType.MONTHLY,
                            equipment.description,
                            monthly_result.priority_score,
                            monthly_result.reason
                        ))

            # Check 6-month PM eligibility (only if Weekly or Monthly isn't being assigned)
            if equipment.has_six_month:
                # Don't assign both Weekly/Monthly and 6-month to same equipment in same week
                has_weekly_assignment = any(
                    a.bfm_no == equipment.bfm_no and a.pm_type == PMType.WEEKLY
                    for a in potential_assignments
                )
                has_monthly_assignment = any(
                    a.bfm_no == equipment.bfm_no and a.pm_type == PMType.MONTHLY
                    for a in potential_assignments
                )

                if not has_weekly_assignment and not has_monthly_assignment:
                    six_month_result = self.eligibility_checker.check_eligibility(
                        equipment, PMType.SIX_MONTH, week_start
                    )
                    if six_month_result.status == PMStatus.DUE:
                        potential_assignments.append(PMAssignment(
                            equipment.bfm_no,
                            PMType.SIX_MONTH,
                            equipment.description,
                            six_month_result.priority_score,
                            six_month_result.reason
                        ))

            # Check Annual PM eligibility (only if Weekly, Monthly, or 6-month isn't being assigned)
            if equipment.has_annual:
                # Don't assign multiple PM types to same equipment in same week
                has_weekly_assignment = any(
                    a.bfm_no == equipment.bfm_no and a.pm_type == PMType.WEEKLY
                    for a in potential_assignments
                )
                has_monthly_assignment = any(
                    a.bfm_no == equipment.bfm_no and a.pm_type == PMType.MONTHLY
                    for a in potential_assignments
                )
                has_six_month_assignment = any(
                    a.bfm_no == equipment.bfm_no and a.pm_type == PMType.SIX_MONTH
                    for a in potential_assignments
                )

                if not has_weekly_assignment and not has_monthly_assignment and not has_six_month_assignment:
                    annual_result = self.eligibility_checker.check_eligibility(
                        equipment, PMType.ANNUAL, week_start
                    )
                    if annual_result.status == PMStatus.DUE:
                        potential_assignments.append(PMAssignment(
                            equipment.bfm_no,
                            PMType.ANNUAL,
                            equipment.description,
                            annual_result.priority_score,
                            annual_result.reason
                        ))

        print(f"DEBUG: Finished processing all {total_equipment} equipment items")
        print(f"DEBUG: Found {len(potential_assignments)} potential assignments")

        # Sort by priority level first (P1, P2, P3, then others), then by priority_score (days overdue)
        # Priority level: 1 (P1) comes first, then 2 (P2), then 3 (P3), then 99 (others)
        # Within each priority level, sort by priority_score (higher = more overdue)
        print(f"DEBUG: Sorting assignments by priority...")
        potential_assignments.sort(
            key=lambda x: (
                equipment_priority_map.get(x.bfm_no, 99),  # Sort by priority level (1, 2, 3, 99)
                -x.priority_score  # Then by priority score (negative for descending order)
            )
        )

        return potential_assignments[:max_assignments]

class PMSchedulingService:
    """Main orchestrator class"""

    def __init__(self, conn, technicians: List[str], root=None):
        self.conn = conn
        self.technicians = technicians
        self.root = root  # Store root window for UI updates

        # Initialize components
        self.date_parser = DateParser(conn)
        self.completion_repo = CompletionRecordRepository(conn)
        self.eligibility_checker = PMEligibilityChecker(self.date_parser, self.completion_repo)
        self.assignment_generator = PMAssignmentGenerator(self.eligibility_checker, root)

        # Load priority assets from CSV files
        self.priority_map = self._load_priority_assets()

    def _load_priority_assets(self) -> Dict[str, int]:
        """Load priority assets from CSV files and create a BFM -> Priority mapping"""
        priority_map = {}

        # Define priority CSV files and their priority levels
        priority_files = [
            ('PM_LIST_A220_1.csv', 1),  # P1 assets
            ('PM_LIST_A220_2.csv', 2),  # P2 assets
            ('PM_LIST_A220_3.csv', 3),  # P3 assets
        ]

        try:
            # Get the directory where the script is located
            # Use os.getcwd() as fallback if __file__ is not available
            try:
                script_dir = os.path.dirname(os.path.abspath(__file__))
            except NameError:
                script_dir = os.getcwd()

            for filename, priority in priority_files:
                filepath = os.path.join(script_dir, filename)

                if not os.path.exists(filepath):
                    print(f"Info: Priority file {filename} not found at {filepath}")
                    continue

                try:
                    # Read CSV file
                    df = pd.read_csv(filepath, encoding='utf-8-sig')

                    # Check if BFM column exists
                    if 'BFM' not in df.columns:
                        print(f"Warning: BFM column not found in {filename}")
                        continue

                    # Map each BFM number to its priority
                    for bfm in df['BFM'].dropna().unique():
                        try:
                            if pd.notna(bfm):
                                # Handle both string and numeric BFM values
                                if isinstance(bfm, str):
                                    bfm_str = bfm.strip()
                                elif isinstance(bfm, (int, float)):
                                    bfm_str = str(int(float(bfm)))
                                else:
                                    bfm_str = str(bfm)

                                if bfm_str:
                                    priority_map[bfm_str] = priority
                        except (ValueError, TypeError) as e:
                            print(f"Warning: Could not convert BFM value '{bfm}' in {filename}: {e}")
                            continue

                    print(f"Loaded {len([b for b in df['BFM'].dropna() if pd.notna(b)])} priority {priority} assets from {filename}")

                except pd.errors.EmptyDataError:
                    print(f"Warning: {filename} is empty")
                except pd.errors.ParserError as e:
                    print(f"Warning: Could not parse {filename}: {e}")
                except Exception as e:
                    print(f"Warning: Error loading {filename}: {str(e)}")

        except Exception as e:
            print(f"Warning: Error in priority asset loading system: {str(e)}")
            print("Continuing with empty priority map - all assets will have default priority")

        print(f"Total priority assets loaded: {len(priority_map)}")
        return priority_map
    
    def generate_weekly_schedule(self, week_start_str: str, weekly_pm_target: int) -> Dict:
        """Generate weekly PM schedule with comprehensive validation"""

        try:
            # Validate technicians list
            if not self.technicians or len(self.technicians) == 0:
                return {
                    'success': False,
                    'error': 'No technicians available for assignment. Please ensure technicians are configured in the system.'
                }

            week_start = datetime.strptime(week_start_str, '%Y-%m-%d')
            cursor = self.conn.cursor()

            print(f"DEBUG: NEW SYSTEM - Generating assignments for week {week_start_str}")
            print(f"DEBUG: Available technicians: {len(self.technicians)}")

            # CRITICAL FIX #2: Check if week has completed PMs BEFORE deletion
            # This prevents accidental deletion of completion data
            completed_count = self.completion_repo.check_week_has_completions(week_start)
            if completed_count > 0:
                print(f"WARNING: Week {week_start_str} already has {completed_count} completed PMs")
                print(f"WARNING: Regenerating will DELETE these completion records!")
                # Note: In production, this should show a confirmation dialog to the user
                # For now, we'll proceed but log the warning

            # CRITICAL FIX #3: Load scheduled PMs BEFORE deletion
            # This ensures the "already scheduled" check works correctly
            print(f"DEBUG: Loading existing schedules before deletion...")
            self.completion_repo.bulk_load_scheduled(week_start)

            # Clear existing assignments for this week
            print(f"DEBUG: Deleting existing schedules for week {week_start_str}...")
            cursor.execute(
                'DELETE FROM weekly_pm_schedules WHERE week_start_date = %s',
                (week_start_str,)
            )

            # Get equipment list
            equipment_list = self._get_active_equipment()
            print(f"DEBUG: Found {len(equipment_list)} active equipment items")

            # Check if there's any equipment to schedule
            if not equipment_list or len(equipment_list) == 0:
                self.conn.commit()
                return {
                    'success': True,
                    'total_assignments': 0,
                    'unique_assets': 0,
                    'assignments': [],
                    'message': 'No active equipment found for scheduling.'
                }

            # PERFORMANCE OPTIMIZATION: Bulk load all data to avoid N+1 query problem
            # This reduces thousands of individual queries to just 4 bulk queries
            print(f"DEBUG: OPTIMIZATION - Pre-loading all data to avoid slow individual queries...")
            self.completion_repo.bulk_load_completions(days=400)
            self.completion_repo.bulk_load_uncompleted_schedules(week_start)  # CRITICAL FIX: Bulk load uncompleted schedules
            # Note: bulk_load_scheduled was moved BEFORE deletion (see above)
            self.eligibility_checker.bulk_load_next_annual()
            print(f"DEBUG: OPTIMIZATION - Data pre-loading complete!")

            # Generate assignments
            assignments = self.assignment_generator.generate_assignments(
                equipment_list, week_start, weekly_pm_target
            )
            print(f"DEBUG: Generated {len(assignments)} potential assignments")

            # Check if assignments were generated
            if not assignments or len(assignments) == 0:
                self.conn.commit()
                return {
                    'success': True,
                    'total_assignments': 0,
                    'unique_assets': 0,
                    'assignments': [],
                    'message': 'No PM assignments needed for this week.'
                }

            # Assign to technicians and save
            scheduled_assignments = self._assign_and_save(assignments, week_start, week_start_str)

            self.conn.commit()

            # Clear caches to free memory
            self.completion_repo.clear_cache()
            self.eligibility_checker.clear_cache()

            return {
                'success': True,
                'total_assignments': len(scheduled_assignments),
                'unique_assets': len(set(a['bfm_no'] for a in scheduled_assignments)),
                'assignments': scheduled_assignments
            }

        except Exception as e:
            self.conn.rollback()
            # Clear caches even on error
            self.completion_repo.clear_cache()
            self.eligibility_checker.clear_cache()
            import traceback
            traceback.print_exc()
            return {'success': False, 'error': str(e)}
    
    def _get_active_equipment(self) -> List[Equipment]:
        """Get list of active equipment from database - EXCLUDES Cannot Find, Run to Failure, Deactivated, and equipment with no PM schedules"""
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT bfm_equipment_no, description, weekly_pm, monthly_pm, six_month_pm, annual_pm,
                last_weekly_pm, last_monthly_pm, last_six_month_pm, last_annual_pm, COALESCE(status, 'Active') as status
            FROM equipment
            WHERE (status = 'Active' OR status IS NULL)
            AND status NOT IN ('Run to Failure', 'Missing')
            AND bfm_equipment_no NOT IN (
                SELECT DISTINCT bfm_equipment_no FROM cannot_find_assets WHERE status = 'Missing'
            )
            AND bfm_equipment_no NOT IN (
                SELECT DISTINCT bfm_equipment_no FROM run_to_failure_assets
            )
            AND bfm_equipment_no NOT IN (
                SELECT DISTINCT bfm_equipment_no FROM deactivated_assets
            )
            AND (weekly_pm = TRUE OR monthly_pm = TRUE OR six_month_pm = TRUE OR annual_pm = TRUE)
            ORDER BY bfm_equipment_no
        ''')

        equipment_list = []
        for row in cursor.fetchall():
            bfm_no = row[0]
            # Get priority from priority_map, default to 99 if not found
            priority = self.priority_map.get(str(bfm_no), 99)

            equipment_list.append(Equipment(
                bfm_no=bfm_no,
                description=row[1],
                has_weekly=bool(row[2]) if row[2] is not None else False,
                has_monthly=bool(row[3]) if row[3] is not None else False,
                has_six_month=bool(row[4]) if row[4] is not None else False,
                has_annual=bool(row[5]) if row[5] is not None else False,
                last_weekly_date=row[6],
                last_monthly_date=row[7],
                last_six_month_date=row[8],
                last_annual_date=row[9],
                status=row[10],
                priority=priority
            ))

        return equipment_list
    
    def _assign_and_save(self, assignments: List[PMAssignment], week_start: datetime, week_start_str: str):
        """Assign to technicians and save to database - OPTIMIZED WITH BATCH INSERT"""

        cursor = self.conn.cursor()
        scheduled_assignments = []

        # Defensive check - should never happen due to validation in generate_weekly_schedule
        if not self.technicians or len(self.technicians) == 0:
            print("ERROR: No technicians available for assignment")
            return scheduled_assignments

        if not assignments or len(assignments) == 0:
            print("INFO: No assignments to schedule")
            return scheduled_assignments

        total_assignments = len(assignments)
        print(f"DEBUG: Assigning {total_assignments} PMs to technicians...")

        # Prepare batch data for database insert
        batch_insert_data = []

        for i, assignment in enumerate(assignments):
            # Yield to event loop every 100 assignments to prevent UI freeze
            # (Increased from 25 due to batch insert optimization - much faster now)
            if i > 0 and i % 100 == 0:
                print(f"DEBUG: Progress: {i}/{total_assignments} assignments processed ({i*100//total_assignments}%)")
                if self.root:
                    self.root.update_idletasks()  # Yield to tkinter event loop

            # Distribute among technicians
            tech_index = i % len(self.technicians)
            technician = self.technicians[tech_index]

            # Schedule throughout the week
            day_offset = i % 5  # Spread across weekdays
            scheduled_date = week_start + timedelta(days=day_offset)

            # Add to batch insert data
            batch_insert_data.append((
                week_start_str,
                assignment.bfm_no,
                assignment.pm_type.value,
                technician,
                scheduled_date.strftime('%Y-%m-%d')
            ))

            scheduled_assignments.append({
                'bfm_no': assignment.bfm_no,
                'pm_type': assignment.pm_type.value,
                'description': assignment.description,
                'technician': technician,
                'scheduled_date': scheduled_date,
                'reason': assignment.reason,
                'priority_score': assignment.priority_score
            })

        # PERFORMANCE OPTIMIZATION: Batch insert all assignments at once
        print(f"DEBUG: Saving {len(batch_insert_data)} assignments to database (batch insert)...")
        cursor.executemany('''
            INSERT INTO weekly_pm_schedules
            (week_start_date, bfm_equipment_no, pm_type, assigned_technician, scheduled_date)
            VALUES (%s, %s, %s, %s, %s)
        ''', batch_insert_data)

        print(f"DEBUG: Finished assigning all {total_assignments} PMs")
        return scheduled_assignments



class DateStandardizer:
    """Utility class to standardize all dates in the CMMS database to YYYY-MM-DD format"""
    
    def __init__(self, conn):
        self.conn = conn
        self.date_patterns = [
            r'^\d{1,2}/\d{1,2}/\d{2}$',      # MM/DD/YY or M/D/YY
            r'^\d{1,2}/\d{1,2}/\d{4}$',     # MM/DD/YYYY or M/D/YYYY
            r'^\d{1,2}-\d{1,2}-\d{2}$',      # MM-DD-YY or M-D-YY
            r'^\d{1,2}-\d{1,2}-\d{4}$',     # MM-DD-YYYY or M-D-YYYY
            r'^\d{4}-\d{1,2}-\d{1,2}$'      # YYYY-MM-DD (already correct)
        ]
        
        self.date_formats = [
            '%m/%d/%y', '%#m/%#d/%y', '%-m/%-d/%y',  # Handle leading zeros
            '%m/%d/%Y', '%#m/%#d/%Y', '%-m/%-d/%Y',
            '%m-%d-%y', '%#m-%#d-%y', '%-m/%-d/%y',
            '%m-%d-%Y', '%#m-%#d-%Y', '%-m/%-d/%Y',
            '%Y-%m-%d'  # Target format
        ]
    
    def parse_date_flexible(self, date_str):
        """Parse date string using multiple formats and return standardized YYYY-MM-DD"""
        if not date_str or date_str.strip() == '':
            return None
            
        date_str = str(date_str).strip()
        
        # Already in correct format
        if re.match(r'^\d{4}-\d{2}-\d{2}$', date_str):
            try:
                # Validate it's a real date
                datetime.strptime(date_str, '%Y-%m-%d')
                return date_str
            except ValueError:
                pass
        
        # Try all possible formats
        for date_format in self.date_formats:
            try:
                parsed_date = datetime.strptime(date_str, date_format)
                
                # Handle 2-digit years (assume 20xx if < 50, 19xx if >= 50)
                if parsed_date.year < 1950:
                    if parsed_date.year < 50:
                        parsed_date = parsed_date.replace(year=parsed_date.year + 2000)
                    else:
                        parsed_date = parsed_date.replace(year=parsed_date.year + 1900)
                
                return parsed_date.strftime('%Y-%m-%d')
                
            except ValueError:
                continue
        
        # If no format worked, return None
        print(f"Could not parse date: '{date_str}'")
        return None
    
    def standardize_all_dates(self):
        """Standardize all dates in the database to YYYY-MM-DD format"""
        cursor = self.conn.cursor()
        total_updated = 0
        errors = []
        
        # Tables and their date columns to standardize
        tables_to_update = {
            'equipment': [
                'last_monthly_pm', 'last_six_month_pm', 'last_annual_pm',
                'next_monthly_pm', 'next_six_month_pm', 'next_annual_pm'
            ],
            'pm_completions': [
                'completion_date', 'pm_due_date', 'next_annual_pm_date'
            ],
            'weekly_pm_schedules': [
                'week_start_date', 'scheduled_date', 'completion_date'
            ],
            'corrective_maintenance': [
                'created_date', 'completion_date'
            ],
            'cannot_find_assets': [
                'reported_date'
            ],
            'run_to_failure_assets': [
                'completion_date'
            ]
        }
        
        for table, date_columns in tables_to_update.items():
            print(f"Processing table: {table}")
            
            try:
                # Get all rows from table
                cursor.execute(f'SELECT * FROM {table}')
                rows = cursor.fetchall()
                
                # Get column names
                cursor.execute(f'PRAGMA table_info({table})')
                column_info = cursor.fetchall()
                column_names = [col[1] for col in column_info]
                
                for row in rows:
                    row_dict = dict(zip(column_names, row))
                    updates_needed = {}
                    
                    # Check each date column
                    for date_col in date_columns:
                        if date_col in row_dict and row_dict[date_col]:
                            original_date = row_dict[date_col]
                            standardized_date = self.parse_date_flexible(original_date)
                            
                            if standardized_date and standardized_date != original_date:
                                updates_needed[date_col] = standardized_date
                    
                    # Update row if any dates need standardizing
                    if updates_needed:
                        update_parts = []
                        values = []
                        
                        for col, new_value in updates_needed.items():
                            update_parts.append(f'{col} = %s')
                            values.append(new_value)
                        
                        # Identify primary key or unique identifier
                        if table == 'equipment':
                            where_clause = 'bfm_equipment_no = %s'
                            values.append(row_dict['bfm_equipment_no'])
                        elif 'id' in row_dict:
                            where_clause = 'id = %s'
                            values.append(row_dict['id'])
                        else:
                            # Skip if no clear identifier
                            continue
                        
                        update_sql = f"UPDATE {table} SET {', '.join(update_parts)} WHERE {where_clause}"
                        
                        try:
                            cursor.execute(update_sql, values)
                            total_updated += 1
                            print(f"Updated {table} - {updates_needed}")
                        except Exception as e:
                            errors.append(f"Error updating {table}: {str(e)}")
                            
            except Exception as e:
                errors.append(f"Error processing table {table}: {str(e)}")
                continue
        
        # Commit changes
        try:
            self.conn.commit()
            return total_updated, errors
        except Exception as e:
            self.conn.rollback()
            errors.append(f"Error committing changes: {str(e)}")
            return 0, errors



def generate_monthly_summary_report(conn, month=None, year=None):
    """
    Generate a comprehensive monthly PM summary report with separate tracking
    for PM Completions, Cannot Find, Run to Failure entries, and CM statistics

    Args:
        conn: Database connection
        month: Month number (1-12), defaults to current month
        year: Year (YYYY), defaults to current year
    """
    # Debug logging to desktop
    import traceback
    import os
    log_file = os.path.expanduser("~/Desktop/monthly_report_debug.log")

    def log_debug(message):
        """Write debug message to log file"""
        try:
            with open(log_file, 'a') as f:
                from datetime import datetime as dt
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S')
                f.write(f"[{timestamp}] {message}\n")
        except:
            pass

    try:
        log_debug("="*80)
        log_debug(f"STARTING REPORT GENERATION: month={month} ({type(month).__name__}), year={year} ({type(year).__name__})")

        # Rollback any failed transaction before starting
        try:
            conn.rollback()
            log_debug("Database connection rollback successful")
        except Exception as e:
            log_debug(f"Rollback exception (ignored): {e}")
            pass  # Ignore if there's no transaction to rollback

        cursor = conn.cursor()
        log_debug("Cursor created successfully")

        # Use current month/year if not specified
        if month is None or year is None:
            now = datetime.now()
            month = month or now.month
            year = year or now.year
        log_debug(f"After defaults: month={month}, year={year}")

        # Ensure month and year are integers
        month = int(month)
        year = int(year)
        log_debug(f"After int conversion: month={month}, year={year}")

        month_name = calendar.month_name[month]
        log_debug(f"Month name: {month_name}")
    
        # Calculate date range for the month
        first_day = f"{year}-{month:02d}-01"
        last_day = f"{year}-{month:02d}-{calendar.monthrange(year, month)[1]}"
    
        print("=" * 80)
        print(f"MONTHLY PM SUMMARY REPORT")
        print(f"Month: {month_name} {year}")
        print(f"Report Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("=" * 80)
        print()
    
        # 1. OVERALL MONTHLY SUMMARY - PM COMPLETIONS ONLY
        # Get PM completions count - ONLY for PMs assigned AND completed in the same month
        # EXCLUDE special types: Cannot Find, Run to Failure
        cursor.execute('''
            SELECT
                COUNT(*) as total_completions,
                SUM(labor_hours + labor_minutes/60.0) as total_hours,
                AVG(labor_hours + labor_minutes/60.0) as avg_hours
            FROM pm_completions
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND pm_due_date IS NOT NULL
            AND pm_due_date != ''
            AND EXTRACT(YEAR FROM pm_due_date::date) = %s
            AND EXTRACT(MONTH FROM pm_due_date::date) = %s
            AND pm_type NOT IN ('CANNOT FIND', 'Cannot Find', 'Run to Failure', 'RTF')
        ''', (year, month, year, month))

        pm_results = cursor.fetchone()
        pm_completions = pm_results[0] or 0
        pm_total_hours = pm_results[1] or 0.0
        pm_avg_hours = pm_results[2] or 0.0

        # Get PMs assigned BEFORE this month but completed this month (Outstanding Completions)
        # This includes PMs with different due dates OR NULL/empty due dates
        # EXCLUDE special types: Cannot Find, Run to Failure
        cursor.execute('''
            SELECT
                COUNT(*) as total_completions,
                SUM(labor_hours + labor_minutes/60.0) as total_hours,
                AVG(labor_hours + labor_minutes/60.0) as avg_hours
            FROM pm_completions
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND (
                pm_due_date IS NULL
                OR pm_due_date = ''
                OR EXTRACT(YEAR FROM pm_due_date::date) != %s
                OR EXTRACT(MONTH FROM pm_due_date::date) != %s
            )
            AND pm_type NOT IN ('CANNOT FIND', 'Cannot Find', 'Run to Failure', 'RTF')
        ''', (year, month, year, month))

        outstanding_results = cursor.fetchone()
        outstanding_completions = outstanding_results[0] or 0
        outstanding_total_hours = outstanding_results[1] or 0.0
        outstanding_avg_hours = outstanding_results[2] or 0.0
    
        # Get Cannot Find entries count (separate) - using DISTINCT to match tab behavior
        cursor.execute('''
            SELECT COUNT(DISTINCT bfm_equipment_no)
            FROM cannot_find_assets
            WHERE EXTRACT(YEAR FROM reported_date::date) = %s
            AND EXTRACT(MONTH FROM reported_date::date) = %s
            AND status = 'Missing'
        ''', (year, month))

        cf_count = cursor.fetchone()[0] or 0

        # Get details of Cannot Find assets reported this month
        cursor.execute('''
            SELECT bfm_equipment_no, description, location, reported_date, technician_name, reported_by
            FROM cannot_find_assets
            WHERE EXTRACT(YEAR FROM reported_date::date) = %s
            AND EXTRACT(MONTH FROM reported_date::date) = %s
            AND status = 'Missing'
            ORDER BY reported_date DESC
        ''', (year, month))

        cannot_find_assets = cursor.fetchall()

        # Get Mark as Found entries for this month
        cursor.execute('''
            SELECT COUNT(*)
            FROM cannot_find_assets
            WHERE EXTRACT(YEAR FROM found_date::date) = %s
            AND EXTRACT(MONTH FROM found_date::date) = %s
            AND status = 'Found'
        ''', (year, month))

        found_count = cursor.fetchone()[0] or 0

        # Get details of Mark as Found assets for this month
        cursor.execute('''
            SELECT bfm_equipment_no, description, location, reported_date, found_date, found_by
            FROM cannot_find_assets
            WHERE EXTRACT(YEAR FROM found_date::date) = %s
            AND EXTRACT(MONTH FROM found_date::date) = %s
            AND status = 'Found'
            ORDER BY found_date DESC
        ''', (year, month))

        found_assets = cursor.fetchall()

        # Get Run to Failure entries count (separate)
        cursor.execute('''
            SELECT COUNT(*)
            FROM run_to_failure_assets
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
        ''', (year, month))

        rtf_count = cursor.fetchone()[0] or 0

        # Get Deactivated entries count
        cursor.execute('''
            SELECT COUNT(*)
            FROM deactivated_assets
            WHERE EXTRACT(YEAR FROM deactivated_date::date) = %s
            AND EXTRACT(MONTH FROM deactivated_date::date) = %s
            AND status = 'Deactivated'
        ''', (year, month))

        deactivated_count = cursor.fetchone()[0] or 0

        # Get CM statistics
        # CMs created this month
        cursor.execute('''
            SELECT COUNT(*)
            FROM corrective_maintenance
            WHERE EXTRACT(YEAR FROM created_date::date) = %s
            AND EXTRACT(MONTH FROM created_date::date) = %s
        ''', (year, month))

        cms_created = cursor.fetchone()[0] or 0

        # CMs completed/closed this month (TOTAL)
        cursor.execute('''
            SELECT COUNT(*)
            FROM corrective_maintenance
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND (status = 'Closed' OR status = 'Completed')
        ''', (year, month))

        cms_closed = cursor.fetchone()[0] or 0

        # NEW: CMs created AND closed in the same month
        cursor.execute('''
            SELECT COUNT(*)
            FROM corrective_maintenance
            WHERE EXTRACT(YEAR FROM created_date::date) = %s
            AND EXTRACT(MONTH FROM created_date::date) = %s
            AND EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND (status = 'Closed' OR status = 'Completed')
        ''', (year, month, year, month))

        cms_created_and_closed = cursor.fetchone()[0] or 0

        # NEW: CMs created BEFORE this month but closed this month
        cursor.execute('''
            SELECT COUNT(*)
            FROM corrective_maintenance
            WHERE (EXTRACT(YEAR FROM created_date::date) != %s OR EXTRACT(MONTH FROM created_date::date) != %s)
            AND EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND (status = 'Closed' OR status = 'Completed')
        ''', (year, month, year, month))

        cms_closed_from_before = cursor.fetchone()[0] or 0

        # Calculate the last day of the reporting month
        last_day = calendar.monthrange(year, month)[1]
        month_end_date = f"{year}-{month:02d}-{last_day:02d}"

        # Currently open CMs (as of the end of the reporting month)
        # These are CMs that were created on or before the month end AND either:
        # 1. Still open (status = 'Open'), OR
        # 2. Closed after the month end
        cursor.execute('''
            SELECT COUNT(*)
            FROM corrective_maintenance
            WHERE created_date::date <= %s::date
            AND (
                status = 'Open'
                OR (status IN ('Closed', 'Completed') AND completion_date::date > %s::date)
            )
        ''', (month_end_date, month_end_date))

        cms_open_current = cursor.fetchone()[0] or 0

        # Get total days open for CMs that were open as of the end of the reporting month
        # Calculate days open from creation to the end of the reporting month
        cursor.execute('''
            SELECT
                SUM(%s::date - created_date::date) as total_days_open,
                AVG(%s::date - created_date::date) as avg_days_open
            FROM corrective_maintenance
            WHERE created_date::date <= %s::date
            AND (
                status = 'Open'
                OR (status IN ('Closed', 'Completed') AND completion_date::date > %s::date)
            )
        ''', (month_end_date, month_end_date, month_end_date, month_end_date))

        open_days_result = cursor.fetchone()
        cms_total_days_open = open_days_result[0] or 0
        cms_avg_days_open = open_days_result[1] or 0.0

        # Get CM total labor hours for CMs closed this month
        cursor.execute('''
            SELECT
                SUM(labor_hours) as total_hours,
                AVG(labor_hours) as avg_hours
            FROM corrective_maintenance
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND (status = 'Closed' OR status = 'Completed')
        ''', (year, month))

        cm_hours_result = cursor.fetchone()
        cm_total_hours = cm_hours_result[0] or 0.0
        cm_avg_hours = cm_hours_result[1] or 0.0

        # Get total days open for CMs closed this month (time to close)
        cursor.execute('''
            SELECT
                SUM(completion_date::date - created_date::date) as total_days_to_close,
                AVG(completion_date::date - created_date::date) as avg_days_to_close
            FROM corrective_maintenance
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND (status = 'Closed' OR status = 'Completed')
        ''', (year, month))

        closed_days_result = cursor.fetchone()
        cms_total_days_to_close = closed_days_result[0] or 0
        cms_avg_days_to_close = closed_days_result[1] or 0.0

        # Display Enhanced CM Statistics
        print("CORRECTIVE MAINTENANCE (CM) SUMMARY:")
        print(f"  CMs Created This Month: {cms_created}")
        print(f"  CMs Closed This Month: {cms_closed}")
        print(f"    - Created & Closed in {month_name}: {cms_created_and_closed}")
        print(f"    - Created Before {month_name}, Closed in {month_name}: {cms_closed_from_before}")
        if cms_closed > 0:
            print(f"    - Total Days to Close (All Closed CMs): {cms_total_days_to_close} days")
            print(f"    - Average Days to Close per CM: {cms_avg_days_to_close:.1f} days")
            print()

            # Detailed breakdown of Days to Close for all closed CMs
            print("=" * 100)
            print(f"DETAILED BREAKDOWN: DAYS TO CLOSE (All Closed CMs in {month_name} {year})")
            print("=" * 100)
            print()
            print("Calculation: Days to Close = Date Closed - Date Created")
            print()

            # Query all closed CMs with their details
            cursor.execute('''
                SELECT
                    cm.cm_number,
                    cm.created_date,
                    cm.completion_date,
                    cm.assigned_technician,
                    cm.bfm_equipment_no,
                    cm.description,
                    cm.priority,
                    (cm.completion_date::date - cm.created_date::date) as days_to_close,
                    cm.root_cause,
                    cm.corrective_action
                FROM corrective_maintenance cm
                WHERE EXTRACT(YEAR FROM cm.completion_date::date) = %s
                AND EXTRACT(MONTH FROM cm.completion_date::date) = %s
                AND (cm.status = 'Closed' OR cm.status = 'Completed')
                ORDER BY cm.completion_date
            ''', (year, month))

            closed_cms = cursor.fetchall()

            for cm_data in closed_cms:
                cm_number, created_date, completion_date, technician, equipment, description, priority, days, root_cause, corrective_action = cm_data

                # Format dates - handle both string and datetime objects
                if created_date:
                    created_str = created_date.strftime('%Y-%m-%d') if hasattr(created_date, 'strftime') else str(created_date)[:10]
                else:
                    created_str = "Unknown"

                if completion_date:
                    completed_str = completion_date.strftime('%Y-%m-%d') if hasattr(completion_date, 'strftime') else str(completion_date)[:10]
                else:
                    completed_str = "Unknown"

                tech_name = technician if technician else "Unassigned"
                equip_str = equipment if equipment else "N/A"
                desc_str = (description[:60] + "...") if description and len(description) > 60 else (description or "No description")
                priority_str = priority if priority else "N/A"

                print(f"CM Number: {cm_number}")
                print(f"  Priority: {priority_str}")
                print(f"  Equipment: {equip_str}")
                print(f"  Description: {desc_str}")
                print(f"  Date Created: {created_str}")
                print(f"  Date Closed: {completed_str}")
                print(f"  Days to Close: {days} days ({completed_str} - {created_str})")
                print(f"  Technician: {tech_name}")

                # Display root cause and corrective action
                root_cause_str = root_cause if root_cause else "Not recorded"
                corrective_action_str = corrective_action if corrective_action else "Not recorded"
                print(f"  Root Cause: {root_cause_str}")
                print(f"  Corrective Action: {corrective_action_str}")

                # Get MRO stock items used for this CM
                cursor.execute('''
                    SELECT
                        cpu.part_number,
                        mro.name,
                        cpu.quantity_used,
                        mro.unit_price,
                        cpu.total_cost,
                        mro.unit_of_measure
                    FROM cm_parts_used cpu
                    LEFT JOIN mro_inventory mro ON cpu.part_number = mro.part_number
                    WHERE cpu.cm_number = %s
                    ORDER BY cpu.recorded_date
                ''', (cm_number,))

                parts_used = cursor.fetchall()

                if parts_used:
                    print(f"  MRO Stock Items Used:")
                    total_cm_cost = 0.0
                    for part_number, name, qty, unit_price, total_cost, uom in parts_used:
                        part_name = name if name else "Unknown Part"
                        quantity = qty if qty else 0
                        price = unit_price if unit_price else 0.0
                        # Always use current unit_price from mro_inventory, not cached total_cost
                        cost = quantity * price
                        unit = uom if uom else "EA"

                        print(f"    - Part#: {part_number} | {part_name}")
                        print(f"      Qty: {quantity} {unit} @ ${price:.2f}/unit = ${cost:.2f}")
                        total_cm_cost += cost

                    print(f"  Total MRO Cost for CM: ${total_cm_cost:.2f}")
                else:
                    print(f"  MRO Stock Items Used: None recorded")

                print("-" * 100)
                print()

            print("=" * 100)
            print()

        print(f"  CM Total Labor Hours (Closed): {cm_total_hours:.1f} hours")
        print(f"  CM Average Hours per Closure: {cm_avg_hours:.1f} hours")
        print(f"  Currently Open CMs: {cms_open_current}")
        if cms_open_current > 0:
            print(f"    - Total Days Open (All Open CMs): {cms_total_days_open} days")
            print(f"    - Average Days Open per CM: {cms_avg_days_open:.1f} days")
            print()

        # ==================== OVERALL MAINTENANCE EFFICIENCY ====================
        # Define constants for efficiency calculation
        TOTAL_TECHNICIANS = 9
        ANNUAL_HOURS_PER_TECHNICIAN = 1900
        WEEKLY_AVAILABLE_HOURS = 328.85
        MONTHLY_AVAILABLE_HOURS = 1425.0  # Updated from 1485.0 hours
        TARGET_EFFICIENCY_RATE = 80.0

        # Calculate Cannot Find hours (2 hours per asset)
        HOURS_PER_CANNOT_FIND = 2.0
        cannot_find_hours = cf_count * HOURS_PER_CANNOT_FIND

        # Calculate total maintenance hours (PM + Outstanding PM + CM)
        total_maintenance_hours = pm_total_hours + outstanding_total_hours + cm_total_hours

        # Calculate efficiency rate
        efficiency_rate = (total_maintenance_hours / MONTHLY_AVAILABLE_HOURS) * 100 if MONTHLY_AVAILABLE_HOURS > 0 else 0.0

        # Determine status
        efficiency_status = "MEETS TARGET " if efficiency_rate >= TARGET_EFFICIENCY_RATE else "BELOW TARGET "

        print()
        print("=" * 80)
        print("OVERALL MAINTENANCE EFFICIENCY")
        print("=" * 80)
        print()
        print(f"  Total PM Hours (Assigned This Month): {pm_total_hours:.1f} hours")
        print(f"  Total Outstanding PM Hours: {outstanding_total_hours:.1f} hours")
        print(f"  Total CM Hours: {cm_total_hours:.1f} hours")
        print(f"  Total Maintenance Hours: {total_maintenance_hours:.1f} hours")
        print()
        print(f"  Cannot Find Assets Count: {cf_count}")
        print(f"  Cannot Find Search Hours: {cannot_find_hours:.1f} hours")
        print(f"    (Based on {HOURS_PER_CANNOT_FIND:.1f} hours per Cannot Find asset)")
        print()
        print(f"  Monthly Available Hours: {MONTHLY_AVAILABLE_HOURS:.1f} hours")
        print(f"    (Based on {TOTAL_TECHNICIANS} technicians  {ANNUAL_HOURS_PER_TECHNICIAN} hours/year  12 months)")
        print(f"    (Weekly Available: {WEEKLY_AVAILABLE_HOURS:.2f} hours)")
        print()
        print(f"  Overall Efficiency Rate: {efficiency_rate:.1f}%")
        print(f"  Target Efficiency Rate: {TARGET_EFFICIENCY_RATE:.1f}%")
        print(f"  Status: {efficiency_status}")
        print()

        if cms_open_current > 0:
            # Detailed breakdown of currently open CMs
            print("=" * 100)
            print(f"DETAILED BREAKDOWN: CURRENTLY OPEN CMs")
            print("=" * 100)
            print()
            print("Calculation: Days Open = Current Date - Date Created")
            print()

            # Query all currently open CMs with their details
            cursor.execute('''
                SELECT
                    cm.cm_number,
                    cm.created_date,
                    cm.assigned_technician,
                    cm.bfm_equipment_no,
                    cm.description,
                    cm.priority,
                    (CURRENT_DATE - cm.created_date::date) as days_open
                FROM corrective_maintenance cm
                WHERE cm.status = 'Open'
                ORDER BY cm.created_date
            ''')

            open_cms = cursor.fetchall()

            for cm_data in open_cms:
                cm_number, created_date, technician, equipment, description, priority, days_open = cm_data

                # Format dates - handle both string and datetime objects
                if created_date:
                    created_str = created_date.strftime('%Y-%m-%d') if hasattr(created_date, 'strftime') else str(created_date)[:10]
                else:
                    created_str = "Unknown"

                current_date_str = datetime.now().strftime('%Y-%m-%d')
                tech_name = technician if technician else "Unassigned"
                equip_str = equipment if equipment else "N/A"
                desc_str = (description[:60] + "...") if description and len(description) > 60 else (description or "No description")
                priority_str = priority if priority else "N/A"

                print(f"CM Number: {cm_number}")
                print(f"  Priority: {priority_str}")
                print(f"  Equipment: {equip_str}")
                print(f"  Description: {desc_str}")
                print(f"  Date Created: {created_str}")
                print(f"  Days Open: {days_open} days (as of {current_date_str})")
                print(f"  Technician: {tech_name}")

                # Get MRO stock items used for this CM (if any parts were already consumed during work)
                cursor.execute('''
                    SELECT
                        cpu.part_number,
                        mro.name,
                        cpu.quantity_used,
                        mro.unit_price,
                        cpu.total_cost,
                        mro.unit_of_measure
                    FROM cm_parts_used cpu
                    LEFT JOIN mro_inventory mro ON cpu.part_number = mro.part_number
                    WHERE cpu.cm_number = %s
                    ORDER BY cpu.recorded_date
                ''', (cm_number,))

                parts_used = cursor.fetchall()

                if parts_used:
                    print(f"  MRO Stock Items Used (work in progress):")
                    total_cm_cost = 0.0
                    for part_number, name, qty, unit_price, total_cost, uom in parts_used:
                        part_name = name if name else "Unknown Part"
                        quantity = qty if qty else 0
                        price = unit_price if unit_price else 0.0
                        # Always use current unit_price from mro_inventory, not cached total_cost
                        cost = quantity * price
                        unit = uom if uom else "EA"

                        print(f"    - Part#: {part_number} | {part_name}")
                        print(f"      Qty: {quantity} {unit} @ ${price:.2f}/unit = ${cost:.2f}")
                        total_cm_cost += cost

                    print(f"  Total MRO Cost (so far): ${total_cm_cost:.2f}")
                else:
                    print(f"  MRO Stock Items Used: None recorded yet")

                print("-" * 100)
                print()

            print("=" * 100)
            print()

        print()

        # NEW: Show details of CMs closed from previous months (if any)
        if cms_closed_from_before > 0:
            print("=" * 80)
            print(f"CMs CREATED BEFORE {month_name.upper()} BUT CLOSED IN {month_name.upper()}:")
            print("=" * 80)
    
            cursor.execute('''
                SELECT 
                    cm_number,
                    bfm_equipment_no,
                    created_date,
                    completion_date,
                    assigned_technician
                FROM corrective_maintenance 
                WHERE (EXTRACT(YEAR FROM created_date::date) != %s OR EXTRACT(MONTH FROM created_date::date) != %s)
                AND EXTRACT(YEAR FROM completion_date::date) = %s
                AND EXTRACT(MONTH FROM completion_date::date) = %s
                AND (status = 'Closed' OR status = 'Completed')
                ORDER BY completion_date
            ''', (year, month, year, month))
    
            old_cms = cursor.fetchall()
    
            print(f"{'CM#':<12} {'Created':<12} {'Closed':<12} {'Equipment':<15} {'Tech':<20}")
            print("-" * 80)
    
            for cm_number, bfm, created, completed, tech in old_cms:
                created_short = str(created)[:10] if created else "Unknown"
                completed_short = str(completed)[:10] if completed else "Unknown"
                bfm_short = (bfm[:15] if bfm else "N/A")
                tech_short = (tech[:20] if tech else "Unassigned")
                print(f"{cm_number:<12} {created_short:<12} {completed_short:<12} {bfm_short:<15} {tech_short:<20}")
    
            print()

        # NEW: Show details of PMs assigned before this month but completed this month (Outstanding Completions)
        if outstanding_completions > 0:
            print("=" * 120)
            print(f"OUTSTANDING PM COMPLETIONS - ASSIGNED BEFORE {month_name.upper()} BUT COMPLETED IN {month_name.upper()}:")
            print("=" * 120)
            print()

            cursor.execute('''
                SELECT
                    bfm_equipment_no,
                    pm_type,
                    pm_due_date,
                    completion_date,
                    technician_name,
                    labor_hours,
                    labor_minutes,
                    notes
                FROM pm_completions
                WHERE EXTRACT(YEAR FROM completion_date::date) = %s
                AND EXTRACT(MONTH FROM completion_date::date) = %s
                AND (
                    pm_due_date IS NULL
                    OR pm_due_date = ''
                    OR EXTRACT(YEAR FROM pm_due_date::date) != %s
                    OR EXTRACT(MONTH FROM pm_due_date::date) != %s
                )
                AND pm_type NOT IN ('CANNOT FIND', 'Cannot Find', 'Run to Failure', 'RTF')
                ORDER BY technician_name, completion_date
            ''', (year, month, year, month))

            outstanding_pms = cursor.fetchall()

            print(f"{'Equipment':<18} {'PM Type':<12} {'Assigned':<12} {'Completed':<12} {'Labor Hrs':<12} {'Technician':<20}")
            print("-" * 120)

            for bfm_no, pm_type, assigned_date, completed_date, tech, labor_hrs, labor_mins, notes in outstanding_pms:
                assigned_short = str(assigned_date)[:10] if assigned_date else "Unknown"
                completed_short = str(completed_date)[:10] if completed_date else "Unknown"
                bfm_short = (bfm_no[:18] if bfm_no else "N/A")
                tech_short = (tech[:20] if tech else "Unassigned")
                pm_type_short = (pm_type[:12] if pm_type else "N/A")
                total_hours = (labor_hrs or 0) + ((labor_mins or 0) / 60.0)
                hours_str = f"{total_hours:.1f}h"

                print(f"{bfm_short:<18} {pm_type_short:<12} {assigned_short:<12} {completed_short:<12} {hours_str:<12} {tech_short:<20}")

                # Display notes/description if available
                if notes and notes.strip():
                    note_lines = notes.strip().split('\n')
                    for line in note_lines[:3]:  # Show first 3 lines of notes
                        truncated_note = (line[:110] + '...') if len(line) > 110 else line
                        print(f"  Note: {truncated_note}")

            print()
            print(f"Total Outstanding Completions: {outstanding_completions}")
            print(f"Total Labor Hours (Outstanding): {outstanding_total_hours:.1f} hours")
            print()

        # Display PM Completions (NOT including Cannot Find or Run to Failure)
        print("MONTHLY OVERVIEW:")
        print(f"  PM Completions (Assigned & Completed in {month_name}): {pm_completions}")
        print(f"    - Total Labor Hours: {pm_total_hours:.1f} hours")
        print(f"    - Average Hours per PM: {pm_avg_hours:.1f} hours")
        print()
        print(f"  Outstanding Completions (Assigned Before {month_name}, Completed in {month_name}): {outstanding_completions}")
        print(f"    - Total Labor Hours: {outstanding_total_hours:.1f} hours")
        print(f"    - Average Hours per PM: {outstanding_avg_hours:.1f} hours")
        print()
        print(f"  Note: PM Completions + Outstanding = {pm_completions + outstanding_completions} total completions")
        print()
    
        # Display Cannot Find, Run to Failure, and Deactivated separately
        print("OTHER ACTIVITY (Not counted in PM totals):")
        print(f"  Cannot Find Entries: {cf_count}")
        print(f"  Mark as Found Entries: {found_count}")
        print(f"  Run to Failure Entries: {rtf_count}")
        print(f"  Deactivated Assets: {deactivated_count}")
        print()
        print(f"  Total Assets Excluded from PM Requirements: {cf_count + rtf_count + deactivated_count}")
        print()

        # Display detailed Cannot Find list if any assets were reported missing this month
        if cf_count > 0:
            print("CANNOT FIND ASSETS DETAILS:")
            print(f"{'BFM Number':<15} {'Description':<30} {'Location':<20} {'Reported Date':<15} {'Technician':<20}")
            print("-" * 110)
            for asset in cannot_find_assets:
                bfm_no = asset[0] or 'N/A'
                desc = (asset[1][:27] + '...') if asset[1] and len(asset[1]) > 30 else (asset[1] or 'N/A')
                loc = (asset[2][:17] + '...') if asset[2] and len(asset[2]) > 20 else (asset[2] or 'N/A')
                # Format reported date properly - extract first 10 chars (YYYY-MM-DD)
                reported_date = asset[3]
                if reported_date:
                    reported = reported_date.strftime('%Y-%m-%d') if hasattr(reported_date, 'strftime') else str(reported_date)[:10]
                else:
                    reported = 'N/A'
                technician = (asset[4][:17] + '...') if asset[4] and len(asset[4]) > 20 else (asset[4] or 'N/A')
                print(f"{bfm_no:<15} {desc:<30} {loc:<20} {reported:<15} {technician:<20}")
            print()
            print(f"Total Cannot Find Assets Reported: {cf_count}")
            print()

        # Display detailed Mark as Found list if any assets were found this month
        if found_count > 0:
            print("MARK AS FOUND ASSETS DETAILS:")
            print(f"{'BFM Number':<15} {'Description':<30} {'Location':<20} {'Reported Date':<15} {'Found Date':<15} {'Found By':<15}")
            print("-" * 120)
            for asset in found_assets:
                bfm_no = asset[0] or 'N/A'
                desc = (asset[1][:27] + '...') if asset[1] and len(asset[1]) > 30 else (asset[1] or 'N/A')
                loc = (asset[2][:17] + '...') if asset[2] and len(asset[2]) > 20 else (asset[2] or 'N/A')
                # Format reported date properly
                reported_date_val = asset[3]
                if reported_date_val:
                    reported = reported_date_val.strftime('%Y-%m-%d') if hasattr(reported_date_val, 'strftime') else str(reported_date_val)[:10]
                else:
                    reported = 'N/A'
                # Format found date properly
                found_date_val = asset[4]
                if found_date_val:
                    found_date = found_date_val.strftime('%Y-%m-%d') if hasattr(found_date_val, 'strftime') else str(found_date_val)[:10]
                else:
                    found_date = 'N/A'
                found_by = asset[5] or 'N/A'
                print(f"{bfm_no:<15} {desc:<30} {loc:<20} {reported:<15} {found_date:<15} {found_by:<15}")
            print()
            print(f"Total Mark as Found Assets: {found_count}")
            print()
    
    
    
        # 2. PM TYPE BREAKDOWN (PM Completions only)
        cursor.execute('''
            SELECT
                pm_type,
                COUNT(*) as count,
                SUM(labor_hours + labor_minutes/60.0) as total_hours,
                AVG(labor_hours + labor_minutes/60.0) as avg_hours
            FROM pm_completions
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            GROUP BY pm_type
            ORDER BY count DESC
        ''', (year, month))
    
        pm_types = cursor.fetchall()
    
        if pm_types:
            print("PM TYPE BREAKDOWN:")
            print(f"{'PM Type':<15} {'Count':<10} {'Total Hours':<15} {'Avg Hours':<12}")
            print("-" * 55)
            for pm_type, count, total_hrs, avg_hrs in pm_types:
                pm_type_str = pm_type if pm_type is not None else "N/A"
                count_val = count if count is not None else 0
                total_hrs_display = f"{total_hrs:.1f}h" if total_hrs else "0.0h"
                avg_hrs_display = f"{avg_hrs:.1f}h" if avg_hrs else "0.0h"
                print(f"{pm_type_str:<15} {count_val:<10} {total_hrs_display:<15} {avg_hrs_display:<12}")
            print()
    
        # 3. DAILY COMPLETION TRACKING (PM Completions only)
        cursor.execute('''
            SELECT
                completion_date,
                COUNT(*) as daily_count,
                SUM(labor_hours + labor_minutes/60.0) as daily_hours
            FROM pm_completions
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            GROUP BY completion_date
            ORDER BY completion_date
        ''', (year, month))
    
        daily_data = cursor.fetchall()
    
        if daily_data:
            print("DAILY COMPLETION SUMMARY:")
            print(f"{'Date':<12} {'PMs Completed':<15} {'Labor Hours':<12} {'Running Total':<15}")
            print("-" * 55)
        
            running_total = 0
            for date, count, hours in daily_data:
                date_str = str(date) if date is not None else "N/A"
                count_val = count if count is not None else 0
                running_total += count_val
                hours_display = f"{hours:.1f}h" if hours else "0.0h"
                print(f"{date_str:<12} {count_val:<15} {hours_display:<12} {running_total:<15}")
            print()
    
        # 4. TECHNICIAN PERFORMANCE (PM Completions only)
        # Get completions per technician
        cursor.execute('''
            SELECT
                technician_name,
                COUNT(*) as completions,
                SUM(labor_hours + labor_minutes/60.0) as total_hours,
                AVG(labor_hours + labor_minutes/60.0) as avg_hours
            FROM pm_completions
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            GROUP BY technician_name
            ORDER BY completions DESC
        ''', (year, month))

        completions_data = {row[0]: {'count': row[1], 'total_hrs': row[2], 'avg_hrs': row[3]}
                            for row in cursor.fetchall()}

        # Get assigned PMs per technician for completion rate calculation
        # Count PMs that were scheduled for completion in this month
        cursor.execute('''
            SELECT
                assigned_technician,
                COUNT(*) as assigned_count
            FROM weekly_pm_schedules
            WHERE EXTRACT(YEAR FROM scheduled_date::date) = %s
            AND EXTRACT(MONTH FROM scheduled_date::date) = %s
            AND assigned_technician IS NOT NULL
            AND assigned_technician != ''
            GROUP BY assigned_technician
        ''', (year, month))

        assigned_pms = {row[0]: row[1] for row in cursor.fetchall()}

        # Get Cannot Find count per technician for this month
        cursor.execute('''
            SELECT
                assigned_technician,
                COUNT(*) as cannot_find_count
            FROM weekly_pm_schedules
            WHERE EXTRACT(YEAR FROM scheduled_date::date) = %s
            AND EXTRACT(MONTH FROM scheduled_date::date) = %s
            AND status = 'Cannot Find'
            AND assigned_technician IS NOT NULL
            AND assigned_technician != ''
            GROUP BY assigned_technician
        ''', (year, month))

        cannot_find_pms = {row[0]: row[1] for row in cursor.fetchall()}

        # Build complete list of all technicians with any activity
        all_technicians = set(list(assigned_pms.keys()) + list(completions_data.keys()) + list(cannot_find_pms.keys()))

        if all_technicians:
            print("TECHNICIAN PERFORMANCE:")
            print(f"{'Technician':<25} {'Assigned':<12} {'Completed':<12} {'Cannot Find':<14} {'Rate':<12} {'Total Hours':<15} {'Avg Hours':<12}")
            print("-" * 110)

            # Sort technicians by completion count (descending), then by name
            tech_list = sorted(all_technicians,
                              key=lambda t: (completions_data.get(t, {}).get('count', 0), t),
                              reverse=True)

            for tech in tech_list:
                # Get assigned PM count for this technician
                assigned_count = assigned_pms.get(tech, 0)

                # Get completion data for this technician
                comp_data = completions_data.get(tech, {'count': 0, 'total_hrs': 0.0, 'avg_hrs': 0.0})
                count = comp_data['count']
                total_hrs = comp_data['total_hrs']
                avg_hrs = comp_data['avg_hrs']

                # Get Cannot Find count for this technician (0 if none)
                cf_count = cannot_find_pms.get(tech, 0)

                # Calculate completion rate percentage
                if assigned_count > 0:
                    completion_rate = (count / assigned_count) * 100
                    rate_display = f"{completion_rate:.1f}%"
                else:
                    # If no assigned PMs tracked, show count without percentage
                    rate_display = "N/A"

                tech_str = tech if tech is not None else "Unassigned"
                total_hrs_display = f"{total_hrs:.1f}h" if total_hrs else "0.0h"
                avg_hrs_display = f"{avg_hrs:.1f}h" if avg_hrs else "0.0h"
                print(f"{tech_str:<25} {assigned_count:<12} {count:<12} {cf_count:<14} {rate_display:<12} {total_hrs_display:<15} {avg_hrs_display:<12}")
            print()
    
        # 5. CM BREAKDOWN BY PRIORITY AND TECHNICIAN
        # First show CMs created this month by priority
        cursor.execute('''
            SELECT
                priority,
                COUNT(*) as count
            FROM corrective_maintenance
            WHERE EXTRACT(YEAR FROM created_date::date) = %s
            AND EXTRACT(MONTH FROM created_date::date) = %s
            GROUP BY priority
            ORDER BY
                CASE priority
                    WHEN 'Critical' THEN 1
                    WHEN 'High' THEN 2
                    WHEN 'Medium' THEN 3
                    WHEN 'Low' THEN 4
                    ELSE 5
                END
        ''', (year, month))

        cm_priorities_created = cursor.fetchall()

        if cm_priorities_created:
            print("CM BREAKDOWN BY PRIORITY (Created This Month):")
            print(f"{'Priority':<15} {'Count':<10}")
            print("-" * 25)
            for priority, count in cm_priorities_created:
                priority_str = priority if priority is not None else "N/A"
                count_val = count if count is not None else 0
                print(f"{priority_str:<15} {count_val:<10}")
            print()

        # Now show CMs closed this month by priority with hours
        cursor.execute('''
            SELECT
                priority,
                COUNT(*) as count,
                SUM(labor_hours) as total_hours,
                AVG(labor_hours) as avg_hours
            FROM corrective_maintenance
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND (status = 'Closed' OR status = 'Completed')
            GROUP BY priority
            ORDER BY
                CASE priority
                    WHEN 'Critical' THEN 1
                    WHEN 'High' THEN 2
                    WHEN 'Medium' THEN 3
                    WHEN 'Low' THEN 4
                    ELSE 5
                END
        ''', (year, month))

        cm_priorities_closed = cursor.fetchall()

        if cm_priorities_closed:
            print("CM BREAKDOWN BY PRIORITY (Closed This Month):")
            print(f"{'Priority':<15} {'Count':<10} {'Total Hours':<15} {'Avg Hours':<12}")
            print("-" * 55)
            for priority, count, total_hrs, avg_hrs in cm_priorities_closed:
                priority_str = priority if priority is not None else "N/A"
                count_val = count if count is not None else 0
                total_hrs_display = f"{total_hrs:.1f}h" if total_hrs else "0.0h"
                avg_hrs_display = f"{avg_hrs:.1f}h" if avg_hrs else "0.0h"
                print(f"{priority_str:<15} {count_val:<10} {total_hrs_display:<15} {avg_hrs_display:<12}")
            print()
    
        # CM completion by technician
        cursor.execute('''
            SELECT
                assigned_technician,
                COUNT(*) as completed,
                SUM(labor_hours) as total_hours,
                AVG(labor_hours) as avg_hours
            FROM corrective_maintenance
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND (status = 'Closed' OR status = 'Completed')
            GROUP BY assigned_technician
            ORDER BY completed DESC
        ''', (year, month))

        cm_techs = cursor.fetchall()

        if cm_techs:
            print("CMs COMPLETED BY TECHNICIAN (This Month):")
            print(f"{'Technician':<25} {'CMs Closed':<12} {'Total Hours':<15} {'Avg Hours':<12}")
            print("-" * 67)
            for tech, count, total_hrs, avg_hrs in cm_techs:
                tech_str = tech if tech is not None else "Unassigned"
                count_val = count if count is not None else 0
                total_hrs_display = f"{total_hrs:.1f}h" if total_hrs else "0.0h"
                avg_hrs_display = f"{avg_hrs:.1f}h" if avg_hrs else "0.0h"
                print(f"{tech_str:<25} {count_val:<12} {total_hrs_display:<15} {avg_hrs_display:<12}")
            print()
    
        # 6. EQUIPMENT LOCATION SUMMARY (PM Completions only)
        cursor.execute('''
            SELECT
                e.location,
                COUNT(*) as completions,
                SUM(pc.labor_hours + pc.labor_minutes/60.0) as total_hours
            FROM pm_completions pc
            JOIN equipment e ON pc.bfm_equipment_no = e.bfm_equipment_no
            WHERE EXTRACT(YEAR FROM pc.completion_date::date) = %s
            AND EXTRACT(MONTH FROM pc.completion_date::date) = %s
            GROUP BY e.location
            ORDER BY completions DESC
        ''', (year, month))
    
        locations = cursor.fetchall()
    
        if locations:
            print("COMPLETIONS BY LOCATION:")
            print(f"{'Location':<30} {'Completions':<15} {'Total Hours':<12}")
            print("-" * 60)
            for location, count, hours in locations:
                location_str = location if location is not None else "N/A"
                count_val = count if count is not None else 0
                hours_display = f"{hours:.1f}h" if hours else "0.0h"
                print(f"{location_str:<30} {count_val:<15} {hours_display:<12}")
            print()

        # ==================== EQUIPMENT MISSING PARTS SUMMARY ====================
        print()
        print("=" * 80)
        print("EQUIPMENT WITH MISSING PARTS SUMMARY")
        print("=" * 80)
        print()

        # Get Equipment Missing Parts statistics
        # Entries reported this month
        cursor.execute('''
            SELECT COUNT(*)
            FROM equipment_missing_parts
            WHERE EXTRACT(YEAR FROM reported_date::date) = %s
            AND EXTRACT(MONTH FROM reported_date::date) = %s
        ''', (year, month))

        emp_reported = cursor.fetchone()[0] or 0

        # Entries closed this month
        cursor.execute('''
            SELECT COUNT(*)
            FROM equipment_missing_parts
            WHERE EXTRACT(YEAR FROM closed_date::date) = %s
            AND EXTRACT(MONTH FROM closed_date::date) = %s
            AND status = 'Closed'
        ''', (year, month))

        emp_closed = cursor.fetchone()[0] or 0

        # Currently open entries
        cursor.execute('''
            SELECT COUNT(*)
            FROM equipment_missing_parts
            WHERE status = 'Open'
        ''')

        emp_open_current = cursor.fetchone()[0] or 0

        # Display summary statistics
        print(f"  Entries Reported This Month: {emp_reported}")
        print(f"  Entries Closed This Month: {emp_closed}")
        print(f"  Currently Open Entries: {emp_open_current}")
        print()

        # Detailed breakdown of entries reported this month
        if emp_reported > 0:
            print("=" * 100)
            print(f"DETAILED BREAKDOWN: EQUIPMENT MISSING PARTS REPORTED IN {month_name.upper()} {year}")
            print("=" * 100)
            print()

            cursor.execute('''
                SELECT
                    emp_number,
                    bfm_equipment_no,
                    description,
                    missing_parts_description,
                    priority,
                    assigned_technician,
                    reported_date,
                    status
                FROM equipment_missing_parts
                WHERE EXTRACT(YEAR FROM reported_date::date) = %s
                AND EXTRACT(MONTH FROM reported_date::date) = %s
                ORDER BY reported_date
            ''', (year, month))

            reported_emps = cursor.fetchall()

            for emp_data in reported_emps:
                emp_number, equipment, description, missing_parts, priority, technician, reported_date, status = emp_data

                # Format dates - handle both string and datetime objects
                if reported_date:
                    reported_str = reported_date.strftime('%Y-%m-%d') if hasattr(reported_date, 'strftime') else str(reported_date)[:10]
                else:
                    reported_str = "Unknown"

                tech_name = technician if technician else "Unassigned"
                equip_str = equipment if equipment else "N/A"
                desc_str = (description[:60] + "...") if description and len(description) > 60 else (description or "No description")
                priority_str = priority if priority else "N/A"
                parts_str = (missing_parts[:80] + "...") if missing_parts and len(missing_parts) > 80 else (missing_parts or "N/A")
                status_str = status if status else "Open"

                print(f"EMP Number: {emp_number}")
                print(f"  Priority: {priority_str}")
                print(f"  Status: {status_str}")
                print(f"  Equipment: {equip_str}")
                print(f"  Description: {desc_str}")
                print(f"  Missing Parts: {parts_str}")
                print(f"  Reported Date: {reported_str}")
                print(f"  Assigned Technician: {tech_name}")
                print("-" * 100)
                print()

            print("=" * 100)
            print()

        # Detailed breakdown of entries closed this month
        if emp_closed > 0:
            print("=" * 100)
            print(f"DETAILED BREAKDOWN: EQUIPMENT MISSING PARTS CLOSED IN {month_name.upper()} {year}")
            print("=" * 100)
            print()

            cursor.execute('''
                SELECT
                    emp_number,
                    bfm_equipment_no,
                    description,
                    missing_parts_description,
                    priority,
                    assigned_technician,
                    reported_date,
                    closed_date,
                    closed_by
                FROM equipment_missing_parts
                WHERE EXTRACT(YEAR FROM closed_date::date) = %s
                AND EXTRACT(MONTH FROM closed_date::date) = %s
                AND status = 'Closed'
                ORDER BY closed_date
            ''', (year, month))

            closed_emps = cursor.fetchall()

            for emp_data in closed_emps:
                emp_number, equipment, description, missing_parts, priority, technician, reported_date, closed_date, closed_by = emp_data

                # Format dates
                if reported_date:
                    reported_str = reported_date.strftime('%Y-%m-%d') if hasattr(reported_date, 'strftime') else str(reported_date)[:10]
                else:
                    reported_str = "Unknown"

                if closed_date:
                    closed_str = closed_date.strftime('%Y-%m-%d') if hasattr(closed_date, 'strftime') else str(closed_date)[:10]
                else:
                    closed_str = "Unknown"

                tech_name = technician if technician else "Unassigned"
                equip_str = equipment if equipment else "N/A"
                desc_str = (description[:60] + "...") if description and len(description) > 60 else (description or "No description")
                priority_str = priority if priority else "N/A"
                parts_str = (missing_parts[:80] + "...") if missing_parts and len(missing_parts) > 80 else (missing_parts or "N/A")
                closer_name = closed_by if closed_by else "Unknown"

                print(f"EMP Number: {emp_number}")
                print(f"  Priority: {priority_str}")
                print(f"  Equipment: {equip_str}")
                print(f"  Description: {desc_str}")
                print(f"  Missing Parts: {parts_str}")
                print(f"  Reported Date: {reported_str}")
                print(f"  Closed Date: {closed_str}")
                print(f"  Assigned Technician: {tech_name}")
                print(f"  Closed By: {closer_name}")
                print("-" * 100)
                print()

            print("=" * 100)
            print()

        # Currently open entries
        if emp_open_current > 0:
            print("=" * 100)
            print(f"CURRENTLY OPEN EQUIPMENT MISSING PARTS ENTRIES")
            print("=" * 100)
            print()

            cursor.execute('''
                SELECT
                    emp_number,
                    bfm_equipment_no,
                    description,
                    missing_parts_description,
                    priority,
                    assigned_technician,
                    reported_date,
                    (CURRENT_DATE - reported_date::date) as days_open
                FROM equipment_missing_parts
                WHERE status = 'Open'
                ORDER BY reported_date
            ''')

            open_emps = cursor.fetchall()

            for emp_data in open_emps:
                emp_number, equipment, description, missing_parts, priority, technician, reported_date, days_open = emp_data

                # Format dates
                if reported_date:
                    reported_str = reported_date.strftime('%Y-%m-%d') if hasattr(reported_date, 'strftime') else str(reported_date)[:10]
                else:
                    reported_str = "Unknown"

                current_date_str = datetime.now().strftime('%Y-%m-%d')
                tech_name = technician if technician else "Unassigned"
                equip_str = equipment if equipment else "N/A"
                desc_str = (description[:60] + "...") if description and len(description) > 60 else (description or "No description")
                priority_str = priority if priority else "N/A"
                parts_str = (missing_parts[:80] + "...") if missing_parts and len(missing_parts) > 80 else (missing_parts or "N/A")

                print(f"EMP Number: {emp_number}")
                print(f"  Priority: {priority_str}")
                print(f"  Equipment: {equip_str}")
                print(f"  Description: {desc_str}")
                print(f"  Missing Parts: {parts_str}")
                print(f"  Reported Date: {reported_str}")
                print(f"  Days Open: {days_open} days (as of {current_date_str})")
                print(f"  Assigned Technician: {tech_name}")
                print("-" * 100)
                print()

            print("=" * 100)
            print()

        print()

        print("=" * 80)
        print("END OF MONTHLY SUMMARY REPORT")
        print("=" * 80)
    
        log_debug("Report generation completed successfully")
        return {
            'pm_completions': pm_completions,
            'outstanding_completions': outstanding_completions,
            'total_pm_completions': pm_completions + outstanding_completions,
            'cannot_find_count': cf_count,
            'run_to_failure_count': rtf_count,
            'deactivated_count': deactivated_count,
            'cms_created': cms_created,
            'cms_closed': cms_closed,
            'cms_open_current': cms_open_current,
            'total_hours': pm_total_hours,
            'outstanding_hours': outstanding_total_hours,
            'avg_hours': pm_avg_hours,
            'outstanding_avg_hours': outstanding_avg_hours,
            'month': month_name,
            'year': year
        }
    except Exception as e:
        log_debug(f"ERROR OCCURRED: {type(e).__name__}: {str(e)}")
        log_debug(f"Full traceback:\n{traceback.format_exc()}")
        # Re-raise the exception so the UI can display it
        raise

def export_professional_monthly_report_pdf(conn, month=None, year=None):
        """
        Generate a professional monthly report PDF
        """
        from reportlab.lib.pagesizes import letter, landscape
        from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.units import inch
        from reportlab.lib import colors
        from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
        from tkinter import filedialog

        try:
            # Rollback any failed transaction before starting
            conn.rollback()
        except Exception:
            pass  # Ignore if there's no transaction to rollback

        cursor = conn.cursor()

        # Use current month/year if not specified
        if month is None or year is None:
            now = datetime.now()
            month = month or now.month
            year = year or now.year

        # Ensure month and year are integers
        month = int(month)
        year = int(year)

        month_name = calendar.month_name[month]

        # Create PDF filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        default_filename = f"AIT_Monthly_Report_{month_name}_{year}_{timestamp}.pdf"

        # Ask user where to save the file
        filename = filedialog.asksaveasfilename(
            title="Save Monthly Report",
            initialdir=os.path.expanduser("~/Documents"),
            initialfile=default_filename,
            defaultextension=".pdf",
            filetypes=[("PDF files", "*.pdf"), ("All files", "*.*")]
        )

        if not filename:
            return None  # User cancelled

        # Create document
        doc = SimpleDocTemplate(filename, pagesize=letter,
                            rightMargin=36, leftMargin=36,
                            topMargin=50, bottomMargin=36)
    
        story = []
        styles = getSampleStyleSheet()
    
        # ==================== CUSTOM STYLES ====================
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=24,
            textColor=colors.HexColor('#1a365d'),
            spaceAfter=30,
            alignment=TA_CENTER,
            fontName='Helvetica-Bold'
        )
    
        heading_style = ParagraphStyle(
            'CustomHeading',
            parent=styles['Heading2'],
            fontSize=14,
            textColor=colors.HexColor('#2c5282'),
            spaceAfter=12,
            spaceBefore=12,
            fontName='Helvetica-Bold'
        )
    
        subheading_style = ParagraphStyle(
            'CustomSubHeading',
            parent=styles['Heading3'],
            fontSize=11,
            textColor=colors.HexColor('#2d3748'),
            spaceAfter=6,
            fontName='Helvetica-Bold'
        )

        body_style = ParagraphStyle(
            'CustomBody',
            parent=styles['Normal'],
            fontSize=10,
            textColor=colors.HexColor('#2d3748'),
            spaceAfter=6,
            fontName='Helvetica'
        )

        # ==================== TITLE PAGE ====================
        story.append(Paragraph("AIRBUS AIT", title_style))
        story.append(Paragraph("Monthly Maintenance Summary Report", 
                            ParagraphStyle('Subtitle', parent=styles['Normal'], 
                                        fontSize=16, alignment=TA_CENTER, 
                                        textColor=colors.HexColor('#4a5568'))))
        story.append(Spacer(1, 20))
    
        # Report metadata box
        meta_data = [
            ['Report Period:', f'{month_name} {year}'],
            ['Generated:', datetime.now().strftime('%B %d, %Y at %I:%M %p')],
            ['Report Type:', 'Comprehensive Monthly Summary']
        ]
    
        meta_table = Table(meta_data, colWidths=[2*inch, 4*inch])
        meta_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#e2e8f0')),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#2d3748')),
            ('ALIGN', (0, 0), (0, -1), 'RIGHT'),
            ('ALIGN', (1, 0), (1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#cbd5e0')),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('LEFTPADDING', (0, 0), (-1, -1), 12),
            ('RIGHTPADDING', (0, 0), (-1, -1), 12),
            ('TOPPADDING', (0, 0), (-1, -1), 8),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ]))
    
        story.append(meta_table)
        story.append(Spacer(1, 30))
    
        # ==================== EXECUTIVE SUMMARY ====================
        story.append(Paragraph("EXECUTIVE SUMMARY", heading_style))
        story.append(Spacer(1, 10))
    
        # Get summary data - ONLY PMs assigned AND completed in the same month
        # EXCLUDE special types: Cannot Find, Run to Failure
        cursor.execute('''
            SELECT
                COUNT(*) as total_completions,
                SUM(labor_hours + labor_minutes/60.0) as total_hours,
                AVG(labor_hours + labor_minutes/60.0) as avg_hours
            FROM pm_completions
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND pm_due_date IS NOT NULL
            AND pm_due_date != ''
            AND EXTRACT(YEAR FROM pm_due_date::date) = %s
            AND EXTRACT(MONTH FROM pm_due_date::date) = %s
            AND pm_type NOT IN ('CANNOT FIND', 'Cannot Find', 'Run to Failure', 'RTF')
        ''', (year, month, year, month))

        pm_results = cursor.fetchone()
        pm_completions = pm_results[0] or 0
        pm_total_hours = pm_results[1] or 0.0
        pm_avg_hours = pm_results[2] or 0.0

        # Get Outstanding Completions (assigned before, completed this month, OR NULL due date)
        # EXCLUDE special types: Cannot Find, Run to Failure
        cursor.execute('''
            SELECT
                COUNT(*) as total_completions,
                SUM(labor_hours + labor_minutes/60.0) as total_hours,
                AVG(labor_hours + labor_minutes/60.0) as avg_hours
            FROM pm_completions
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND (
                pm_due_date IS NULL
                OR pm_due_date = ''
                OR EXTRACT(YEAR FROM pm_due_date::date) != %s
                OR EXTRACT(MONTH FROM pm_due_date::date) != %s
            )
            AND pm_type NOT IN ('CANNOT FIND', 'Cannot Find', 'Run to Failure', 'RTF')
        ''', (year, month, year, month))

        outstanding_results = cursor.fetchone()
        outstanding_completions = outstanding_results[0] or 0
        outstanding_total_hours = outstanding_results[1] or 0.0
        outstanding_avg_hours = outstanding_results[2] or 0.0
    
        # Get CM data
        cursor.execute('''
            SELECT COUNT(*) FROM corrective_maintenance
            WHERE EXTRACT(YEAR FROM created_date::date) = %s AND EXTRACT(MONTH FROM created_date::date) = %s
        ''', (year, month))
        cms_created = cursor.fetchone()[0] or 0

        cursor.execute('''
            SELECT COUNT(*) FROM corrective_maintenance
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s  AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND (status = 'Closed' OR status = 'Completed')
        ''', (year, month))
        cms_closed = cursor.fetchone()[0] or 0

        # Get Cannot Find data for this month (reported missing)
        cursor.execute('''
            SELECT COUNT(DISTINCT bfm_equipment_no) FROM cannot_find_assets
            WHERE EXTRACT(YEAR FROM reported_date::date) = %s
            AND EXTRACT(MONTH FROM reported_date::date) = %s
            AND status = 'Missing'
        ''', (year, month))
        cf_count = cursor.fetchone()[0] or 0

        # Get details of Cannot Find assets reported this month
        cursor.execute('''
            SELECT bfm_equipment_no, description, location, reported_date, technician_name, reported_by
            FROM cannot_find_assets
            WHERE EXTRACT(YEAR FROM reported_date::date) = %s
            AND EXTRACT(MONTH FROM reported_date::date) = %s
            AND status = 'Missing'
            ORDER BY reported_date DESC
        ''', (year, month))
        cannot_find_assets = cursor.fetchall()

        # Get Mark as Found data for this month
        cursor.execute('''
            SELECT COUNT(*) FROM cannot_find_assets
            WHERE EXTRACT(YEAR FROM found_date::date) = %s
            AND EXTRACT(MONTH FROM found_date::date) = %s
            AND status = 'Found'
        ''', (year, month))
        found_count = cursor.fetchone()[0] or 0

        # Get details of Mark as Found assets for this month
        cursor.execute('''
            SELECT bfm_equipment_no, description, location, reported_date, found_date, found_by
            FROM cannot_find_assets
            WHERE EXTRACT(YEAR FROM found_date::date) = %s
            AND EXTRACT(MONTH FROM found_date::date) = %s
            AND status = 'Found'
            ORDER BY found_date DESC
        ''', (year, month))
        found_assets = cursor.fetchall()

        # Get Run to Failure entries count
        cursor.execute('''
            SELECT COUNT(*)
            FROM run_to_failure_assets
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
        ''', (year, month))
        rtf_count = cursor.fetchone()[0] or 0

        # Get Deactivated entries count
        cursor.execute('''
            SELECT COUNT(*)
            FROM deactivated_assets
            WHERE EXTRACT(YEAR FROM deactivated_date::date) = %s
            AND EXTRACT(MONTH FROM deactivated_date::date) = %s
            AND status = 'Deactivated'
        ''', (year, month))
        deactivated_count = cursor.fetchone()[0] or 0

        # Summary highlights table
        summary_data = [
            ['METRIC', 'VALUE'],
            ['PM Completions (Assigned & Completed This Month)', f'{pm_completions:,}'],
            ['Outstanding Completions (Assigned Before, Completed This Month)', f'{outstanding_completions:,}'],
            ['Total PMs Completed This Month', f'{pm_completions + outstanding_completions:,}'],
            ['PM Labor Hours (This Month Assigned)', f'{pm_total_hours:.1f} hrs'],
            ['Outstanding Labor Hours', f'{outstanding_total_hours:.1f} hrs'],
            ['Average Time per PM (This Month Assigned)', f'{pm_avg_hours:.1f} hrs'],
            ['CMs Created', f'{cms_created:,}'],
            ['CMs Closed', f'{cms_closed:,}']
        ]
    
        summary_table = Table(summary_data, colWidths=[3.5*inch, 2.5*inch])
        summary_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2c5282')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('ALIGN', (1, 1), (1, -1), 'RIGHT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 12),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 11),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#cbd5e0')),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('LEFTPADDING', (0, 0), (-1, -1), 12),
            ('RIGHTPADDING', (0, 0), (-1, -1), 12),
            ('TOPPADDING', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 10),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#f7fafc')])
        ]))
    
        story.append(summary_table)
        story.append(Spacer(1, 25))

        # ==================== OUTSTANDING PM COMPLETIONS DETAIL ====================
        if outstanding_completions > 0:
            story.append(Paragraph(f"OUTSTANDING PM COMPLETIONS", heading_style))
            story.append(Paragraph(f"PMs Assigned Before {month_name} but Completed in {month_name}", subheading_style))
            story.append(Spacer(1, 10))

            # Get detailed outstanding PM data
            cursor.execute('''
                SELECT
                    bfm_equipment_no,
                    pm_type,
                    pm_due_date,
                    completion_date,
                    technician_name,
                    labor_hours,
                    labor_minutes
                FROM pm_completions
                WHERE EXTRACT(YEAR FROM completion_date::date) = %s
                AND EXTRACT(MONTH FROM completion_date::date) = %s
                AND (
                    pm_due_date IS NULL
                    OR pm_due_date = ''
                    OR EXTRACT(YEAR FROM pm_due_date::date) != %s
                    OR EXTRACT(MONTH FROM pm_due_date::date) != %s
                )
                AND pm_type NOT IN ('CANNOT FIND', 'Cannot Find', 'Run to Failure', 'RTF')
                ORDER BY technician_name, completion_date
            ''', (year, month, year, month))

            outstanding_pms = cursor.fetchall()

            # Build outstanding PMs table
            outstanding_table_data = [
                ['Equipment', 'PM Type', 'Assigned', 'Completed', 'Labor Hrs', 'Technician']
            ]

            for bfm_no, pm_type, assigned_date, completed_date, tech, labor_hrs, labor_mins in outstanding_pms:
                assigned_short = str(assigned_date)[:10] if assigned_date else "Unknown"
                completed_short = str(completed_date)[:10] if completed_date else "Unknown"
                bfm_short = (bfm_no[:12] if bfm_no else "N/A")
                tech_short = (tech[:15] if tech else "Unassigned")
                pm_type_short = (pm_type[:10] if pm_type else "N/A")
                total_hours = (labor_hrs or 0) + ((labor_mins or 0) / 60.0)
                hours_str = f"{total_hours:.1f}h"

                outstanding_table_data.append([
                    bfm_short, pm_type_short, assigned_short, completed_short, hours_str, tech_short
                ])

            outstanding_table = Table(outstanding_table_data, colWidths=[1.2*inch, 0.8*inch, 0.8*inch, 0.8*inch, 0.7*inch, 1.2*inch])
            outstanding_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#e53e3e')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 9),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 8),
                ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#cbd5e0')),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('LEFTPADDING', (0, 0), (-1, -1), 6),
                ('RIGHTPADDING', (0, 0), (-1, -1), 6),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#fff5f5')])
            ]))

            story.append(outstanding_table)
            story.append(Spacer(1, 10))

            # Add summary note
            summary_note = Paragraph(
                f"<b>Total Outstanding Completions:</b> {outstanding_completions} | "
                f"<b>Total Labor Hours:</b> {outstanding_total_hours:.1f} hrs",
                body_style
            )
            story.append(summary_note)
            story.append(Spacer(1, 25))

        # ==================== CORRECTIVE MAINTENANCE DETAIL ====================
        story.append(Paragraph("CORRECTIVE MAINTENANCE ANALYSIS", heading_style))
        story.append(Spacer(1, 10))
    
        # Get CM breakdown
        cursor.execute('''
            SELECT COUNT(*) FROM corrective_maintenance
            WHERE EXTRACT(YEAR FROM created_date::date) = %s AND EXTRACT(MONTH FROM created_date::date) = %s
            AND EXTRACT(YEAR FROM completion_date::date) = %s AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND (status = 'Closed' OR status = 'Completed')
        ''', (year, month, year, month))
        cms_created_and_closed = cursor.fetchone()[0] or 0

        cursor.execute('''
            SELECT COUNT(*) FROM corrective_maintenance
            WHERE (EXTRACT(YEAR FROM created_date::date) != %s OR EXTRACT(MONTH FROM created_date::date) != %s)
            AND EXTRACT(YEAR FROM completion_date::date) = %s AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND (status = 'Closed' OR status = 'Completed')
        ''', (year, month, year, month))
        cms_closed_from_before = cursor.fetchone()[0] or 0

        # Calculate the last day of the reporting month (reuse from earlier in function)
        last_day = calendar.monthrange(year, month)[1]
        month_end_date = f"{year}-{month:02d}-{last_day:02d}"

        # Currently open CMs (as of the end of the reporting month)
        cursor.execute('''
            SELECT COUNT(*)
            FROM corrective_maintenance
            WHERE created_date::date <= %s::date
            AND (
                status = 'Open'
                OR (status IN ('Closed', 'Completed') AND completion_date::date > %s::date)
            )
        ''', (month_end_date, month_end_date))
        cms_open_current = cursor.fetchone()[0] or 0

        # Get total days open for CMs that were open as of the end of the reporting month
        cursor.execute('''
            SELECT
                SUM(%s::date - created_date::date) as total_days_open,
                AVG(%s::date - created_date::date) as avg_days_open
            FROM corrective_maintenance
            WHERE created_date::date <= %s::date
            AND (
                status = 'Open'
                OR (status IN ('Closed', 'Completed') AND completion_date::date > %s::date)
            )
        ''', (month_end_date, month_end_date, month_end_date, month_end_date))

        open_days_result = cursor.fetchone()
        cms_total_days_open = open_days_result[0] or 0
        cms_avg_days_open = open_days_result[1] or 0.0

        # Get CM total labor hours for CMs closed this month
        cursor.execute('''
            SELECT
                SUM(labor_hours) as total_hours,
                AVG(labor_hours) as avg_hours
            FROM corrective_maintenance
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND (status = 'Closed' OR status = 'Completed')
        ''', (year, month))

        cm_hours_result = cursor.fetchone()
        cm_total_hours = cm_hours_result[0] or 0.0
        cm_avg_hours = cm_hours_result[1] or 0.0

        # Get total days open for CMs closed this month (time to close)
        cursor.execute('''
            SELECT
                SUM(completion_date::date - created_date::date) as total_days_to_close,
                AVG(completion_date::date - created_date::date) as avg_days_to_close
            FROM corrective_maintenance
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND (status = 'Closed' OR status = 'Completed')
        ''', (year, month))

        closed_days_result = cursor.fetchone()
        cms_total_days_to_close = closed_days_result[0] or 0
        cms_avg_days_to_close = closed_days_result[1] or 0.0

        # Build CM breakdown data with conditional days open/closed
        cm_breakdown_data = [
            ['CATEGORY', 'VALUE'],
            ['CMs Created This Month', str(cms_created)],
            ['CMs Closed This Month', str(cms_closed)],
            ['  - Created & Closed Same Month', str(cms_created_and_closed)],
            [f'  - Carried Over from Prior Months', str(cms_closed_from_before)]
        ]

        # Add days to close metrics if there are closed CMs
        if cms_closed > 0:
            cm_breakdown_data.extend([
                ['  - Total Days to Close (All Closed CMs)', f'{cms_total_days_to_close} days'],
                ['  - Average Days to Close per CM', f'{cms_avg_days_to_close:.1f} days']
            ])

        # Add labor hours
        cm_breakdown_data.extend([
            ['CM Total Labor Hours (Closed)', f'{cm_total_hours:.1f} hours'],
            ['CM Average Hours per Closure', f'{cm_avg_hours:.1f} hours'],
            ['Currently Open CMs', str(cms_open_current)]
        ])

        # Add days open metrics if there are open CMs
        if cms_open_current > 0:
            cm_breakdown_data.extend([
                ['  - Total Days Open (All Open CMs)', f'{cms_total_days_open} days'],
                ['  - Average Days Open per CM', f'{cms_avg_days_open:.1f} days']
            ])
    
        cm_table = Table(cm_breakdown_data, colWidths=[4.5*inch, 1.5*inch])
        cm_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2c5282')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (0, -1), 'LEFT'),
            ('ALIGN', (1, 0), (1, -1), 'RIGHT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 11),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 10),
            ('BACKGROUND', (0, 1), (-1, 2), colors.white),
            ('BACKGROUND', (0, 3), (-1, -1), colors.HexColor('#f7fafc')),
            ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#cbd5e0')),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('LEFTPADDING', (0, 0), (-1, -1), 12),
            ('LEFTPADDING', (0, 3), (0, 4), 24),  # Indent sub-items
            ('RIGHTPADDING', (0, 0), (-1, -1), 12),
            ('TOPPADDING', (0, 0), (-1, -1), 8),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ]))
    
        story.append(cm_table)
        story.append(Spacer(1, 20))

        # ==================== OVERALL MAINTENANCE EFFICIENCY ====================
        story.append(Paragraph("OVERALL MAINTENANCE EFFICIENCY", heading_style))
        story.append(Spacer(1, 10))

        # Define constants for efficiency calculation
        TOTAL_TECHNICIANS = 9
        ANNUAL_HOURS_PER_TECHNICIAN = 1900
        WEEKLY_AVAILABLE_HOURS = 328.85
        MONTHLY_AVAILABLE_HOURS = 1425.0  # Updated from 1485.0 hours
        TARGET_EFFICIENCY_RATE = 80.0

        # Calculate Cannot Find hours (2 hours per asset)
        HOURS_PER_CANNOT_FIND = 2.0
        cannot_find_hours = cf_count * HOURS_PER_CANNOT_FIND

        # Calculate total maintenance hours (PM + Outstanding PM + CM)
        total_maintenance_hours = pm_total_hours + outstanding_total_hours + cm_total_hours

        # Calculate efficiency rate
        efficiency_rate = (total_maintenance_hours / MONTHLY_AVAILABLE_HOURS) * 100 if MONTHLY_AVAILABLE_HOURS > 0 else 0.0

        # Determine status and color
        if efficiency_rate >= TARGET_EFFICIENCY_RATE:
            efficiency_status = "MEETS TARGET "
            status_color = colors.HexColor('#22c55e')  # Green
        else:
            efficiency_status = "BELOW TARGET "
            status_color = colors.HexColor('#ef4444')  # Red

        # Build efficiency data table
        efficiency_data = [
            ['METRIC', 'VALUE'],
            ['Total PM Hours', f'{pm_total_hours:.1f} hours'],
            ['Total CM Hours', f'{cm_total_hours:.1f} hours'],
            ['Total Maintenance Hours', f'{total_maintenance_hours:.1f} hours'],
            ['Cannot Find Assets Count', f'{cf_count}'],
            ['Cannot Find Search Hours', f'{cannot_find_hours:.1f} hours'],
            ['  (Based on)', f'{HOURS_PER_CANNOT_FIND:.1f} hours per Cannot Find asset'],
            ['Monthly Available Hours', f'{MONTHLY_AVAILABLE_HOURS:.1f} hours'],
            ['  (Based on)', f'{TOTAL_TECHNICIANS} technicians  {ANNUAL_HOURS_PER_TECHNICIAN} hrs/year  12 months'],
            ['  (Weekly Available)', f'{WEEKLY_AVAILABLE_HOURS:.2f} hours'],
            ['Overall Efficiency Rate', f'{efficiency_rate:.1f}%'],
            ['Target Efficiency Rate', f'{TARGET_EFFICIENCY_RATE:.1f}%'],
            ['Status', efficiency_status]
        ]

        efficiency_table = Table(efficiency_data, colWidths=[3*inch, 3*inch])
        efficiency_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2c5282')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (0, -1), 'LEFT'),
            ('ALIGN', (1, 0), (1, -1), 'RIGHT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 11),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 10),
            ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#f7fafc')),
            ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#cbd5e0')),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('LEFTPADDING', (0, 0), (-1, -1), 12),
            ('LEFTPADDING', (0, 6), (0, 6), 24),  # Indent sub-items for Cannot Find calculation
            ('LEFTPADDING', (0, 8), (0, 9), 24),  # Indent sub-items for Available Hours calculation details
            ('RIGHTPADDING', (0, 0), (-1, -1), 12),
            ('TOPPADDING', (0, 0), (-1, -1), 8),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
            # Highlight efficiency rate and status rows
            ('BACKGROUND', (0, 10), (-1, 10), colors.HexColor('#e0f2fe')),  # Light blue for efficiency rate
            ('FONTNAME', (0, 10), (-1, 10), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 10), (-1, 10), 11),
            ('BACKGROUND', (0, 12), (-1, 12), colors.HexColor('#f0fdf4') if efficiency_rate >= TARGET_EFFICIENCY_RATE else colors.HexColor('#fef2f2')),
            ('TEXTCOLOR', (1, 12), (1, 12), status_color),
            ('FONTNAME', (0, 12), (-1, 12), 'Helvetica-Bold'),
        ]))

        story.append(efficiency_table)
        story.append(Spacer(1, 20))

        # ==================== DETAILED BREAKDOWN: DAYS TO CLOSE ====================
        if cms_closed > 0:
            story.append(Paragraph("DETAILED BREAKDOWN: DAYS TO CLOSE", heading_style))
            story.append(Spacer(1, 8))
            story.append(Paragraph(
                f"<i>Calculation: Days to Close = Date Closed - Date Created</i>",
                ParagraphStyle('ItalicStyle', parent=body_style, fontSize=9, textColor=colors.HexColor('#4a5568'))
            ))
            story.append(Spacer(1, 12))

            # Query all closed CMs with their details
            cursor.execute('''
                SELECT
                    cm.cm_number,
                    cm.created_date,
                    cm.completion_date,
                    cm.assigned_technician,
                    cm.bfm_equipment_no,
                    cm.description,
                    cm.priority,
                    (cm.completion_date::date - cm.created_date::date) as days_to_close
                FROM corrective_maintenance cm
                WHERE EXTRACT(YEAR FROM cm.completion_date::date) = %s
                AND EXTRACT(MONTH FROM cm.completion_date::date) = %s
                AND (cm.status = 'Closed' OR cm.status = 'Completed')
                ORDER BY cm.completion_date
            ''', (year, month))

            closed_cms = cursor.fetchall()

            for cm_data in closed_cms:
                cm_number, created_date, completion_date, technician, equipment, description, priority, days = cm_data

                # Format dates - handle both string and datetime objects
                if created_date:
                    created_str = created_date.strftime('%Y-%m-%d') if hasattr(created_date, 'strftime') else str(created_date)[:10]
                else:
                    created_str = "Unknown"

                if completion_date:
                    completed_str = completion_date.strftime('%Y-%m-%d') if hasattr(completion_date, 'strftime') else str(completion_date)[:10]
                else:
                    completed_str = "Unknown"

                tech_name = technician if technician else "Unassigned"
                equip_str = equipment if equipment else "N/A"
                desc_str = (description[:80] + "...") if description and len(description) > 80 else (description or "No description")
                priority_str = priority if priority else "N/A"

                # CM Header with key info
                story.append(Paragraph(
                    f"<b>CM Number: {cm_number}</b>",
                    ParagraphStyle('CMHeader', parent=body_style, fontSize=11, textColor=colors.HexColor('#2c5282'), spaceAfter=4)
                ))

                # CM Details Table
                cm_details_data = [
                    ['Priority:', priority_str],
                    ['Equipment:', equip_str],
                    ['Description:', desc_str],
                    ['Date Created:', created_str],
                    ['Date Closed:', completed_str],
                    ['Days to Close:', f'{days} days ({completed_str} - {created_str})'],
                    ['Technician:', tech_name]
                ]

                cm_details_table = Table(cm_details_data, colWidths=[1.3*inch, 4.7*inch])
                cm_details_table.setStyle(TableStyle([
                    ('ALIGN', (0, 0), (0, -1), 'LEFT'),
                    ('ALIGN', (1, 0), (1, -1), 'LEFT'),
                    ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                    ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
                    ('FONTSIZE', (0, 0), (-1, -1), 9),
                    ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#2d3748')),
                    ('LEFTPADDING', (0, 0), (-1, -1), 6),
                    ('RIGHTPADDING', (0, 0), (-1, -1), 6),
                    ('TOPPADDING', (0, 0), (-1, -1), 3),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
                    ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ]))

                story.append(cm_details_table)
                story.append(Spacer(1, 8))

                # Get MRO stock items used for this CM
                cursor.execute('''
                    SELECT
                        cpu.part_number,
                        mro.name,
                        cpu.quantity_used,
                        mro.unit_price,
                        cpu.total_cost,
                        mro.unit_of_measure
                    FROM cm_parts_used cpu
                    LEFT JOIN mro_inventory mro ON cpu.part_number = mro.part_number
                    WHERE cpu.cm_number = %s
                    ORDER BY cpu.recorded_date
                ''', (cm_number,))

                parts_used = cursor.fetchall()

                if parts_used:
                    story.append(Paragraph(
                        "<b>MRO Stock Items Used:</b>",
                        ParagraphStyle('PartsHeader', parent=body_style, fontSize=9, spaceAfter=4)
                    ))

                    # Build parts table
                    parts_table_data = [['Part Number', 'Part Name', 'Qty', 'Unit Price', 'Total Cost']]
                    total_cm_cost = 0.0

                    for part_number, name, qty, unit_price, total_cost, uom in parts_used:
                        part_name = name if name else "Unknown Part"
                        quantity = qty if qty else 0
                        price = unit_price if unit_price else 0.0
                        # Always use current unit_price from mro_inventory, not cached total_cost
                        cost = quantity * price
                        unit = uom if uom else "EA"

                        parts_table_data.append([
                            part_number,
                            part_name[:30] + "..." if len(part_name) > 30 else part_name,
                            f'{quantity} {unit}',
                            f'${price:.2f}',
                            f'${cost:.2f}'
                        ])
                        total_cm_cost += cost

                    # Add total row
                    parts_table_data.append(['', '', '', 'Total:', f'${total_cm_cost:.2f}'])

                    parts_table = Table(parts_table_data, colWidths=[1.2*inch, 2.3*inch, 0.8*inch, 0.9*inch, 0.8*inch])
                    parts_table.setStyle(TableStyle([
                        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#4a5568')),
                        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                        ('ALIGN', (0, 0), (1, -1), 'LEFT'),
                        ('ALIGN', (2, 0), (-1, -1), 'RIGHT'),
                        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                        ('FONTSIZE', (0, 0), (-1, 0), 8),
                        ('FONTNAME', (0, 1), (-1, -2), 'Helvetica'),
                        ('FONTSIZE', (0, 1), (-1, -2), 8),
                        ('FONTNAME', (0, -1), (-1, -1), 'Helvetica-Bold'),
                        ('FONTSIZE', (0, -1), (-1, -1), 9),
                        ('BACKGROUND', (0, 1), (-1, -2), colors.white),
                        ('BACKGROUND', (0, -1), (-1, -1), colors.HexColor('#edf2f7')),
                        ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#cbd5e0')),
                        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                        ('LEFTPADDING', (0, 0), (-1, -1), 6),
                        ('RIGHTPADDING', (0, 0), (-1, -1), 6),
                        ('TOPPADDING', (0, 0), (-1, -1), 5),
                        ('BOTTOMPADDING', (0, 0), (-1, -1), 5),
                        ('ROWBACKGROUNDS', (0, 1), (-1, -2), [colors.white, colors.HexColor('#f7fafc')])
                    ]))

                    story.append(parts_table)
                else:
                    story.append(Paragraph(
                        "<b>MRO Stock Items Used:</b> None recorded",
                        ParagraphStyle('NoPartsStyle', parent=body_style, fontSize=9, textColor=colors.HexColor('#718096'))
                    ))

                # Add separator between CMs
                story.append(Spacer(1, 8))
                story.append(Paragraph(
                    "" * 100,
                    ParagraphStyle('Separator', parent=body_style, fontSize=8, textColor=colors.HexColor('#cbd5e0'))
                ))
                story.append(Spacer(1, 12))

            story.append(Spacer(1, 10))

        # CM Details from previous months (if any)
        if cms_closed_from_before > 0:
            story.append(Paragraph("CMs Carried Over from Prior Months", subheading_style))
            story.append(Spacer(1, 8))
        
            cursor.execute('''
                SELECT cm_number, bfm_equipment_no, created_date, completion_date, assigned_technician
                FROM corrective_maintenance
                WHERE (EXTRACT(YEAR FROM created_date::date) != %s OR EXTRACT(MONTH FROM created_date::date) != %s)
                AND EXTRACT(YEAR FROM completion_date::date) = %s AND EXTRACT(MONTH FROM completion_date::date) = %s
                AND (status = 'Closed' OR status = 'Completed')
                ORDER BY completion_date
            ''', (year, month, year, month))
        
            old_cms = cursor.fetchall()
        
            cm_detail_data = [['CM Number', 'Equipment', 'Created', 'Closed', 'Technician']]
        
            for cm_number, bfm, created, completed, tech in old_cms:
                created_short = str(created)[:10] if created else "N/A"
                completed_short = str(completed)[:10] if completed else "N/A"
                bfm_short = (bfm[:12] + '...' if len(str(bfm)) > 12 else bfm) if bfm else "N/A"
                tech_short = (tech[:15] + '...' if len(str(tech)) > 15 else tech) if tech else "Unassigned"
                cm_detail_data.append([cm_number, bfm_short, created_short, completed_short, tech_short])
        
            cm_detail_table = Table(cm_detail_data, colWidths=[1.1*inch, 1.3*inch, 1.1*inch, 1.1*inch, 1.4*inch])
            cm_detail_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#4a5568')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 9),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#cbd5e0')),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('LEFTPADDING', (0, 0), (-1, -1), 6),
                ('RIGHTPADDING', (0, 0), (-1, -1), 6),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#f7fafc')])
            ]))
        
            story.append(cm_detail_table)
            story.append(Spacer(1, 20))

        # ==================== DETAILED BREAKDOWN: CURRENTLY OPEN CMs ====================
        if cms_open_current > 0:
            story.append(Paragraph("DETAILED BREAKDOWN: CURRENTLY OPEN CMs", heading_style))
            story.append(Spacer(1, 8))
            story.append(Paragraph(
                f"<i>Calculation: Days Open = Current Date - Date Created</i>",
                ParagraphStyle('ItalicStyle', parent=body_style, fontSize=9, textColor=colors.HexColor('#4a5568'))
            ))
            story.append(Spacer(1, 12))

            # Query all currently open CMs with their details
            cursor.execute('''
                SELECT
                    cm.cm_number,
                    cm.created_date,
                    cm.assigned_technician,
                    cm.bfm_equipment_no,
                    cm.description,
                    cm.priority,
                    (CURRENT_DATE - cm.created_date::date) as days_open
                FROM corrective_maintenance cm
                WHERE cm.status = 'Open'
                ORDER BY cm.created_date
            ''')

            open_cms = cursor.fetchall()

            for cm_data in open_cms:
                cm_number, created_date, technician, equipment, description, priority, days_open = cm_data

                # Format dates - handle both string and datetime objects
                if created_date:
                    created_str = created_date.strftime('%Y-%m-%d') if hasattr(created_date, 'strftime') else str(created_date)[:10]
                else:
                    created_str = "Unknown"

                current_date_str = datetime.now().strftime('%Y-%m-%d')
                tech_name = technician if technician else "Unassigned"
                equip_str = equipment if equipment else "N/A"
                desc_str = (description[:80] + "...") if description and len(description) > 80 else (description or "No description")
                priority_str = priority if priority else "N/A"

                # CM Header with key info
                story.append(Paragraph(
                    f"<b>CM Number: {cm_number}</b>",
                    ParagraphStyle('CMHeader', parent=body_style, fontSize=11, textColor=colors.HexColor('#2c5282'), spaceAfter=4)
                ))

                # CM Details Table
                cm_details_data = [
                    ['Priority:', priority_str],
                    ['Equipment:', equip_str],
                    ['Description:', desc_str],
                    ['Date Created:', created_str],
                    ['Days Open:', f'{days_open} days (as of {current_date_str})'],
                    ['Technician:', tech_name]
                ]

                cm_details_table = Table(cm_details_data, colWidths=[1.3*inch, 4.7*inch])
                cm_details_table.setStyle(TableStyle([
                    ('ALIGN', (0, 0), (0, -1), 'LEFT'),
                    ('ALIGN', (1, 0), (1, -1), 'LEFT'),
                    ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                    ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
                    ('FONTSIZE', (0, 0), (-1, -1), 9),
                    ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#2d3748')),
                    ('LEFTPADDING', (0, 0), (-1, -1), 6),
                    ('RIGHTPADDING', (0, 0), (-1, -1), 6),
                    ('TOPPADDING', (0, 0), (-1, -1), 3),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
                    ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ]))

                story.append(cm_details_table)
                story.append(Spacer(1, 8))

                # Get MRO stock items used for this CM (if any parts were already consumed during work)
                cursor.execute('''
                    SELECT
                        cpu.part_number,
                        mro.name,
                        cpu.quantity_used,
                        mro.unit_price,
                        cpu.total_cost,
                        mro.unit_of_measure
                    FROM cm_parts_used cpu
                    LEFT JOIN mro_inventory mro ON cpu.part_number = mro.part_number
                    WHERE cpu.cm_number = %s
                    ORDER BY cpu.recorded_date
                ''', (cm_number,))

                parts_used = cursor.fetchall()

                if parts_used:
                    story.append(Paragraph(
                        "<b>MRO Stock Items Used (work in progress):</b>",
                        ParagraphStyle('PartsHeader', parent=body_style, fontSize=9, spaceAfter=4)
                    ))

                    # Build parts table
                    parts_table_data = [['Part Number', 'Part Name', 'Qty', 'Unit Price', 'Total Cost']]
                    total_cm_cost = 0.0

                    for part_number, name, qty, unit_price, total_cost, uom in parts_used:
                        part_name = name if name else "Unknown Part"
                        quantity = qty if qty else 0
                        price = unit_price if unit_price else 0.0
                        # Always use current unit_price from mro_inventory, not cached total_cost
                        cost = quantity * price
                        unit = uom if uom else "EA"

                        parts_table_data.append([
                            part_number,
                            part_name[:30] + "..." if len(part_name) > 30 else part_name,
                            f'{quantity} {unit}',
                            f'${price:.2f}',
                            f'${cost:.2f}'
                        ])
                        total_cm_cost += cost

                    # Add total row
                    parts_table_data.append(['', '', '', 'Total (so far):', f'${total_cm_cost:.2f}'])

                    parts_table = Table(parts_table_data, colWidths=[1.2*inch, 2.3*inch, 0.8*inch, 0.9*inch, 0.8*inch])
                    parts_table.setStyle(TableStyle([
                        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#4a5568')),
                        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                        ('ALIGN', (0, 0), (1, -1), 'LEFT'),
                        ('ALIGN', (2, 0), (-1, -1), 'RIGHT'),
                        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                        ('FONTSIZE', (0, 0), (-1, 0), 8),
                        ('FONTNAME', (0, 1), (-1, -2), 'Helvetica'),
                        ('FONTSIZE', (0, 1), (-1, -2), 8),
                        ('FONTNAME', (0, -1), (-1, -1), 'Helvetica-Bold'),
                        ('FONTSIZE', (0, -1), (-1, -1), 9),
                        ('BACKGROUND', (0, 1), (-1, -2), colors.white),
                        ('BACKGROUND', (0, -1), (-1, -1), colors.HexColor('#edf2f7')),
                        ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#cbd5e0')),
                        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                        ('LEFTPADDING', (0, 0), (-1, -1), 6),
                        ('RIGHTPADDING', (0, 0), (-1, -1), 6),
                        ('TOPPADDING', (0, 0), (-1, -1), 5),
                        ('BOTTOMPADDING', (0, 0), (-1, -1), 5),
                        ('ROWBACKGROUNDS', (0, 1), (-1, -2), [colors.white, colors.HexColor('#f7fafc')])
                    ]))

                    story.append(parts_table)
                else:
                    story.append(Paragraph(
                        "<b>MRO Stock Items Used:</b> None recorded yet",
                        ParagraphStyle('NoPartsStyle', parent=body_style, fontSize=9, textColor=colors.HexColor('#718096'))
                    ))

                # Add separator between CMs
                story.append(Spacer(1, 8))
                story.append(Paragraph(
                    "" * 100,
                    ParagraphStyle('Separator', parent=body_style, fontSize=8, textColor=colors.HexColor('#cbd5e0'))
                ))
                story.append(Spacer(1, 12))

            story.append(Spacer(1, 10))

        # ==================== CM BREAKDOWN BY PRIORITY ====================
        story.append(Paragraph("CM BREAKDOWN BY PRIORITY (Closed This Month)", subheading_style))
        story.append(Spacer(1, 8))

        cursor.execute('''
            SELECT
                priority,
                COUNT(*) as count,
                SUM(labor_hours) as total_hours,
                AVG(labor_hours) as avg_hours
            FROM corrective_maintenance
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND (status = 'Closed' OR status = 'Completed')
            GROUP BY priority
            ORDER BY
                CASE priority
                    WHEN 'Critical' THEN 1
                    WHEN 'High' THEN 2
                    WHEN 'Medium' THEN 3
                    WHEN 'Low' THEN 4
                    ELSE 5
                END
        ''', (year, month))

        cm_priorities = cursor.fetchall()

        if cm_priorities:
            cm_priority_data = [['Priority', 'Count', 'Total Hours', 'Avg Hours']]

            for priority, count, total_hrs, avg_hrs in cm_priorities:
                cm_priority_data.append([
                    priority,
                    str(count),
                    f'{total_hrs:.1f}' if total_hrs else '0.0',
                    f'{avg_hrs:.1f}' if avg_hrs else '0.0'
                ])

            cm_priority_table = Table(cm_priority_data, colWidths=[2*inch, 1.5*inch, 1.5*inch, 1.5*inch])
            cm_priority_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2c5282')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (0, -1), 'LEFT'),
                ('ALIGN', (1, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 11),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 10),
                ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#cbd5e0')),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('LEFTPADDING', (0, 0), (-1, -1), 12),
                ('RIGHTPADDING', (0, 0), (-1, -1), 12),
                ('TOPPADDING', (0, 0), (-1, -1), 8),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#f7fafc')])
            ]))

            story.append(cm_priority_table)
            story.append(Spacer(1, 20))

        # ==================== CM BREAKDOWN BY TECHNICIAN ====================
        story.append(Paragraph("CMs COMPLETED BY TECHNICIAN (This Month)", subheading_style))
        story.append(Spacer(1, 8))

        cursor.execute('''
            SELECT
                assigned_technician,
                COUNT(*) as completed,
                SUM(labor_hours) as total_hours,
                AVG(labor_hours) as avg_hours
            FROM corrective_maintenance
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s
            AND EXTRACT(MONTH FROM completion_date::date) = %s
            AND (status = 'Closed' OR status = 'Completed')
            GROUP BY assigned_technician
            ORDER BY completed DESC
        ''', (year, month))

        cm_techs = cursor.fetchall()

        if cm_techs:
            cm_tech_data = [['Technician', 'CMs Closed', 'Total Hours', 'Avg Hours']]

            for tech, count, total_hrs, avg_hrs in cm_techs:
                cm_tech_data.append([
                    tech if tech else 'Unassigned',
                    str(count),
                    f'{total_hrs:.1f}' if total_hrs else '0.0',
                    f'{avg_hrs:.1f}' if avg_hrs else '0.0'
                ])

            cm_tech_table = Table(cm_tech_data, colWidths=[2.5*inch, 1.5*inch, 1.5*inch, 1.5*inch])
            cm_tech_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2c5282')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (0, -1), 'LEFT'),
                ('ALIGN', (1, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 11),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 10),
                ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#cbd5e0')),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('LEFTPADDING', (0, 0), (-1, -1), 12),
                ('RIGHTPADDING', (0, 0), (-1, -1), 12),
                ('TOPPADDING', (0, 0), (-1, -1), 8),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#f7fafc')])
            ]))

            story.append(cm_tech_table)
            story.append(Spacer(1, 20))

        # ==================== PM TYPE BREAKDOWN ====================
        story.append(Paragraph("PREVENTIVE MAINTENANCE BREAKDOWN", heading_style))
        story.append(Spacer(1, 10))
    
        cursor.execute('''
            SELECT pm_type, COUNT(*) as count,
                SUM(labor_hours + labor_minutes/60.0) as total_hours,
                AVG(labor_hours + labor_minutes/60.0) as avg_hours
            FROM pm_completions
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s AND EXTRACT(MONTH FROM completion_date::date) = %s
            GROUP BY pm_type
            ORDER BY count DESC
        ''', (year, month))
    
        pm_types = cursor.fetchall()
    
        if pm_types:
            pm_type_data = [['PM Type', 'Count', 'Total Hours', 'Avg Hours']]
        
            for pm_type, count, total_hrs, avg_hrs in pm_types:
                pm_type_data.append([
                    pm_type,
                    str(count),
                    f'{total_hrs:.1f}' if total_hrs else '0.0',
                    f'{avg_hrs:.1f}' if avg_hrs else '0.0'
                ])
        
            pm_type_table = Table(pm_type_data, colWidths=[2*inch, 1.5*inch, 1.5*inch, 1.5*inch])
            pm_type_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2c5282')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (0, -1), 'LEFT'),
                ('ALIGN', (1, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 11),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 10),
                ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#cbd5e0')),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('LEFTPADDING', (0, 0), (-1, -1), 12),
                ('RIGHTPADDING', (0, 0), (-1, -1), 12),
                ('TOPPADDING', (0, 0), (-1, -1), 8),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#f7fafc')])
            ]))
        
            story.append(pm_type_table)
            story.append(Spacer(1, 25))
    
        # ==================== DAILY ACTIVITY SUMMARY ====================
        story.append(Paragraph("DAILY COMPLETION SUMMARY", heading_style))
        story.append(Spacer(1, 10))
    
        cursor.execute('''
            SELECT completion_date, COUNT(*) as daily_count,
                SUM(labor_hours + labor_minutes/60.0) as daily_hours
            FROM pm_completions
            WHERE EXTRACT(YEAR FROM completion_date::date) = %s AND EXTRACT(MONTH FROM completion_date::date) = %s
            GROUP BY completion_date
            ORDER BY completion_date
        ''', (year, month))
    
        daily_data_raw = cursor.fetchall()
    
        if daily_data_raw:
            daily_data = [['Date', 'PMs Completed', 'Labor Hours', 'Running Total']]
            running_total = 0
        
            for date, count, hours in daily_data_raw:
                running_total += count
                daily_data.append([
                    date,
                    str(count),
                    f'{hours:.1f}' if hours else '0.0',
                    str(running_total)
                ])
        
            daily_table = Table(daily_data, colWidths=[1.5*inch, 1.5*inch, 1.5*inch, 1.5*inch])
            daily_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2c5282')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 10),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 9),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#cbd5e0')),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('LEFTPADDING', (0, 0), (-1, -1), 8),
                ('RIGHTPADDING', (0, 0), (-1, -1), 8),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#f7fafc')])
            ]))

            story.append(daily_table)

        story.append(Spacer(1, 25))

        # ==================== OTHER ACTIVITY SUMMARY ====================
        story.append(Paragraph("OTHER ACTIVITY (Not counted in PM totals)", heading_style))
        story.append(Spacer(1, 10))

        other_activity_data = [
            ['ACTIVITY TYPE', 'COUNT'],
            ['Cannot Find Entries', f'{cf_count:,}'],
            ['Mark as Found Entries', f'{found_count:,}'],
            ['Run to Failure Entries', f'{rtf_count:,}'],
            ['Deactivated Assets', f'{deactivated_count:,}'],
            ['Total Assets Excluded from PM Requirements', f'{cf_count + rtf_count + deactivated_count:,}']
        ]

        other_table = Table(other_activity_data, colWidths=[4*inch, 2*inch])
        other_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2c5282')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('ALIGN', (1, 1), (1, -1), 'RIGHT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 12),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 11),
            ('BACKGROUND', (0, 1), (-1, 4), colors.white),
            ('BACKGROUND', (0, 5), (-1, 5), colors.HexColor('#e6f2ff')),
            ('FONTNAME', (0, 5), (-1, 5), 'Helvetica-Bold'),
            ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#cbd5e0')),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('LEFTPADDING', (0, 0), (-1, -1), 12),
            ('RIGHTPADDING', (0, 0), (-1, -1), 12),
            ('TOPPADDING', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 10),
            ('ROWBACKGROUNDS', (0, 1), (-1, 4), [colors.white, colors.HexColor('#f7fafc')])
        ]))

        story.append(other_table)
        story.append(Spacer(1, 25))

        # ==================== CANNOT FIND ASSETS ====================
        if cf_count > 0:
            story.append(Paragraph("CANNOT FIND ASSETS REPORTED", heading_style))
            story.append(Spacer(1, 10))

            # Summary paragraph
            story.append(Paragraph(
                f"<b>{cf_count}</b> asset(s) were reported as 'Cannot Find' during {month_name} {year}.",
                body_style
            ))
            story.append(Spacer(1, 15))

            # Build table of cannot find assets
            cf_data = [['BFM Number', 'Description', 'Location', 'Reported Date', 'Technician']]

            for asset in cannot_find_assets:
                bfm_no = asset[0] or 'N/A'
                desc = asset[1] or 'N/A'
                # Truncate description if too long
                if len(desc) > 30:
                    desc = desc[:27] + '...'
                loc = asset[2] or 'N/A'
                # Truncate location if too long
                if len(loc) > 15:
                    loc = loc[:12] + '...'
                reported_date = asset[3]
                if reported_date:
                    reported = reported_date.strftime('%Y-%m-%d') if hasattr(reported_date, 'strftime') else str(reported_date)[:10]
                else:
                    reported = 'N/A'
                technician = asset[4] or asset[5] or 'N/A'
                # Truncate technician if too long
                if len(technician) > 18:
                    technician = technician[:15] + '...'

                cf_data.append([bfm_no, desc, loc, reported, technician])

            cf_table = Table(cf_data, colWidths=[1.0*inch, 1.8*inch, 1.0*inch, 1.0*inch, 1.2*inch])
            cf_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#c53030')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 9),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#cbd5e0')),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('LEFTPADDING', (0, 0), (-1, -1), 6),
                ('RIGHTPADDING', (0, 0), (-1, -1), 6),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#fff5f5')])
            ]))

            story.append(cf_table)
            story.append(Spacer(1, 10))

            # Add summary note
            story.append(Paragraph(
                f"<i>Note: These assets were reported as missing during {month_name} {year}. "
                f"They remain in 'Cannot Find' status until located and marked as found.</i>",
                ParagraphStyle('NoteStyle', parent=body_style, fontSize=9,
                             textColor=colors.HexColor('#718096'), alignment=TA_LEFT)
            ))

        # ==================== MARK AS FOUND ASSETS ====================
        if found_count > 0:
            story.append(Spacer(1, 25))
            story.append(Paragraph("MARK AS FOUND ASSETS", heading_style))
            story.append(Spacer(1, 10))

            # Summary paragraph
            story.append(Paragraph(
                f"<b>{found_count}</b> asset(s) were marked as found and reactivated during {month_name} {year}.",
                body_style
            ))
            story.append(Spacer(1, 15))

            # Build table of found assets
            found_data = [['BFM Number', 'Description', 'Location', 'Reported Date', 'Found Date', 'Found By']]

            for asset in found_assets:
                bfm_no = asset[0] or 'N/A'
                desc = asset[1] or 'N/A'
                # Truncate description if too long
                if len(desc) > 25:
                    desc = desc[:22] + '...'
                loc = asset[2] or 'N/A'
                # Truncate location if too long
                if len(loc) > 15:
                    loc = loc[:12] + '...'
                reported = str(asset[3])[:10] if asset[3] else 'N/A'
                found_date = str(asset[4])[:10] if asset[4] else 'N/A'
                found_by = asset[5] or 'N/A'
                # Truncate found_by if too long
                if len(found_by) > 12:
                    found_by = found_by[:9] + '...'

                found_data.append([bfm_no, desc, loc, reported, found_date, found_by])

            found_table = Table(found_data, colWidths=[1.0*inch, 1.5*inch, 1.0*inch, 1.0*inch, 1.0*inch, 0.9*inch])
            found_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2c5282')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 9),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#cbd5e0')),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('LEFTPADDING', (0, 0), (-1, -1), 6),
                ('RIGHTPADDING', (0, 0), (-1, -1), 6),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#f7fafc')])
            ]))

            story.append(found_table)
            story.append(Spacer(1, 10))

            # Add summary note
            story.append(Paragraph(
                f"<i>Note: These assets were previously reported as 'Cannot Find' and have been successfully "
                f"located and reactivated for preventive maintenance scheduling.</i>",
                ParagraphStyle('NoteStyle', parent=body_style, fontSize=9,
                             textColor=colors.HexColor('#718096'), alignment=TA_LEFT)
            ))

        # ==================== BUILD PDF ====================
        doc.build(story)
    
        return filename   





class AITCMMSSystem:
    """Complete AIT CMMS - Computerized Maintenance Management System"""
    
    def show_closing_sync_dialog(self):
        """Show dialog asking user to confirm database sync on close"""
    
        dialog = tk.Toplevel(self.root)
        dialog.title("Closing Program - Database Sync")
        dialog.geometry("600x500")
        dialog.transient(self.root)
        dialog.grab_set()
    
        # Center dialog
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (600 // 2)
        y = (dialog.winfo_screenheight() // 2) - (500 // 2)
        dialog.geometry(f"600x500+{x}+{y}")
    
        result = {"action": "cancel"}  # Default to cancel
    
        # Header
        header_frame = ttk.Frame(dialog, padding=20)
        header_frame.pack(fill='x')
    
        ttk.Label(header_frame, text="Closing AIT CMMS", 
                font=('Arial', 16, 'bold')).pack()
        ttk.Label(header_frame, text="Database Backup Confirmation", 
                font=('Arial', 11), foreground='blue').pack(pady=5)
    
        # Separator
        ttk.Separator(dialog, orient='horizontal').pack(fill='x', pady=10)
    
        # Info section
        info_frame = ttk.LabelFrame(dialog, text="Session Information", padding=15)
        info_frame.pack(fill='both', expand=True, padx=20, pady=10)
    
        session_duration = datetime.now() - self.session_start_time
        hours, remainder = divmod(int(session_duration.total_seconds()), 3600)
        minutes, seconds = divmod(remainder, 60)
    
        info_text = f"""
    User: {self.user_name}
    Role: {self.current_user_role}

    Session Start: {self.session_start_time.strftime('%Y-%m-%d %H:%M:%S')}
    Session Duration: {hours}h {minutes}m {seconds}s

    Current Database: ait_cmms_database.db
    SharePoint Folder: {os.path.basename(self.backup_sync_dir) if hasattr(self, 'backup_sync_dir') and self.backup_sync_dir else 'Not Connected'}
        """
    
        ttk.Label(info_frame, text=info_text, justify='left', 
                font=('Courier', 9)).pack(anchor='w')
    
        # Sync explanation
        sync_frame = ttk.LabelFrame(dialog, text="What Happens Next", padding=15)
        sync_frame.pack(fill='x', padx=20, pady=10)
    
        sync_text = """When you click 'Backup and Close':

    1. CHECK: Your database will be backed up to SharePoint
    2. CHECK: Timestamped backup will be created
    3. CHECK: Other users can access your latest changes
    4. CHECK: Program will close safely

    This ensures all your work is saved.
        """
    
        ttk.Label(sync_frame, text=sync_text, justify='left').pack(anchor='w')
    
        # Important note
        note_frame = ttk.Frame(dialog, padding=10)
        note_frame.pack(fill='x', padx=20)
    
        ttk.Label(note_frame, 
                  text="Note: Last person to close the program pushes the final database state",
                  foreground='blue', font=('Arial', 9),
                  wraplength=550).pack()
    
        # Buttons
        button_frame = ttk.Frame(dialog, padding=15)
        button_frame.pack(fill='x')
    
        def sync_and_close():
            result["action"] = "sync_and_close"
            dialog.destroy()
    
        def cancel_close():
            result["action"] = "cancel"
            dialog.destroy()
    
        def close_without_sync():
            confirm = messagebox.askyesno(
                "Confirm Close Without Backup",
                "Close without backing up to SharePoint?\n\n"
                "CHECK: WARNING: Your changes will NOT be saved!\n"
                "CHECK: Other users will NOT see your work!\n\n"
                "Are you sure?",
                icon='warning',
                parent=dialog
            )
            if confirm:
                result["action"] = "close_without_sync"
                dialog.destroy()
    
        ttk.Button(button_frame, text="Backup and Close", 
                command=sync_and_close,
                style='Accent.TButton').pack(side='left', padx=5)
    
        ttk.Button(button_frame, text="Cancel", 
                command=cancel_close).pack(side='left', padx=5)
    
        ttk.Button(button_frame, text="Close Without Backup", 
                command=close_without_sync).pack(side='right', padx=5)
    
        # Wait for dialog
        dialog.wait_window()
    
        return result["action"]
    
    
    
    
    def analyze_pm_capacity(self):
        """Analyze if weekly PM target can handle all equipment requirements"""
        try:
            cursor = self.conn.cursor()
        
            # Get the actual counts from your database
            cursor.execute('''
                SELECT
                    COUNT(*) as total_active,
                    SUM(CASE WHEN monthly_pm = TRUE THEN 1 ELSE 0 END) as monthly_pm_count,
                    SUM(CASE WHEN annual_pm = TRUE THEN 1 ELSE 0 END) as annual_pm_count,
                    SUM(CASE WHEN status IN ('Run to Failure', 'Missing') THEN 1 ELSE 0 END) as excluded_count
                FROM equipment
                WHERE status = 'Active' OR status IS NULL
            ''')
        
            result = cursor.fetchone()
            total_active = result[0]
            monthly_count = result[1]
            annual_count = result[2]
            excluded = result[3]
        
            # Calculate requirements
            monthly_pms_per_month = monthly_count  # Each needs PM every 30 days
            annual_pms_per_month = round(annual_count / 12)  # Spread over 12 months
            total_required_per_month = monthly_pms_per_month + annual_pms_per_month
            
            # Your capacity
            weekly_capacity = self.weekly_pm_target
            monthly_capacity = weekly_capacity * 4
            
            # Calculate surplus/deficit
            surplus = monthly_capacity - total_required_per_month
            
            # Build report
            report = "CHECK:" * 70 + "\n"
            report += "PM CAPACITY ANALYSIS\n"
            report += "CHECK:" * 70 + "\n\n"
            
            report += "EQUIPMENT BREAKDOWN:\n"
            report += f"  Total Active Assets: {total_active:,}\n"
            report += f"  Assets requiring Monthly PMs: {monthly_count:,}\n"
            report += f"  Assets requiring Annual PMs: {annual_count:,}\n"
            report += f"  Excluded (Run to Failure/Cannot Find): {excluded:,}\n\n"
            
            report += "MONTHLY PM REQUIREMENTS:\n"
            report += f"  Monthly PMs needed: {monthly_pms_per_month:,}/month\n"
            report += f"  Annual PMs needed: {annual_pms_per_month:,}/month\n"
            report += f"  TOTAL Required: {total_required_per_month:,}/month\n\n"
            
            report += "YOUR CAPACITY:\n"
            report += f"  Weekly target: {weekly_capacity} PMs/week\n"
            report += f"  Monthly capacity: {monthly_capacity} PMs/month (4 weeks)\n\n"
        
            report += "CHECK:" * 70 + "\n"
            if surplus >= 0:
                report += "CHECK: VERDICT: CAPACITY IS SUFFICIENT!\n"
                report += "CHECK:" * 70 + "\n"
                report += f"You have {surplus} PMs/month surplus capacity.\n"
                report += f"This is {(surplus/monthly_capacity*100):.1f}% extra capacity for:\n"
                report += "  - Catching up on PM backlog\n"
                report += "  - Handling equipment that was missed\n"
                report += "  - Additional corrective maintenance\n\n"
            else:
                report += "CHECK: VERDICT: CAPACITY IS INSUFFICIENT!\n"
                report += "CHECK:" * 70 + "\n"
                report += f"You need {abs(surplus)} MORE PMs/month to keep up.\n\n"
                report += "RECOMMENDATIONS:\n"
                report += f"  - Increase weekly target to: {math.ceil(total_required_per_month/4)} PMs/week\n"
                report += f"  - Or add {math.ceil(abs(surplus)/monthly_capacity * 100)}% more technician hours\n"
                report += f"  - Or convert some Monthly PMs to Annual (if appropriate)\n\n"
                report += "WARNING: WARNING: At current capacity, you will accumulate\n"
                report += f"   a backlog of {abs(surplus)} PMs every month!\n\n"
        
            # Sustainability reference
            report += "CHECK:" * 70 + "\n"
            report += "WHAT YOUR CAPACITY CAN SUSTAIN:\n"
            report += "CHECK:" * 70 + "\n"
            report += f"  If ALL assets need Monthly PMs: {monthly_capacity:,} assets\n"
            report += f"  If ALL assets need Annual PMs: {monthly_capacity * 12:,} assets\n"
            report += f"  Current mix sustainability: {(monthly_capacity/total_required_per_month*100):.1f}%\n\n"
        
            # Check for never-done PMs
            cursor.execute('''
                SELECT COUNT(DISTINCT e.bfm_equipment_no)
                FROM equipment e
                LEFT JOIN pm_completions pc ON e.bfm_equipment_no = pc.bfm_equipment_no
                WHERE e.status = 'Active'
                AND (e.monthly_pm = TRUE OR e.annual_pm = TRUE)
                AND pc.bfm_equipment_no IS NULL
            ''')
            never_done = cursor.fetchone()[0]
        
            if never_done > 0:
                report += "CHECK:" * 70 + "\n"
                report += "WARNING: PM BACKLOG DETECTED:\n"
                report += "CHECK:" * 70 + "\n"
                report += f"  {never_done:,} assets have NEVER had a PM completed!\n"
                report += f"  At current capacity, it will take {math.ceil(never_done/monthly_capacity)} months\n"
                report += f"  just to complete the initial backlog (not counting recurring PMs).\n\n"
                report += "CATCH-UP STRATEGY:\n"
                report += f"  - Temporarily increase weekly target to {weekly_capacity + 50} for catch-up\n"
                report += f"  - Prioritize 'never done' PMs (system already does this)\n"
                report += f"  - Expected catch-up time: {math.ceil(never_done/(monthly_capacity + 50))}-{math.ceil(never_done/(monthly_capacity + 100))} months\n\n"
        
            # Show in dialog
            dialog = tk.Toplevel(self.root)
            dialog.title("PM Capacity Analysis")
            dialog.geometry("800x600")
            
            text_frame = ttk.Frame(dialog)
            text_frame.pack(fill='both', expand=True, padx=10, pady=10)
            
            scrollbar = ttk.Scrollbar(text_frame)
            scrollbar.pack(side='right', fill='y')
            
            text_widget = tk.Text(text_frame, wrap='word', yscrollcommand=scrollbar.set, 
                                font=('Courier', 10))
            text_widget.pack(fill='both', expand=True)
            scrollbar.config(command=text_widget.yview)
        
            text_widget.insert('1.0', report)
            text_widget.config(state='disabled')
        
            # Close button
            ttk.Button(dialog, text="Close", command=dialog.destroy).pack(pady=10)
        
        except Exception as e:
            messagebox.showerror("Error", f"Failed to analyze PM capacity: {str(e)}")
    
    
    
    def add_cannot_find_asset_dialog(self):
        """Dialog to manually add a new Cannot Find asset with auto-fill functionality"""
        dialog = tk.Toplevel(self.root)
        dialog.title("Add Cannot Find Asset")
        dialog.geometry("500x450")
        dialog.transient(self.root)
        dialog.grab_set()

        # Form fields
        ttk.Label(dialog, text="BFM Equipment No:").grid(row=0, column=0, sticky='w', padx=10, pady=10)
        bfm_var = tk.StringVar()
        bfm_entry = ttk.Entry(dialog, textvariable=bfm_var, width=30)
        bfm_entry.grid(row=0, column=1, padx=10, pady=10)

        ttk.Label(dialog, text="Description:").grid(row=1, column=0, sticky='w', padx=10, pady=10)
        desc_var = tk.StringVar()
        desc_entry = ttk.Entry(dialog, textvariable=desc_var, width=30)
        desc_entry.grid(row=1, column=1, padx=10, pady=10)
        
        ttk.Label(dialog, text="Location:").grid(row=2, column=0, sticky='w', padx=10, pady=10)
        location_var = tk.StringVar()
        location_entry = ttk.Entry(dialog, textvariable=location_var, width=30)
        location_entry.grid(row=2, column=1, padx=10, pady=10)

        ttk.Label(dialog, text="Reported By (Technician):").grid(row=3, column=0, sticky='w', padx=10, pady=10)
        tech_var = tk.StringVar()
        tech_combo = ttk.Combobox(dialog, textvariable=tech_var, width=28)
        tech_combo['values'] = self.technicians if hasattr(self, 'technicians') else []
        tech_combo.grid(row=3, column=1, padx=10, pady=10)

        ttk.Label(dialog, text="Report Date:").grid(row=4, column=0, sticky='w', padx=10, pady=10)
        date_var = tk.StringVar(value=datetime.now().strftime('%Y-%m-%d'))
        date_entry = ttk.Entry(dialog, textvariable=date_var, width=30)
        date_entry.grid(row=4, column=1, padx=10, pady=10)
        
        ttk.Label(dialog, text="Notes (Optional):").grid(row=5, column=0, sticky='nw', padx=10, pady=10)
        notes_text = tk.Text(dialog, width=30, height=5)
        notes_text.grid(row=5, column=1, padx=10, pady=10)

        # Status label for autofill feedback
        status_label = ttk.Label(dialog, text="", foreground="blue")
        status_label.grid(row=6, column=0, columnspan=2, pady=5)

        def autofill_from_bfm(*args):
            """Auto-fill description and location when BFM number is entered"""
            bfm_no = bfm_var.get().strip()
        
            if not bfm_no:
                # Clear fields if BFM is empty
                desc_var.set("")
                location_var.set("")
                status_label.config(text="", foreground="blue")
                return
        
            try:
                cursor = self.conn.cursor()
                cursor.execute('''
                    SELECT description, location 
                    FROM equipment 
                    WHERE bfm_equipment_no = %s
                ''', (bfm_no,))
            
                result = cursor.fetchone()
            
                if result:
                    description, location = result
                    desc_var.set(description or "")
                    location_var.set(location or "")
                    status_label.config(text="Equipment found - fields auto-filled", foreground="green")
                else:
                    # Don't clear existing values, just update status
                    status_label.config(text="Equipment not found in database", foreground="orange")
                
            except Exception as e:
                status_label.config(text=f"Error: {str(e)}", foreground="red")
                print(f"Autofill error: {e}")

        # Bind the autofill function to BFM entry changes
        # Use a slight delay to avoid querying on every keystroke
        bfm_var.trace_add('write', lambda *args: dialog.after(500, autofill_from_bfm))

        def save_cannot_find_asset():
            """Save the new Cannot Find asset to database"""
            bfm_no = bfm_var.get().strip()
            description = desc_var.get().strip()
            location = location_var.get().strip()
            technician = tech_var.get().strip()
            reported_date = date_var.get().strip()
            notes = notes_text.get("1.0", tk.END).strip()
    
            # Validation
            if not bfm_no:
                messagebox.showwarning("Validation Error", "BFM Equipment No. is required")
                return
    
            if not technician:
                messagebox.showwarning("Validation Error", "Technician name is required")
                return
    
            # Validate date format
            try:
                datetime.strptime(reported_date, '%Y-%m-%d')
            except ValueError:
                messagebox.showwarning("Validation Error", "Date must be in YYYY-MM-DD format")
                return
    
            try:
                cursor = self.conn.cursor()
        
                # Check if asset already exists in cannot_find_assets
                cursor.execute('SELECT bfm_equipment_no FROM cannot_find_assets WHERE bfm_equipment_no = %s', (bfm_no,))
                existing = cursor.fetchone()
        
                if existing:
                    result = messagebox.askyesno(
                        "Asset Exists",
                        f"Asset {bfm_no} already exists in Cannot Find list.\n\nUpdate the record with new information?"
                    )
                    if not result:
                        return
            
                    # Update existing record
                    cursor.execute('''
                        UPDATE cannot_find_assets 
                        SET description = %s, location = %s, technician_name = %s, 
                            reported_date = %s, status = 'Missing', notes = %s
                        WHERE bfm_equipment_no = %s
                    ''', (description, location, technician, reported_date, notes, bfm_no))
                else:
                    # Insert new record
                    cursor.execute('''
                        INSERT INTO cannot_find_assets 
                        (bfm_equipment_no, description, location, technician_name, reported_date, status, notes)
                        VALUES (%s, %s, %s, %s, %s, 'Missing', %s)
                    ''', (bfm_no, description, location, technician, reported_date, notes))
        
                # Also update the equipment table status if the equipment exists
                cursor.execute('SELECT bfm_equipment_no FROM equipment WHERE bfm_equipment_no = %s', (bfm_no,))
                if cursor.fetchone():
                    cursor.execute('UPDATE equipment SET status = %s WHERE bfm_equipment_no = %s',
                                ('Cannot Find', bfm_no))

                # Update any scheduled PMs for this asset to "Cannot Find" status
                cursor.execute('''
                    UPDATE weekly_pm_schedules
                    SET status = 'Cannot Find'
                    WHERE bfm_equipment_no = %s AND status = 'Scheduled'
                ''', (bfm_no,))

                self.conn.commit()
        
                messagebox.showinfo("Success", f"Cannot Find asset {bfm_no} added successfully")
        
                # Refresh the Cannot Find list
                self.load_cannot_find_assets()
        
                # Update statistics if method exists
                if hasattr(self, 'update_equipment_statistics'):
                    self.update_equipment_statistics()
        
                dialog.destroy()
        
            except Exception as e:
                messagebox.showerror("Error", f"Failed to add Cannot Find asset: {str(e)}")

        # Buttons
        button_frame = ttk.Frame(dialog)
        button_frame.grid(row=7, column=0, columnspan=2, pady=20)
        
        ttk.Button(button_frame, text="Save", command=save_cannot_find_asset).pack(side='left', padx=10)
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side='left', padx=10)

        # Focus on first entry
        bfm_entry.focus()
    
    
    
    
    def create_cm_from_pm_dialog(self):
        """Create a CM from within PM Completion tab - pre-filled with PM data"""
        # Get current PM form data
        bfm_no = self.completion_bfm_var.get().strip()
        pm_notes = self.notes_text.get('1.0', 'end-1c').strip()
        technician = self.completion_tech_var.get().strip()
    
        if not bfm_no:
            messagebox.showwarning("Warning", "Please select equipment first")
            return
    
        # Create CM dialog
        dialog = tk.Toplevel(self.root)
        dialog.title("Create CM from PM")
        dialog.geometry("600x700")
        dialog.transient(self.root)
        dialog.grab_set()
    
        # Header
        header = ttk.Label(dialog, text="Create Corrective Maintenance from PM", 
                        font=('Arial', 12, 'bold'))
        header.pack(pady=10)
    
        # Info label
        info_text = f"Creating CM for Equipment: {bfm_no}"
        ttk.Label(dialog, text=info_text, foreground='blue').pack(pady=5)
    
        # Form frame
        form_frame = ttk.LabelFrame(dialog, text="CM Details", padding=15)
        form_frame.pack(fill='both', expand=True, padx=10, pady=5)
    
        row = 0
    
        # CM Number (auto-generated)
        ttk.Label(form_frame, text="CM Number:").grid(row=row, column=0, sticky='w', pady=5)
        cm_number = self.generate_cm_number()
        cm_number_var = tk.StringVar(value=cm_number)
        ttk.Entry(form_frame, textvariable=cm_number_var, width=20, state='readonly').grid(
            row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1
    
        # BFM Equipment (pre-filled, readonly)
        ttk.Label(form_frame, text="BFM Equipment:").grid(row=row, column=0, sticky='w', pady=5)
        bfm_var = tk.StringVar(value=bfm_no)
        ttk.Entry(form_frame, textvariable=bfm_var, width=30, state='readonly').grid(
            row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1
    
        # Get equipment description
        cursor = self.conn.cursor()
        cursor.execute('SELECT description FROM equipment WHERE bfm_equipment_no = %s', (bfm_no,))
        result = cursor.fetchone()
        equip_desc = result[0] if result else "Unknown"
    
        ttk.Label(form_frame, text=f"Description: {equip_desc}", 
                foreground='gray').grid(row=row, column=1, sticky='w', padx=5)
        row += 1
    
        # Description (pre-filled with PM notes if available)
        ttk.Label(form_frame, text="CM Description:*").grid(row=row, column=0, sticky='nw', pady=5)
        description_text = tk.Text(form_frame, width=40, height=4)
        description_text.grid(row=row, column=1, sticky='w', padx=5, pady=5)
        if pm_notes:
            description_text.insert('1.0', f"Issue found during PM:\n{pm_notes}")
        row += 1
    
        # Priority
        ttk.Label(form_frame, text="Priority:*").grid(row=row, column=0, sticky='w', pady=5)
        priority_var = tk.StringVar(value="Medium")
        priority_combo = ttk.Combobox(form_frame, textvariable=priority_var, 
                                     values=['Low', 'Medium', 'High', 'Critical'], 
                                     width=15, state='readonly')
        priority_combo.grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1
    
        # Assigned Technician (default to current user)
        ttk.Label(form_frame, text="Assigned To:*").grid(row=row, column=0, sticky='w', pady=5)
        assigned_var = tk.StringVar(value=self.user_name if hasattr(self, 'user_name') else technician)
        assigned_combo = ttk.Combobox(form_frame, textvariable=assigned_var, 
                                    values=self.technicians, width=20)
        assigned_combo.grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1
    
        # CM Date (default to today)
        ttk.Label(form_frame, text="CM Date:*").grid(row=row, column=0, sticky='w', pady=5)
        cm_date_var = tk.StringVar(value=datetime.now().strftime('%Y-%m-%d'))
        ttk.Entry(form_frame, textvariable=cm_date_var, width=20).grid(
            row=row, column=1, sticky='w', padx=5, pady=5)
        ttk.Label(form_frame, text="(YYYY-MM-DD)", foreground='gray').grid(
            row=row, column=2, sticky='w', padx=5)
        row += 1
    
        # Additional Notes
        ttk.Label(form_frame, text="Additional Notes:").grid(row=row, column=0, sticky='nw', pady=5)
        notes_text = tk.Text(form_frame, width=40, height=3)
        notes_text.grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1
    
        # Validation and Save function
        def validate_and_save_cm():
            # Validate required fields
            if not description_text.get('1.0', 'end-1c').strip():
                messagebox.showerror("Error", "Please enter CM description")
                return
        
            if not assigned_var.get().strip():
                messagebox.showerror("Error", "Please assign a technician")
                return
        
            # Validate date format
            date_str = cm_date_var.get().strip()
            try:
                datetime.strptime(date_str, '%Y-%m-%d')
                validated_date = date_str
            except ValueError:
                messagebox.showerror("Error", "Invalid date format. Use YYYY-MM-DD")
                return
        
            # Save to database
            try:
                cursor = self.conn.cursor()
                cursor.execute('''
                    INSERT INTO corrective_maintenance 
                    (cm_number, bfm_equipment_no, description, priority, 
                     assigned_technician, status, created_date, notes)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                ''', (
                    cm_number_var.get(),
                    bfm_var.get(),
                    description_text.get('1.0', 'end-1c').strip(),
                    priority_var.get(),
                    assigned_var.get(),
                    'Open',
                    validated_date,
                    notes_text.get('1.0', 'end-1c').strip()
                ))
                self.conn.commit()
            
                messagebox.showinfo("Success", 
                                f"CHECK: CM Created Successfully!\n\n"
                                f"CM Number: {cm_number_var.get()}\n"
                                f"Equipment: {bfm_var.get()}\n"
                                f"Priority: {priority_var.get()}\n"
                                f"Assigned to: {assigned_var.get()}\n\n"
                                f"The CM is now visible in the CM Completions tab.")
            
                dialog.destroy()
            
                # Refresh CM list if the tab exists
                if hasattr(self, 'load_corrective_maintenance'):
                    self.load_corrective_maintenance()
            
                # Auto-sync to SharePoint if enabled
                if hasattr(self, 'auto_sync_after_action'):
                    self.auto_sync_after_action()
            
                # Update status bar
                if hasattr(self, 'update_status'):
                    self.update_status(f"CHECK: New CM created: {cm_number_var.get()} for {bfm_var.get()}")
                
                # Prompt for parts request
                try:
                    self.prompt_parts_required(cm_number_var.get(), bfm_var.get(), assigned_var.get())
                except Exception as _e:
                    pass
        
            except Exception as e:
                messagebox.showerror("Error", f"Failed to create CM: {str(e)}")
    
        # Buttons
        button_frame = ttk.Frame(dialog)
        button_frame.pack(fill='x', padx=10, pady=15)
    
        ttk.Button(button_frame, text="Save CM", command=validate_and_save_cm, 
                width=15).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy, 
                width=15).pack(side='left', padx=5)
    
        # Help text
        help_text = "* Required fields\nThis CM will be saved to the database and visible to all technicians."
        ttk.Label(dialog, text=help_text, foreground='gray', font=('Arial', 9)).pack(pady=5)


    def generate_cm_number(self):
        """Generate next CM number in format CM-YYYYMMDD-XXXX"""
        cursor = self.conn.cursor()
        today = datetime.now().strftime('%Y%m%d')
        cursor.execute(
            "SELECT MAX(CAST(SPLIT_PART(cm_number, '-', 3) AS INTEGER)) "
            "FROM corrective_maintenance "
            "WHERE cm_number LIKE %s",
            (f'CM-{today}-%',)
        )
        result = cursor.fetchone()

        if result[0]:
            next_num = result[0] + 1
        else:
            next_num = 1

        return f"CM-{today}-{next_num:04d}"


    def prompt_parts_required(self, cm_number, bfm_no, technician_name):
        """Ask technician if parts are required for this CM and open request form if yes"""
        try:
            answer = messagebox.askyesno(
                "Parts Required?",
                "Are parts required to complete this CM?\n\nIf yes, you'll be prompted to request parts (Part #, Model #, Website)."
            )
            if answer:
                self.open_parts_request_form(cm_number, bfm_no, technician_name)
        except Exception as e:
            print(f"Parts prompt error: {e}")

    def open_parts_request_form(self, cm_number, bfm_no, technician_name):
        """Open a dialog to capture parts request details and send to coordinator"""
        dialog = tk.Toplevel(self.root)
        dialog.title(f"Parts Request for {cm_number}")
        dialog.geometry("750x520")
        dialog.transient(self.root)
        dialog.grab_set()

        header = ttk.Label(dialog, text=f"Request Parts for CM {cm_number} (BFM: {bfm_no})", font=('Arial', 12, 'bold'))
        header.pack(pady=10)

        # Table-like entry area for multiple items
        table_frame = ttk.LabelFrame(dialog, text="Requested Parts", padding=10)
        table_frame.pack(fill='both', expand=True, padx=10, pady=10)

        columns = ("Part Number", "Model Number", "Website (optional)")
        tree = ttk.Treeview(table_frame, columns=columns, show='headings', height=7)
        for col, w in zip(columns, (160, 160, 300)):
            tree.heading(col, text=col)
            tree.column(col, width=w)

        vsb = ttk.Scrollbar(table_frame, orient='vertical', command=tree.yview)
        tree.configure(yscrollcommand=vsb.set)
        tree.grid(row=0, column=0, sticky='nsew')
        vsb.grid(row=0, column=1, sticky='ns')
        table_frame.grid_rowconfigure(0, weight=1)
        table_frame.grid_columnconfigure(0, weight=1)

        # Entry row
        entry_frame = ttk.Frame(dialog)
        entry_frame.pack(fill='x', padx=10, pady=(0,10))
        part_var = tk.StringVar()
        model_var = tk.StringVar()
        site_var = tk.StringVar()
        ttk.Label(entry_frame, text="Part #:").pack(side='left', padx=(0,5))
        ttk.Entry(entry_frame, textvariable=part_var, width=20).pack(side='left', padx=(0,10))
        ttk.Label(entry_frame, text="Model #:").pack(side='left', padx=(0,5))
        ttk.Entry(entry_frame, textvariable=model_var, width=20).pack(side='left', padx=(0,10))
        ttk.Label(entry_frame, text="Website:").pack(side='left', padx=(0,5))
        ttk.Entry(entry_frame, textvariable=site_var, width=40).pack(side='left', padx=(0,10))

        def add_item():
            pn = part_var.get().strip()
            if not pn:
                messagebox.showerror("Missing Part #", "Please enter a Part Number")
                return
            tree.insert('', 'end', values=(pn, model_var.get().strip(), site_var.get().strip()))
            part_var.set(''); model_var.set(''); site_var.set('')

        ttk.Button(entry_frame, text="Add", command=add_item).pack(side='left')

        # Notes
        notes_frame = ttk.LabelFrame(dialog, text="Notes (optional)", padding=8)
        notes_frame.pack(fill='x', padx=10, pady=5)
        notes_text = tk.Text(notes_frame, width=90, height=3)
        notes_text.pack(fill='x')

        def on_submit():
            items = [tree.item(i)['values'] for i in tree.get_children()]
            if not items:
                messagebox.showerror("No Items", "Please add at least one requested part")
                return
            try:
                # Persist requests
                cursor = self.conn.cursor()
                today = datetime.now().strftime('%Y-%m-%d')
                for vals in items:
                    part_no = vals[0] if len(vals) > 0 else ''
                    model_no = vals[1] if len(vals) > 1 else ''
                    website = vals[2] if len(vals) > 2 else ''
                    cursor.execute('''
                        INSERT INTO cm_parts_requests
                        (cm_number, bfm_equipment_no, part_number, model_number, website, requested_by, requested_date, notes)
                        VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                    ''', (cm_number, bfm_no, part_no, model_no, website, technician_name, today, notes_text.get('1.0', 'end-1c').strip()))
                self.conn.commit()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save parts request: {e}")
                return

            # Attempt to send email
            try:
                sent = self.send_parts_request_email(cm_number, bfm_no, technician_name, items, notes_text.get('1.0', 'end-1c').strip())
                if sent:
                    # Mark sent
                    cursor = self.conn.cursor()
                    cursor.execute('''
                        UPDATE cm_parts_requests SET email_sent = TRUE, email_sent_at = CURRENT_TIMESTAMP
                        WHERE cm_number = %s
                    ''', (cm_number,))
                    self.conn.commit()
                    messagebox.showinfo("Sent", "Parts request emailed to Parts Coordinator.")
                else:
                    messagebox.showwarning("Email Not Sent", "Saved request, but email could not be sent automatically. A draft will be shown.")
            except Exception as e:
                messagebox.showwarning("Email Error", f"Saved request, but email failed: {e}")

            dialog.destroy()

        # Buttons
        btn_frame = ttk.Frame(dialog)
        btn_frame.pack(fill='x', padx=10, pady=10)
        ttk.Button(btn_frame, text="Submit Request", command=on_submit).pack(side='left')
        ttk.Button(btn_frame, text="Cancel", command=dialog.destroy).pack(side='right')

    def send_parts_request_email(self, cm_number, bfm_no, technician_name, items, notes):
        """Send an email to the Parts Coordinator with requested parts. Returns True if sent."""
        try:
            import smtplib
            from email.mime.text import MIMEText
            from email.mime.multipart import MIMEMultipart

            to_addr = 'Ashica.Penson@aint.com'
            subject = f"Parts Request for {cm_number} (BFM {bfm_no})"

            lines = [
                f"CM Number: {cm_number}",
                f"BFM Equipment: {bfm_no}",
                f"Requested by: {technician_name}",
                f"Requested date: {datetime.now().strftime('%Y-%m-%d %H:%M')}",
                "",
                "Requested Parts:",
            ]
            for idx, vals in enumerate(items, start=1):
                part_no = vals[0] if len(vals) > 0 else ''
                model_no = vals[1] if len(vals) > 1 else ''
                site = vals[2] if len(vals) > 2 else ''
                lines.append(f"{idx}. Part #: {part_no} | Model #: {model_no} | Website: {site}")
            if notes and notes.strip():
                lines.extend(["", "Notes:", notes.strip()])

            body = "\n".join(lines)

            msg = MIMEMultipart()
            msg['Subject'] = subject
            msg['To'] = to_addr
            # If the system knows a from address, set it; otherwise leave blank and rely on relay
            from_addr = getattr(self, 'system_from_email', None) or 'no-reply@ait-cmms.local'
            msg['From'] = from_addr
            msg.attach(MIMEText(body, 'plain'))

            # Attempt to send via local relay; adjust as needed in deployment
            try:
                with smtplib.SMTP('localhost') as server:
                    server.sendmail(from_addr, [to_addr], msg.as_string())
                return True
            except Exception:
                # Fallback: try common Microsoft 365 relay host if configured via env
                import os
                host = os.environ.get('CMMS_SMTP_HOST')
                port = int(os.environ.get('CMMS_SMTP_PORT', '25'))
                if host:
                    with smtplib.SMTP(host, port) as server:
                        server.sendmail(from_addr, [to_addr], msg.as_string())
                    return True
                # As a last resort, open a mailto draft for the user
                try:
                    import webbrowser
                    import urllib.parse
                    mailto = f"mailto:{to_addr}?subject={urllib.parse.quote(subject)}&body={urllib.parse.quote(body)}"
                    webbrowser.open(mailto)
                except Exception:
                    pass
                return False
        except Exception as e:
            print(f"Email error: {e}")
            return False

    
    
    def show_monthly_summary(self):
        """Display monthly summary report in a new window"""
        try:
            # Create dialog window
            summary_window = tk.Toplevel(self.root)
            summary_window.title("Monthly PM Summary Report")
            summary_window.geometry("900x700")
            summary_window.transient(self.root)
            summary_window.grab_set()
        
            # Create text widget with scrollbar
            text_frame = ttk.Frame(summary_window)
            text_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
            text_widget = tk.Text(text_frame, wrap='word', font=('Courier', 10))
            scrollbar = ttk.Scrollbar(text_frame, orient='vertical', command=text_widget.yview)
            text_widget.configure(yscrollcommand=scrollbar.set)
        
            text_widget.pack(side='left', fill='both', expand=True)
            scrollbar.pack(side='right', fill='y')
        
            # Month/Year selection frame
            selection_frame = ttk.Frame(summary_window)
            selection_frame.pack(fill='x', padx=10, pady=5)
            
            ttk.Label(selection_frame, text="Month:").pack(side='left', padx=5)
            month_var = tk.StringVar(value=str(datetime.now().month))
            month_combo = ttk.Combobox(selection_frame, textvariable=month_var, 
                                    values=list(range(1, 13)), width=5, state='readonly')
            month_combo.pack(side='left', padx=5)
        
            ttk.Label(selection_frame, text="Year:").pack(side='left', padx=5)
            year_var = tk.StringVar(value=str(datetime.now().year))
            year_combo = ttk.Combobox(selection_frame, textvariable=year_var,
                                values=list(range(2020, 2030)), width=8, state='readonly')
            year_combo.pack(side='left', padx=5)
    
            # ========== DEFINE ALL FUNCTIONS FIRST ==========
        
            def generate_report():
                """Generate and display the report"""
                try:
                    month = int(month_var.get())
                    year = int(year_var.get())
                    
                    # Clear existing text
                    text_widget.delete('1.0', 'end')
                    
                    # Redirect print output to text widget
                    import sys
                    from io import StringIO
                    old_stdout = sys.stdout
                    sys.stdout = StringIO()
            
                    # Generate the report
                    generate_monthly_summary_report(self.conn, month, year)
                    
                    # Get the output and restore stdout
                    output = sys.stdout.getvalue()
                    sys.stdout = old_stdout
                
                    # Display in text widget
                    text_widget.insert('1.0', output)
                
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to generate report: {str(e)}")
        
            def export_report():
                """Export report to text file"""
                try:
                    filename = filedialog.asksaveasfilename(
                        title="Export Monthly Summary",
                        defaultextension=".txt",
                        initialname=f"Monthly_Summary_{month_var.get()}_{year_var.get()}.txt",
                        filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
                    )
                    if filename:
                        with open(filename, 'w') as f:
                            f.write(text_widget.get('1.0', 'end'))
                        messagebox.showinfo("Success", f"Report exported to {filename}")
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to export text report: {str(e)}")
        
            def export_professional_pdf():
                """Export professional PDF monthly report"""
                try:
                    month = int(month_var.get())
                    year = int(year_var.get())

                    # Show progress message
                    progress_label = ttk.Label(selection_frame, text="Generating professional PDF...",
                                               foreground='blue')
                    progress_label.pack(side='left', padx=10)
                    summary_window.update()

                    # Generate the PDF
                    filename = export_professional_monthly_report_pdf(self.conn, month, year)

                    # Remove progress label
                    progress_label.destroy()

                    # Check if user cancelled
                    if filename is None:
                        return

                    # Success message with option to open
                    result = messagebox.askyesno(
                        "Success",
                        f"Professional monthly report exported!\n\n{filename}\n\nWould you like to open it now?",
                        icon='info'
                    )
                
                    if result:
                        # Open the PDF
                        import os
                        import platform
                        
                        if platform.system() == 'Windows':
                            os.startfile(filename)
                        elif platform.system() == 'Darwin':  # macOS
                            os.system(f'open "{filename}"')
                        else:  # Linux
                            os.system(f'xdg-open "{filename}"')
                
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to generate PDF report:\n\n{str(e)}")
        
            # ========== NOW CREATE THE BUTTONS ==========
        
            ttk.Button(selection_frame, text="Generate Report", 
                    command=generate_report).pack(side='left', padx=10)
        
            ttk.Button(selection_frame, text="Export Text", 
                    command=export_report).pack(side='left', padx=5)
        
            ttk.Button(selection_frame, text="Export Professional PDF", 
                    command=export_professional_pdf).pack(side='left', padx=5)
        
            ttk.Button(selection_frame, text="Close", 
                    command=summary_window.destroy).pack(side='right', padx=5)
        
            # Generate initial report for current month
            generate_report()
    
        except Exception as e:
            messagebox.showerror("Error", f"Failed to show monthly summary: {str(e)}")
    
    
    
    
    
    # Add this method to your class
    def setup_program_colors(self):
        """Set up the color scheme for the entire program"""
    
        # Create style object
        self.style = ttk.Style()
    
        # Choose base theme
        self.style.theme_use('clam')  # Good base for customization
    
        # Set main window background
        self.root.configure(bg="#e8f4f8")  # Light blue-gray
    
        # Configure Treeview (your asset lists) with larger fonts
        self.style.configure("Treeview",
                        background="#ffffff",        # White background
                        foreground="#1e3a8a",       # Dark blue text
                        rowheight=45,                # Increased for better readability
                        fieldbackground="#ffffff",   # White field background
                        font=('TkDefaultFont', 12))  # Increased row font size

        # Treeview headers - increased font size
        self.style.configure("Treeview.Heading",
                        background="#3b82f6",       # Blue headers
                        foreground="white",
                        font=('TkDefaultFont', 16, 'bold'))  # Increased for better readability

        # Buttons - increased font size
        self.style.configure("TButton",
                        background="#3b82f6",       # Blue buttons
                        foreground="white",
                        padding=(15, 8),             # Increased padding for larger buttons
                        relief="flat",
                        font=('TkDefaultFont', 15))  # Increased for better readability

        # Button hover effects
        self.style.map("TButton",
                    background=[('active', '#60a5fa'),    # Lighter blue on hover
                                ('pressed', '#1d4ed8')])   # Darker blue when pressed

        # LabelFrames (your control sections) - increased font size
        self.style.configure("TLabelframe",
                        background="#e8f4f8",       # Light blue-gray
                        foreground="#1e3a8a",       # Dark blue text
                        borderwidth=2,
                        relief="groove")

        self.style.configure("TLabelframe.Label",
                        background="#e8f4f8",
                        foreground="#1e3a8a",
                        font=('TkDefaultFont', 16, 'bold'))  # Increased for better readability
    
        # Frames
        self.style.configure("TFrame",
                        background="#e8f4f8")
    
        # Entry widgets
        self.style.configure("TEntry",
                        fieldbackground="#ffffff",
                        foreground="#1e3a8a",
                        borderwidth=1,
                        relief="solid")
    
        # Combobox
        self.style.configure("TCombobox",
                        fieldbackground="#ffffff",
                        foreground="#1e3a8a",
                        arrowcolor="#3b82f6")
    
        # Scrollbars
        self.style.configure("Vertical.TScrollbar",
                        background="#d1d5db",
                        troughcolor="#f3f4f6",
                        borderwidth=1,
                        arrowcolor="#3b82f6")
    
        self.style.configure("Horizontal.TScrollbar",
                        background="#d1d5db",
                        troughcolor="#f3f4f6",
                        borderwidth=1,
                        arrowcolor="#3b82f6")

    
    
    
    
    
    
    def check_empty_database_and_offer_restore(self):
        """Check if database is empty and offer to restore from backup"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('SELECT COUNT(*) FROM equipment')
            equipment_count = cursor.fetchone()[0]
            
            if equipment_count == 0:
                # Database is empty, offer restore
                result = messagebox.askyesno(
                    "Empty Database Detected",
                    "The database appears to be empty.\n\n"
                    "Would you like to restore data from a previous backup?\n\n"
                    "Click 'Yes' to browse available backups\n"
                    "Click 'No' to continue with empty database",
                    icon='question'
                )
                
                if result:
                    self.create_database_restore_dialog()
                    
        except Exception as e:
            print(f"Error checking empty database: {e}")
    
    
    def create_database_restore_dialog(self):
        """Create dialog to restore database from SharePoint backups - FIXED with proper buttons"""
        if not hasattr(self, 'backup_sync_dir') or not self.backup_sync_dir:
            messagebox.showerror("Error", "No backup directory configured. Please restart the application.")
            return
    
        dialog = tk.Toplevel(self.root)
        dialog.title("Restore Database from Backup")
        dialog.geometry("1000x700")  # Made larger
        dialog.transient(self.root)
        dialog.grab_set()
    
        # Instructions
        instructions_frame = ttk.LabelFrame(dialog, text="Database Restore", padding=15)
        instructions_frame.pack(fill='x', padx=10, pady=5)
        
        instructions_text = f"""Select a backup file to restore your database from SharePoint.

    Current backup location: {self.backup_sync_dir}

    WARNING: Restoring a backup will:
    - Close the current database
    - Replace it with the selected backup
    - All unsaved changes will be lost
    - The application will reload with the restored data"""
    
        ttk.Label(instructions_frame, text=instructions_text, font=('Arial', 10)).pack(anchor='w')
    
        # Backup files list
        files_frame = ttk.LabelFrame(dialog, text="Available Backup Files (Last 15)", padding=10)
        files_frame.pack(fill='both', expand=True, padx=10, pady=5)
    
        # Create treeview for backup files
        self.backup_files_tree = ttk.Treeview(files_frame,
                                            columns=('Filename', 'Date Created', 'Size', 'Age'),
                                            show='headings')
    
        # Configure columns
        backup_columns = {
            'Filename': ('Backup Filename', 350),
            'Date Created': ('Date Created', 150),
            'Size': ('File Size', 100),
            'Age': ('Age (Days)', 100)
        }
    
        for col, (heading, width) in backup_columns.items():
            self.backup_files_tree.heading(col, text=heading)
            self.backup_files_tree.column(col, width=width)
    
        # Scrollbars
        backup_v_scrollbar = ttk.Scrollbar(files_frame, orient='vertical', command=self.backup_files_tree.yview)
        backup_h_scrollbar = ttk.Scrollbar(files_frame, orient='horizontal', command=self.backup_files_tree.xview)
        self.backup_files_tree.configure(yscrollcommand=backup_v_scrollbar.set, xscrollcommand=backup_h_scrollbar.set)
        
        # Pack treeview and scrollbars
        self.backup_files_tree.grid(row=0, column=0, sticky='nsew')
        backup_v_scrollbar.grid(row=0, column=1, sticky='ns')
        backup_h_scrollbar.grid(row=1, column=0, sticky='ew')
        
        files_frame.grid_rowconfigure(0, weight=1)
        files_frame.grid_columnconfigure(0, weight=1)
        
        # Selection info
        selection_frame = ttk.LabelFrame(dialog, text="Selected Backup Info", padding=10)
        selection_frame.pack(fill='x', padx=10, pady=5)
    
        self.backup_info_label = ttk.Label(selection_frame, text="Loading backup files...", 
                                        font=('Arial', 10), foreground='blue')
        self.backup_info_label.pack(anchor='w')
    
        # Bind selection event
        self.backup_files_tree.bind('<<TreeviewSelect>>', self.on_backup_file_select)
    
        # Action buttons - FIXED with proper layout
        button_frame = ttk.Frame(dialog)
        button_frame.pack(side='bottom', fill='x', padx=10, pady=15)
    
        # Left side buttons
        left_buttons = ttk.Frame(button_frame)
        left_buttons.pack(side='left')
    
        ttk.Button(left_buttons, text="Refresh List", 
                command=self.load_backup_files).pack(side='left', padx=5)
        ttk.Button(left_buttons, text="Preview Backup", 
                command=self.preview_selected_backup).pack(side='left', padx=5)
    
        # Right side buttons  
        right_buttons = ttk.Frame(button_frame)
        right_buttons.pack(side='right')
    
        ttk.Button(right_buttons, text="Cancel", 
                command=dialog.destroy).pack(side='right', padx=5)
    
        # Main restore button - prominent in center
        center_buttons = ttk.Frame(button_frame)
        center_buttons.pack(expand=True)
        
        self.restore_button = ttk.Button(center_buttons, text="RESTORE SELECTED BACKUP", 
                                        command=self.restore_selected_backup, 
                                        state='disabled',
                                        width=25)
        self.restore_button.pack(pady=5)
    
        # Load backup files after creating the dialog
        self.root.after(100, self.load_backup_files)  # Load after dialog is fully created

    
    

    def load_backup_files(self):
        """Load available backup files from SharePoint - FIXED to show multiple files"""
        try:
            if not os.path.exists(self.backup_sync_dir):
                if hasattr(self, 'backup_info_label'):
                    self.backup_info_label.config(text="Backup directory not found", foreground='red')
                return
        
            # Clear existing items
            for item in self.backup_files_tree.get_children():
                self.backup_files_tree.delete(item)
        
            # Get all backup files
            backup_files = []
            try:
                all_files = os.listdir(self.backup_sync_dir)
                print(f"DEBUG: Found {len(all_files)} total files in backup directory")
            
                for filename in all_files:
                    if filename.startswith('ait_cmms_backup_') and filename.endswith('.db'):
                        file_path = os.path.join(self.backup_sync_dir, filename)
                        try:
                            # Get file stats
                            stat = os.stat(file_path)
                            file_size = stat.st_size
                            modified_time = datetime.fromtimestamp(stat.st_mtime)
                            age_days = (datetime.now() - modified_time).days
                        
                            backup_files.append({
                                'filename': filename,
                                'filepath': file_path,
                                'size': file_size,
                                'modified': modified_time,
                                'age_days': age_days
                            })
                            print(f"DEBUG: Added backup file: {filename}")
                        except Exception as e:
                            print(f"Error reading backup file {filename}: {e}")
                            continue
            except Exception as e:
                print(f"Error listing backup directory: {e}")
                if hasattr(self, 'backup_info_label'):
                    self.backup_info_label.config(text=f"Error reading backup directory: {str(e)}", foreground='red')
                return
        
            print(f"DEBUG: Total backup files found: {len(backup_files)}")
        
            # Sort by modification time (newest first)
            backup_files.sort(key=lambda x: x['modified'], reverse=True)
            
            # Limit to last 15 backups for better performance
            backup_files = backup_files[:15]
        
            # Add to tree
            for idx, backup in enumerate(backup_files):
                # Format file size
                size_mb = backup['size'] / (1024 * 1024)
                size_str = f"{size_mb:.1f} MB" if size_mb >= 1 else f"{backup['size']} bytes"

                item_id = self.backup_files_tree.insert('', 'end', values=(
                    backup['filename'],
                    backup['modified'].strftime('%Y-%m-%d %H:%M:%S'),
                    size_str,
                    f"{backup['age_days']} days"
                ))

                print(f"DEBUG: Inserted item: {backup['filename']}")

                # Yield to event loop periodically to keep UI responsive
                if idx % 5 == 0:
                    self.root.update_idletasks()
        
            # Update info label
            if hasattr(self, 'backup_info_label'):
                if backup_files:
                    self.backup_info_label.config(text=f"Found {len(backup_files)} backup files", foreground='green')
                else:
                    self.backup_info_label.config(text="No backup files found in directory", foreground='orange')
                
        except Exception as e:
            print(f"Error loading backup files: {e}")
            if hasattr(self, 'backup_info_label'):
                self.backup_info_label.config(text=f"Error loading backups: {str(e)}", foreground='red')


    def on_backup_file_select(self, event):
        """Handle backup file selection - ENHANCED"""
        try:
            selected = self.backup_files_tree.selection()
            if selected:
                item = self.backup_files_tree.item(selected[0])
                filename = item['values'][0]
                date_created = item['values'][1]
                file_size = item['values'][2]
                age = item['values'][3]
                
                # Show backup info
                info_text = f"CHECK: SELECTED: {filename}\n"
                info_text += f"Created: {date_created}\n"
                info_text += f"Size: {file_size}\n"
                info_text += f"Age: {age}\n\n"
                info_text += "Click 'RESTORE SELECTED BACKUP' to proceed"
            
                self.backup_info_label.config(text=info_text, foreground='darkgreen')
            
                # Enable restore button
                self.restore_button.config(state='normal')
                self.restore_button.config(text=f"RESTORE: {filename}")
            else:
                self.backup_info_label.config(text="Select a backup file to see details", foreground='gray')
                self.restore_button.config(state='disabled')
                self.restore_button.config(text="RESTORE SELECTED BACKUP")
        except Exception as e:
            print(f"Error in backup file selection: {e}")
            self.backup_info_label.config(text="Error selecting backup file", foreground='red')


    def preview_selected_backup(self):
        """Preview selected backup file contents"""
        selected = self.backup_files_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a backup file to preview")
            return
    
        try:
            item = self.backup_files_tree.item(selected[0])
            filename = item['values'][0]
            filepath = os.path.join(self.backup_sync_dir, filename)
        
            if not os.path.exists(filepath):
                messagebox.showerror("Error", f"Backup file not found: {filename}")
                return
        
            # Create preview dialog
            preview_dialog = tk.Toplevel(self.root)
            preview_dialog.title(f"Preview Backup: {filename}")
            preview_dialog.geometry("800x600")
            preview_dialog.transient(self.root)
            preview_dialog.grab_set()
        
            # Preview text area
            text_frame = ttk.Frame(preview_dialog)
            text_frame.pack(fill='both', expand=True, padx=10, pady=10)
            
            preview_text = tk.Text(text_frame, wrap='word', font=('Courier', 10))
            scrollbar = ttk.Scrollbar(text_frame, orient='vertical', command=preview_text.yview)
            preview_text.configure(yscrollcommand=scrollbar.set)
            
            preview_text.pack(side='left', fill='both', expand=True)
            scrollbar.pack(side='right', fill='y')
            
            # Connect to backup database and get preview info
            try:
                backup_conn = sqlite3.connect(filepath)
                backup_cursor = backup_conn.cursor()
                
                preview_info = f"BACKUP DATABASE PREVIEW\n"
                preview_info += f"File: {filename}\n"
                preview_info += f"=" * 80 + "\n\n"
                
                # Get table counts
                tables = [
                    ('equipment', 'Equipment/Assets'),
                    ('pm_completions', 'PM Completions'),
                    ('weekly_pm_schedules', 'Weekly Schedules'),
                    ('corrective_maintenance', 'Corrective Maintenance'),
                    ('cannot_find_assets', 'Cannot Find Assets'),
                    ('run_to_failure_assets', 'Run to Failure Assets'),
                    ('pm_templates', 'PM Templates')
                ]
            
                preview_info += "DATABASE CONTENTS:\n"
                preview_info += "-" * 40 + "\n"
            
                total_records = 0
                for table_name, display_name in tables:
                    try:
                        backup_cursor.execute(f'SELECT COUNT(*) FROM {table_name}')
                        count = backup_cursor.fetchone()[0]
                        total_records += count
                        preview_info += f"{display_name}: {count} records\n"
                    except Exception as e:
                        preview_info += f"{display_name}: Error reading ({str(e)})\n"
            
                preview_info += f"\nTotal Records: {total_records}\n\n"
            
                # Get some sample equipment data
                try:
                    backup_cursor.execute('''
                        SELECT bfm_equipment_no, description, status 
                        FROM equipment 
                        ORDER BY updated_date DESC 
                        LIMIT 10
                    ''')
                    equipment_sample = backup_cursor.fetchall()
                
                    if equipment_sample:
                        preview_info += "RECENT EQUIPMENT (Sample):\n"
                        preview_info += "-" * 40 + "\n"
                        for bfm_no, desc, status in equipment_sample:
                            desc_short = (desc[:30] + '...') if desc and len(desc) > 30 else (desc or 'No description')
                            preview_info += f"{bfm_no}: {desc_short} ({status or 'Active'})\n"
                        preview_info += "\n"
                except:
                    pass
            
                # Get recent PM completions
                try:
                    backup_cursor.execute('''
                        SELECT completion_date, COUNT(*) as count
                        FROM pm_completions 
                        GROUP BY completion_date 
                        ORDER BY completion_date DESC 
                        LIMIT 10
                    ''')
                    pm_dates = backup_cursor.fetchall()
                
                    if pm_dates:
                        preview_info += "RECENT PM ACTIVITY:\n"
                        preview_info += "-" * 40 + "\n"
                        for date, count in pm_dates:
                            preview_info += f"{date}: {count} PM completions\n"
                        preview_info += "\n"
                except:
                    pass
                
                # Database metadata
                try:
                    backup_cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                    all_tables = [row[0] for row in backup_cursor.fetchall()]
                    preview_info += f"DATABASE STRUCTURE:\n"
                    preview_info += "-" * 40 + "\n"
                    preview_info += f"Total Tables: {len(all_tables)}\n"
                    preview_info += f"Tables: {', '.join(all_tables)}\n"
                except:
                    pass
            
                backup_conn.close()
            
                preview_text.insert('1.0', preview_info)
                preview_text.config(state='disabled')
            
            except Exception as e:
                preview_text.insert('1.0', f"Error previewing backup database:\n{str(e)}")
                preview_text.config(state='disabled')
        
            # Close button
            ttk.Button(preview_dialog, text="Close", command=preview_dialog.destroy).pack(pady=10)
        
        except Exception as e:
            messagebox.showerror("Preview Error", f"Failed to preview backup: {str(e)}")

    def restore_selected_backup(self):
        """Restore the selected backup file"""
        selected = self.backup_files_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a backup file to restore")
            return
    
        try:
            item = self.backup_files_tree.item(selected[0])
            filename = item['values'][0]
            date_created = item['values'][1]
            file_size = item['values'][2]
        
            # Get the full file path
            source_filepath = os.path.join(self.backup_sync_dir, filename)
        
            if not os.path.exists(source_filepath):
                messagebox.showerror("Error", f"Backup file not found: {filename}")
                return
        
            # Confirmation dialog with detailed info
            confirm_msg = f"""RESTORE DATABASE FROM BACKUP

    Selected Backup:
    - File: {filename}
    - Created: {date_created}
    - Size: {file_size}

    WARNING: This action will:
    - Close the current database
    - Replace it completely with the backup data
    - All current unsaved changes will be lost
    - The application will reload with the backup data

    This action cannot be undone.

    Are you sure you want to proceed?"""
        
            result = messagebox.askyesno("Confirm Database Restore", confirm_msg, 
                                        icon='warning', default='no')
        
            if not result:
                return
        
            # Create progress dialog
            progress_dialog = tk.Toplevel(self.root)
            progress_dialog.title("Restoring Database...")
            progress_dialog.geometry("400x150")
            progress_dialog.transient(self.root)
            progress_dialog.grab_set()
            
            ttk.Label(progress_dialog, text="Restoring database from backup...", 
                    font=('Arial', 12)).pack(pady=20)
        
            progress_var = tk.StringVar(value="Preparing restore...")
            progress_label = ttk.Label(progress_dialog, textvariable=progress_var)
            progress_label.pack(pady=10)
            
            progress_bar = ttk.Progressbar(progress_dialog, mode='indeterminate')
            progress_bar.pack(pady=10, padx=20, fill='x')
            progress_bar.start()
        
            # Update GUI
            self.root.update()
            
            # Perform the restore
            current_db_path = 'ait_cmms_database.db'
        
            # Step 1: Close current database connection
            progress_var.set("Closing current database...")
            self.root.update()
        
            if hasattr(self, 'conn'):
                try:
                    self.conn.close()
                except:
                    pass
        
            # Step 2: Backup current database (just in case)
            progress_var.set("Backing up current database...")
            self.root.update()
        
            if os.path.exists(current_db_path):
                backup_current_path = f"{current_db_path}.pre_restore_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                shutil.copy2(current_db_path, backup_current_path)
        
            # Step 3: Copy backup to current location
            progress_var.set("Restoring backup data...")
            self.root.update()
        
            shutil.copy2(source_filepath, current_db_path)
        
            # Step 4: Reconnect to database
            progress_var.set("Reconnecting to database...")
            self.root.update()
        
            self.conn = sqlite3.connect(current_db_path)
        
            # Step 5: Refresh all data displays
            progress_var.set("Refreshing application data...")
            self.root.update()

            # Refresh all displays (equipment list now uses direct SQL queries)
            self.refresh_equipment_list()
            self.load_recent_completions()
            self.load_corrective_maintenance()
            if hasattr(self, 'load_cannot_find_assets'):
                self.load_cannot_find_assets()
            if hasattr(self, 'load_run_to_failure_assets'):
                self.load_run_to_failure_assets()
            if hasattr(self, 'load_pm_templates'):
                self.load_pm_templates()
        
            # Update statistics
            if hasattr(self, 'update_equipment_statistics'):
                self.update_equipment_statistics()
        
            progress_bar.stop()
            progress_dialog.destroy()
        
            # Close the restore dialog
            if hasattr(self, 'backup_files_tree'):
                # Find and close the restore dialog
                for widget in self.root.winfo_children():
                    if isinstance(widget, tk.Toplevel) and "Restore Database" in widget.title():
                        widget.destroy()
                        break
        
            # Show success message
            messagebox.showinfo("Restore Complete", 
                               f"Database successfully restored from backup!\n\n"
                               f"Restored from: {filename}\n"
                               f"Created: {date_created}\n"
                               f"The application has been refreshed with the restored data.")
        
            self.update_status(f"Database restored from backup: {filename}")
        
        except Exception as e:
            # Try to reconnect to original database
            try:
                self.conn = sqlite3.connect('ait_cmms_database.db')
            except:
                pass
        
            messagebox.showerror("Restore Error", f"Failed to restore database backup:\n\n{str(e)}")
            print(f"Database restore error: {e}")





    
    def add_logo_to_main_window(self):
        """Add AIT logo to the main application window - LEFT SIDE ONLY"""
        try:
            from tkinter import PhotoImage
            from PIL import Image, ImageTk
            
            # Get the directory where the script is located
            script_dir = os.path.dirname(os.path.abspath(__file__))
            img_dir = os.path.join(script_dir, "img")
            logo_path = os.path.join(img_dir, "ait_logo.png")
        
            # Create img directory if it doesn't exist
            if not os.path.exists(img_dir):
                os.makedirs(img_dir)
                print(f"Created img directory: {img_dir}")
        
            # Alternative paths to try
            alternative_paths = [
                os.path.join(script_dir, "ait_logo.png"),  # Same directory as script
                os.path.join(script_dir, "img", "ait_logo.png"),  # img subdirectory
                "ait_logo.png"  # Current working directory
            ]
        
            logo_found = False
            for path in alternative_paths:
                if os.path.exists(path):
                    logo_path = path
                    logo_found = True
                    print(f"Found logo at: {logo_path}")
                    break
        
            if not logo_found:
                print(f"Logo file not found. Tried paths: {alternative_paths}")
                print("Please place your logo file in one of these locations.")
                return
            
            if os.path.exists(logo_path):
                # Open and resize image for tkinter
                pil_image = Image.open(logo_path)
                pil_image = pil_image.resize((200, 60), Image.Resampling.LANCZOS)  # Reasonable size for left corner
                
                # Convert to PhotoImage
                self.logo_image = ImageTk.PhotoImage(pil_image)
                
                # Create logo frame at top left of window
                logo_frame = ttk.Frame(self.root)
                logo_frame.pack(side='top', fill='x', padx=10, pady=5)
            
                # Add logo label (left aligned)
                logo_label = ttk.Label(logo_frame, image=self.logo_image)
                logo_label.pack(side='left')
                
                # Optional: Add a subtle separator line below
                separator = ttk.Separator(self.root, orient='horizontal')
                separator.pack(fill='x', padx=10, pady=2)
            
        except ImportError:
            print("PIL (Pillow) not installed. Install with: pip install Pillow")
        except Exception as e:
            print(f"Error loading logo: {e}")
    
    
    
    
    # SharePoint backup functions removed - using PostgreSQL only


    def on_closing(self):
        """Close application, end user session, and cleanup connections"""
        try:
            result = messagebox.askyesno(
                "Confirm Exit",
                "Are you sure you want to close the application?",
                icon='question'
            )

            if result:
                try:
                    # End user session
                    if hasattr(self, 'session_id') and self.session_id:
                        try:
                            with db_pool.get_cursor() as cursor:
                                UserManager.end_session(cursor, self.session_id)
                                print(f"CHECK: User session ended for {self.user_name}")
                        except Exception as session_error:
                            # If database connection already lost, that's okay during shutdown
                            error_str = str(session_error).lower()
                            if 'connection' in error_str or 'abort' in error_str:
                                print(f"INFO: Database connection already closed during session cleanup (this is normal)")
                            else:
                                print(f"WARNING: Error ending session: {session_error}")

                    # Close main connection if it exists
                    if hasattr(self, 'conn') and self.conn:
                        try:
                            if not self.conn.closed:
                                self.conn.commit()  # Save any pending changes
                                db_pool.return_connection(self.conn)
                                print("CHECK: Database connection returned to pool")
                            else:
                                print("INFO: Connection already closed")
                        except Exception as conn_error:
                            error_str = str(conn_error).lower()
                            if 'connection' in error_str or 'abort' in error_str:
                                print(f"INFO: Database connection already closed during cleanup (this is normal)")
                            else:
                                print(f"WARNING: Error returning connection: {conn_error}")

                except Exception as e:
                    print(f"WARNING: Unexpected error during cleanup: {e}")

                self.root.destroy()

        except Exception as e:
            print(f"Error during closing: {e}")
            self.root.destroy()

    # Backup functions removed - using PostgreSQL only

    def init_pm_templates_database(self):
        """Initialize PM templates database tables"""
        cursor = self.conn.cursor()
    
        # PM Templates table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS pm_templates (
                id SERIAL PRIMARY KEY,
                bfm_equipment_no TEXT,
                template_name TEXT,
                pm_type TEXT,
                checklist_items TEXT,  -- JSON string
                special_instructions TEXT,
                safety_notes TEXT,
                estimated_hours REAL,
                created_date TEXT DEFAULT CURRENT_TIMESTAMP,
                updated_date TEXT DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (bfm_equipment_no) REFERENCES equipment (bfm_equipment_no)
            )
        ''')
    
        # Default checklist items for fallback
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS default_pm_checklist (
                id SERIAL PRIMARY KEY,
                pm_type TEXT,
                step_number INTEGER,
                description TEXT,
                is_active BOOLEAN DEFAULT TRUE,
            )
        ''')
    
        # Insert default checklist if empty
        cursor.execute('SELECT COUNT(*) FROM default_pm_checklist')
        if cursor.fetchone()[0] == 0:
            default_items = [
                (1, "Special Equipment Used (List):"),
                (2, "Validate your maintenance with Date / Stamp / Hours"),
                (3, "Refer to drawing when performing maintenance"),
                (4, "Make sure all instruments are properly calibrated"),
                (5, "Make sure tool is properly identified"),
                (6, "Make sure all mobile mechanisms move fluidly"),
                (7, "Visually inspect the welds"),
                (8, "Take note of any anomaly or defect (create a CM if needed)"),
                (9, "Check all screws. Tighten if needed."),
                (10, "Check the pins for wear"),
                (11, "Make sure all tooling is secured to the equipment with cable"),
                (12, "Ensure all tags (BFM and SAP) are applied and securely fastened"),
                (13, "All documentation are picked up from work area"),
                (14, "All parts and tools have been picked up"),
                (15, "Workspace has been cleaned up"),
                (16, "Dry runs have been performed (tests, restarts, etc.)"),
                (17, "Ensure that AIT Sticker is applied")
            ]
        
            for step_num, description in default_items:
                cursor.execute('''
                    INSERT INTO default_pm_checklist (pm_type, step_number, description)
                    VALUES ('All', %s, %s)
                ''', (step_num, description))
    
        self.conn.commit()

    def edit_pm_template_dialog(self):
        """Edit existing PM template with full functionality"""
        selected = self.templates_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a template to edit")
            return

        # Get selected template data
        item = self.templates_tree.item(selected[0])
        bfm_no = str(item['values'][0])
        template_name = item['values'][1]
        pm_type = item['values'][2]

        # Fetch full template data - MUST filter by pm_type
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT id, bfm_equipment_no, template_name, pm_type, checklist_items,
                special_instructions, safety_notes, estimated_hours
            FROM pm_templates
            WHERE bfm_equipment_no = %s AND template_name = %s AND pm_type = %s
        ''', (bfm_no, template_name, pm_type))

        template_data = cursor.fetchone()
        if not template_data:
            messagebox.showerror("Error", "Template not found")
            return

        # Extract template data
        (template_id, orig_bfm_no, orig_name, orig_pm_type, orig_checklist_json, 
        orig_instructions, orig_safety, orig_hours) = template_data

        # Parse checklist items
        try:
            orig_checklist_items = json.loads(orig_checklist_json) if orig_checklist_json else []
        except:
            orig_checklist_items = []

        # Create edit dialog (similar structure to create dialog)
        dialog = tk.Toplevel(self.root)
        dialog.title(f"Edit PM Template - {template_name}")
        dialog.geometry("800x750")
        dialog.transient(self.root)
        dialog.grab_set()

        # Template information (pre-populated)
        header_frame = ttk.LabelFrame(dialog, text="Template Information", padding=10)
        header_frame.pack(fill='x', padx=10, pady=5)

        # BFM Equipment (read-only)
        ttk.Label(header_frame, text="BFM Equipment Number:").grid(row=0, column=0, sticky='w', pady=5)
        bfm_var = tk.StringVar(value=orig_bfm_no)
        bfm_label = ttk.Label(header_frame, text=orig_bfm_no, font=('Arial', 10, 'bold'))
        bfm_label.grid(row=0, column=1, sticky='w', padx=5, pady=5)

        # Template name (editable)
        ttk.Label(header_frame, text="Template Name:").grid(row=0, column=2, sticky='w', pady=5, padx=(20,5))
        template_name_var = tk.StringVar(value=orig_name)
        ttk.Entry(header_frame, textvariable=template_name_var, width=25).grid(row=0, column=3, sticky='w', padx=5, pady=5)

        # PM Type (editable)
        ttk.Label(header_frame, text="PM Type:").grid(row=1, column=0, sticky='w', pady=5)
        pm_type_var = tk.StringVar(value=orig_pm_type)
        pm_type_combo = ttk.Combobox(header_frame, textvariable=pm_type_var, 
                                values=['Weekly', 'Monthly', 'Six Month', 'Annual'], width=22)
        pm_type_combo.grid(row=1, column=1, sticky='w', padx=5, pady=5)

        # Estimated hours (editable)
        ttk.Label(header_frame, text="Estimated Hours:").grid(row=1, column=2, sticky='w', pady=5, padx=(20,5))
        est_hours_var = tk.StringVar(value=str(orig_hours))
        ttk.Entry(header_frame, textvariable=est_hours_var, width=10).grid(row=1, column=3, sticky='w', padx=5, pady=5)

        # Custom checklist section
        checklist_frame = ttk.LabelFrame(dialog, text="Edit PM Checklist", padding=10)
        checklist_frame.pack(fill='both', expand=True, padx=10, pady=5)

        # Checklist controls
        controls_subframe = ttk.Frame(checklist_frame)
        controls_subframe.pack(fill='x', pady=5)

        # Checklist listbox with scrollbar
        list_frame = ttk.Frame(checklist_frame)
        list_frame.pack(fill='both', expand=True, pady=5)

        checklist_listbox = tk.Listbox(list_frame, height=15, font=('Arial', 9))
        list_scrollbar = ttk.Scrollbar(list_frame, orient='vertical', command=checklist_listbox.yview)
        checklist_listbox.configure(yscrollcommand=list_scrollbar.set)

        checklist_listbox.pack(side='left', fill='both', expand=True)
        list_scrollbar.pack(side='right', fill='y')

        # Step editing
        edit_frame = ttk.LabelFrame(checklist_frame, text="Edit Selected Step", padding=5)
        edit_frame.pack(fill='x', pady=5)

        step_text_var = tk.StringVar()
        step_entry = ttk.Entry(edit_frame, textvariable=step_text_var, width=80)
        step_entry.pack(side='left', fill='x', expand=True, padx=5)

        # Special instructions and safety notes (pre-populated)
        notes_frame = ttk.LabelFrame(dialog, text="Additional Information", padding=10)
        notes_frame.pack(fill='x', padx=10, pady=5)

        ttk.Label(notes_frame, text="Special Instructions:").grid(row=0, column=0, sticky='nw', pady=2)
        special_instructions_text = tk.Text(notes_frame, height=3, width=50)
        special_instructions_text.grid(row=0, column=1, sticky='ew', padx=5, pady=2)
        special_instructions_text.insert('1.0', orig_instructions or '')

        ttk.Label(notes_frame, text="Safety Notes:").grid(row=1, column=0, sticky='nw', pady=2)
        safety_notes_text = tk.Text(notes_frame, height=3, width=50)
        safety_notes_text.grid(row=1, column=1, sticky='ew', padx=5, pady=2)
        safety_notes_text.insert('1.0', orig_safety or '')

        notes_frame.grid_columnconfigure(1, weight=1)

        # Helper functions (same as create dialog)
        def add_checklist_step():
            step_text = step_text_var.get().strip()
            if step_text:
                step_num = checklist_listbox.size() + 1
                checklist_listbox.insert('end', f"{step_num}. {step_text}")
                step_text_var.set('')

        def remove_checklist_step():
            selection = checklist_listbox.curselection()
            if selection:
                checklist_listbox.delete(selection[0])
                renumber_steps()

        def renumber_steps():
            items = []
            for i in range(checklist_listbox.size()):
                step_text = checklist_listbox.get(i)
                step_content = '. '.join(step_text.split('. ')[1:]) if '. ' in step_text else step_text
                items.append(f"{i+1}. {step_content}")
        
            checklist_listbox.delete(0, 'end')
            for item in items:
                checklist_listbox.insert('end', item)

        def update_selected_step():
            selection = checklist_listbox.curselection()
            if selection and step_text_var.get().strip():
                step_num = selection[0] + 1
                new_text = f"{step_num}. {step_text_var.get().strip()}"
                checklist_listbox.delete(selection[0])
                checklist_listbox.insert(selection[0], new_text)

        def move_step_up():
            selection = checklist_listbox.curselection()
            if selection and selection[0] > 0:
                idx = selection[0]
                item = checklist_listbox.get(idx)
                checklist_listbox.delete(idx)
                checklist_listbox.insert(idx-1, item)
                checklist_listbox.selection_set(idx-1)
                renumber_steps()

        def move_step_down():
            selection = checklist_listbox.curselection()
            if selection and selection[0] < checklist_listbox.size()-1:
                idx = selection[0]
                item = checklist_listbox.get(idx)
                checklist_listbox.delete(idx)
                checklist_listbox.insert(idx+1, item)
                checklist_listbox.selection_set(idx+1)
                renumber_steps()

        def save_changes():
            try:
                # Validate inputs
                if not template_name_var.get().strip():
                    messagebox.showerror("Error", "Please enter template name")
                    return

                # Get updated checklist items
                checklist_items = []
                for i in range(checklist_listbox.size()):
                    step_text = checklist_listbox.get(i)
                    step_content = '. '.join(step_text.split('. ')[1:]) if '. ' in step_text else step_text
                    checklist_items.append(step_content)

                if not checklist_items:
                    messagebox.showerror("Error", "Please add at least one checklist item")
                    return

                # Update database
                cursor = self.conn.cursor()
                cursor.execute('''
                    UPDATE pm_templates SET
                    template_name = %s,
                    pm_type = %s,
                    checklist_items = %s,
                    special_instructions = %s,
                    safety_notes = %s,
                    estimated_hours = %s,
                    updated_date = CURRENT_TIMESTAMP
                    WHERE id = %s
                ''', (
                    template_name_var.get().strip(),
                    pm_type_var.get(),
                    json.dumps(checklist_items),
                    special_instructions_text.get('1.0', 'end-1c'),
                    safety_notes_text.get('1.0', 'end-1c'),
                    float(est_hours_var.get() or 1.0),
                    template_id
                ))

                self.conn.commit()
                messagebox.showinfo("Success", "PM template updated successfully!")
                dialog.destroy()
                self.load_pm_templates()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to update template: {str(e)}")

        def on_step_select(event):
            selection = checklist_listbox.curselection()
            if selection:
                step_text = checklist_listbox.get(selection[0])
                step_content = '. '.join(step_text.split('. ')[1:]) if '. ' in step_text else step_text
                step_text_var.set(step_content)

        def parse_word_document(file_path):
            """Parse Word document and extract PM template information"""
            try:
                if not DOCX_AVAILABLE:
                    messagebox.showerror("Error",
                        "python-docx library is not installed.\n\n"
                        "Please install it using: pip install python-docx")
                    return None

                doc = Document(file_path)

                # Extract all paragraphs and tables
                checklist_items = []
                special_instructions = []
                safety_notes = []
                all_text_lines = []  # Fallback: collect all text

                # Track sections based on common PM document structure
                current_section = None

                for para in doc.paragraphs:
                    text = para.text.strip()
                    if not text:
                        continue

                    # Store all non-empty lines for fallback
                    all_text_lines.append(text)

                    # Detect section headers (case-insensitive)
                    text_lower = text.lower()

                    # Check if this is a section header
                    is_header = False
                    if any(keyword in text_lower for keyword in ['checklist', 'procedure', 'steps', 'instructions', 'tasks']):
                        current_section = 'checklist'
                        is_header = True
                    elif any(keyword in text_lower for keyword in ['special instruction', 'notes', 'additional', 'remarks']):
                        current_section = 'special'
                        is_header = True
                    elif any(keyword in text_lower for keyword in ['safety', 'caution', 'warning', 'ppe', 'hazard']):
                        current_section = 'safety'
                        is_header = True

                    if is_header:
                        continue

                    # More flexible pattern matching for checklist items
                    # Matches: "1.", "1)", "", "-", "*", "Step 1:", "Task 1", etc.
                    is_list_item = (
                        re.match(r'^[\d]+[.):\-\s]+', text) or  # Numbers with various separators
                        re.match(r'^[\-*]\s+', text) or  # Bullet points
                        re.match(r'^step\s*\d+', text_lower) or  # "Step 1", "Step 2"
                        re.match(r'^task\s*\d+', text_lower) or  # "Task 1", "Task 2"
                        re.match(r'^\d+\s*[-]\s*', text)  # "1 - ", "1  ", "1  "
                    )

                    if is_list_item:
                        # Remove various numbering/bullet patterns
                        clean_text = re.sub(r'^[\d]+[.):\-\s]+', '', text)
                        clean_text = re.sub(r'^[\-*]\s+', '', clean_text)
                        clean_text = re.sub(r'^step\s*\d+[:\-\s]*', '', clean_text, flags=re.IGNORECASE)
                        clean_text = re.sub(r'^task\s*\d+[:\-\s]*', '', clean_text, flags=re.IGNORECASE)
                        clean_text = re.sub(r'^\d+\s*[-]\s*', '', clean_text)
                        clean_text = clean_text.strip()

                        if clean_text:  # Only add if there's content after removing numbering
                            if current_section == 'safety':
                                safety_notes.append(clean_text)
                            elif current_section == 'special':
                                special_instructions.append(clean_text)
                            else:
                                # Default to checklist
                                checklist_items.append(clean_text)
                    else:
                        # Non-list-item text
                        if current_section == 'safety':
                            safety_notes.append(text)
                        elif current_section == 'special':
                            special_instructions.append(text)
                        elif current_section == 'checklist':
                            # If we're in checklist section, treat all lines as checklist items
                            checklist_items.append(text)

                # Process tables (common in PM documents)
                for table in doc.tables:
                    for row in table.rows:
                        row_text = []
                        for cell in row.cells:
                            cell_text = cell.text.strip()
                            if cell_text:
                                row_text.append(cell_text)

                        if row_text:
                            # If row has multiple cells, join them
                            combined_text = ' - '.join(row_text)
                            all_text_lines.append(combined_text)

                            # Don't be too strict - add table rows to checklist
                            if combined_text and len(combined_text) > 3:  # At least some content
                                # Remove numbering if present
                                clean_combined = re.sub(r'^[\d]+[.):\-\s]+', '', combined_text).strip()
                                if clean_combined:
                                    checklist_items.append(clean_combined)

                # FALLBACK: If no checklist items were found, use all text lines
                if not checklist_items and all_text_lines:
                    # Filter out very short lines (likely headers) and use the rest
                    checklist_items = [line for line in all_text_lines if len(line) > 10]

                return {
                    'checklist_items': checklist_items,
                    'special_instructions': '\n'.join(special_instructions),
                    'safety_notes': '\n'.join(safety_notes)
                }

            except Exception as e:
                messagebox.showerror("Error", f"Failed to parse Word document:\n{str(e)}\n\nTraceback:\n{traceback.format_exc()}")
                return None

        def upload_word_document():
            """Open file dialog and import Word document content"""
            if not DOCX_AVAILABLE:
                messagebox.showerror("Error",
                    "python-docx library is not installed.\n\n"
                    "Please install it using: pip install python-docx\n"
                    "or run: pip install -r requirements.txt")
                return

            file_path = filedialog.askopenfilename(
                title="Select Word Document",
                filetypes=[
                    ("Word Documents", "*.docx"),
                    ("All Files", "*.*")
                ]
            )

            if not file_path:
                return

            # Parse the document
            parsed_data = parse_word_document(file_path)

            if not parsed_data:
                return

            # Confirm before auto-filling
            checklist_count = len(parsed_data['checklist_items'])
            has_instructions = bool(parsed_data['special_instructions'])
            has_safety = bool(parsed_data['safety_notes'])

            msg = f"Found in Word document:\n"
            msg += f"   {checklist_count} checklist items\n"
            msg += f"   Special Instructions: {'Yes' if has_instructions else 'No'}\n"
            msg += f"   Safety Notes: {'Yes' if has_safety else 'No'}\n\n"
            msg += "This will replace current form content.\n\nContinue?"

            if not messagebox.askyesno("Import Word Document", msg):
                return

            # Clear existing checklist
            checklist_listbox.delete(0, 'end')

            # Add checklist items
            for i, item in enumerate(parsed_data['checklist_items'], 1):
                checklist_listbox.insert('end', f"{i}. {item}")

            # Set special instructions
            if parsed_data['special_instructions']:
                special_instructions_text.delete('1.0', 'end')
                special_instructions_text.insert('1.0', parsed_data['special_instructions'])

            # Set safety notes
            if parsed_data['safety_notes']:
                safety_notes_text.delete('1.0', 'end')
                safety_notes_text.insert('1.0', parsed_data['safety_notes'])

            messagebox.showinfo("Success",
                f"Word document imported successfully!\n\n"
                f"Added {checklist_count} checklist items.\n"
                f"Review and adjust as needed before saving.")

        # Create buttons
        ttk.Button(controls_subframe, text="Add Step", command=add_checklist_step).pack(side='left', padx=5)
        ttk.Button(controls_subframe, text="Remove Step", command=remove_checklist_step).pack(side='left', padx=5)
        ttk.Button(controls_subframe, text="Upload Word Doc", command=upload_word_document).pack(side='left', padx=5)
        ttk.Button(controls_subframe, text="Move Up", command=move_step_up).pack(side='left', padx=5)
        ttk.Button(controls_subframe, text="Move Down", command=move_step_down).pack(side='left', padx=5)

        ttk.Button(edit_frame, text="Update Step", command=update_selected_step).pack(side='right', padx=5)

        # Bind listbox selection
        checklist_listbox.bind('<<ListboxSelect>>', on_step_select)

        # Load existing checklist items
        checklist_listbox.delete(0, 'end')
        for i, item in enumerate(orig_checklist_items, 1):
            checklist_listbox.insert('end', f"{i}. {item}")

        # Save and Cancel buttons
        button_frame = ttk.Frame(dialog)
        button_frame.pack(side='bottom', fill='x', padx=10, pady=10)

        ttk.Button(button_frame, text="Save Changes", command=save_changes).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side='right', padx=5)

    def preview_pm_template(self):
        """Preview selected PM template"""
        selected = self.templates_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a template to preview")
            return
    
        item = self.templates_tree.item(selected[0])
        bfm_no = str(item['values'][0])
        template_name = item['values'][1]

        # Get template data
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT pt.*, e.description, e.sap_material_no, e.location
            FROM pm_templates pt
            LEFT JOIN equipment e ON pt.bfm_equipment_no = e.bfm_equipment_no
            WHERE pt.bfm_equipment_no = %s AND pt.template_name = %s
        ''', (bfm_no, template_name))
    
        template_data = cursor.fetchone()
        if not template_data:
            messagebox.showerror("Error", "Template not found")
            return
    
        # Create preview dialog
        preview_dialog = tk.Toplevel(self.root)
        preview_dialog.title(f"PM Template Preview - {bfm_no}")
        preview_dialog.geometry("700x600")
        preview_dialog.transient(self.root)
        preview_dialog.grab_set()
    
        # Template info
        info_frame = ttk.LabelFrame(preview_dialog, text="Template Information", padding=10)
        info_frame.pack(fill='x', padx=10, pady=5)
    
        info_text = f"Equipment: {bfm_no} - {template_data[9] or 'N/A'}\n"
        info_text += f"Template: {template_data[2]}\n"
        info_text += f"PM Type: {template_data[3]}\n"
        info_text += f"Estimated Hours: {template_data[7]:.1f}h"
    
        ttk.Label(info_frame, text=info_text, font=('Arial', 10)).pack(anchor='w')
    
        # Checklist preview
        checklist_frame = ttk.LabelFrame(preview_dialog, text="PM Checklist", padding=10)
        checklist_frame.pack(fill='both', expand=True, padx=10, pady=5)
    
        checklist_text = tk.Text(checklist_frame, wrap='word', font=('Arial', 10))
        scrollbar = ttk.Scrollbar(checklist_frame, orient='vertical', command=checklist_text.yview)
        checklist_text.configure(yscrollcommand=scrollbar.set)
        
        # Format checklist content
        try:
            checklist_items = json.loads(template_data[4]) if template_data[4] else []
            content = "PM CHECKLIST:\n" + "="*50 + "\n\n"
        
            for i, item in enumerate(checklist_items, 1):
                content += f"{i:2d}. {item}\n"
        
            if template_data[5]:  # Special instructions
                content += f"\n\nSPECIAL INSTRUCTIONS:\n{template_data[5]}\n"
        
            if template_data[6]:  # Safety notes
                content += f"\n\nSAFETY NOTES:\n{template_data[6]}\n"
        
            checklist_text.insert('1.0', content)
            checklist_text.config(state='disabled')
        
        except Exception as e:
            checklist_text.insert('1.0', f"Error loading template: {str(e)}")
            checklist_text.config(state='disabled')
    
        checklist_text.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
    
        # Buttons
        button_frame = ttk.Frame(preview_dialog)
        button_frame.pack(side='bottom', fill='x', padx=10, pady=10)
    
        ttk.Button(button_frame, text="Close", command=preview_dialog.destroy).pack(side='right', padx=5)

    def delete_pm_template(self):
        """Delete selected PM template with enhanced confirmation"""
        selected = self.templates_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a template to delete")
            return

        item = self.templates_tree.item(selected[0])
        bfm_no = str(item['values'][0])
        template_name = item['values'][1]
        pm_type = item['values'][2]
        steps_count = item['values'][3]

        # Enhanced confirmation dialog
        result = messagebox.askyesno("Confirm Delete", 
                                f"Delete PM template '{template_name}'?\n\n"
                                f"Equipment: {bfm_no}\n"
                                f"PM Type: {pm_type}\n"
                                f"Steps: {steps_count}\n\n"
                                f"This action cannot be undone.\n"
                                f"Any equipment using this template will revert to default PM procedures.")

        if result:
            try:
                cursor = self.conn.cursor()
                # MUST filter by pm_type to delete correct template
                cursor.execute('''
                    DELETE FROM pm_templates
                    WHERE bfm_equipment_no = %s AND template_name = %s AND pm_type = %s
                ''', (bfm_no, template_name, pm_type))

                self.conn.commit()
                messagebox.showinfo("Success", f"Template '{template_name}' ({pm_type}) deleted successfully!")
                self.load_pm_templates()
                self.update_status(f"Deleted PM template: {template_name} ({pm_type})")

            except Exception as e:
                messagebox.showerror("Error", f"Failed to delete template: {str(e)}")

    def export_custom_template_pdf(self):
        """Export custom template as PDF form"""
        selected = self.templates_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a template to export")
            return

        item = self.templates_tree.item(selected[0])
        bfm_no = str(item['values'][0]).strip()
        template_name = str(item['values'][1]).strip()
        pm_type = item['values'][2]

        cursor = self.conn.cursor()

        # Check if this is a default template
        is_default = template_name.startswith("Default - ")

        if is_default:
            # Load default template data
            cursor.execute('''
                SELECT sap_material_no, description, tool_id_drawing_no, location
                FROM equipment
                WHERE bfm_equipment_no = %s
            ''', (bfm_no,))
            equipment_data = cursor.fetchone()

            if not equipment_data:
                messagebox.showerror("Error", "Equipment not found")
                return

            # Load default checklist items
            cursor.execute('''
                SELECT description
                FROM default_pm_checklist
                WHERE is_active = TRUE
                ORDER BY step_number
            ''')
            checklist_rows = cursor.fetchall()
            checklist_items = [row[0] for row in checklist_rows]

            # Construct template_data tuple to match expected format
            template_data = (
                None,  # template_id
                bfm_no,  # bfm_equipment_no
                template_name,  # template_name
                pm_type,  # pm_type
                json.dumps(checklist_items),  # checklist_items (JSON)
                None,  # special_instructions
                None,  # safety_notes
                2.0,  # estimated_hours
                None,  # created_date
                None,  # updated_date
                equipment_data[0],  # sap_material_no
                equipment_data[1],  # description
                equipment_data[2],  # tool_id_drawing_no
                equipment_data[3]   # location
            )
        else:
            # Get template and equipment data - MUST filter by pm_type
            cursor.execute('''
                SELECT pt.*, e.sap_material_no, e.description, e.tool_id_drawing_no, e.location
                FROM pm_templates pt
                LEFT JOIN equipment e ON pt.bfm_equipment_no = e.bfm_equipment_no
                WHERE pt.bfm_equipment_no = %s AND pt.template_name = %s AND pt.pm_type = %s
            ''', (bfm_no, template_name, pm_type))

            template_data = cursor.fetchone()
            if not template_data:
                messagebox.showerror("Error", f"Template not found for BFM: {bfm_no}, Name: {template_name}, PM Type: {pm_type}\n\nPlease check that the template exists in the database.")
                return

        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"PM_Template_{bfm_no}_{template_name.replace(' ', '_')}_{timestamp}.pdf"

            # Create custom PDF using the template data
            self.create_custom_pm_template_pdf(filename, template_data)

            messagebox.showinfo("Success", f"PM template exported to: {filename}")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to export template: {str(e)}")

    def create_custom_pm_template_pdf(self, filename, template_data):
        """Create PDF with custom PM template"""
        try:
            from reportlab.lib.pagesizes import letter
            from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib.units import inch
            from reportlab.lib import colors
        
            doc = SimpleDocTemplate(filename, pagesize=letter,
                                rightMargin=36, leftMargin=36,
                                topMargin=36, bottomMargin=36)
        
            styles = getSampleStyleSheet()
            story = []
        
            # Extract template data
            (template_id, bfm_no, template_name, pm_type, checklist_json,
            special_instructions, safety_notes, estimated_hours, created_date, updated_date,
            sap_no, description, tool_id, location) = template_data
        
            # Custom styles
            cell_style = ParagraphStyle(
                'CellStyle',
                parent=styles['Normal'],
                fontSize=8,
                leading=10,
                wordWrap='LTR'
            )
        
            header_cell_style = ParagraphStyle(
                'HeaderCellStyle',
                parent=styles['Normal'],
                fontSize=9,
                fontName='Helvetica-Bold',
                leading=11,
                wordWrap='LTR'
            )
        
            company_style = ParagraphStyle(
                'CompanyStyle',
                parent=styles['Heading1'],
                fontSize=14,
                fontName='Helvetica-Bold',
                alignment=1,
                textColor=colors.darkblue
            )
        
            # Header
            story.append(Paragraph("AIT - BUILDING THE FUTURE OF AEROSPACE", company_style))
            story.append(Spacer(1, 15))
        
            # Equipment information table
            equipment_data = [
                [
                    Paragraph('(SAP) Material Number:', header_cell_style), 
                    Paragraph(str(sap_no or ''), cell_style), 
                    Paragraph('Tool ID / Drawing Number:', header_cell_style), 
                    Paragraph(str(tool_id or ''), cell_style)
                ],
                [
                    Paragraph('(BFM) Equipment Number:', header_cell_style), 
                    Paragraph(str(bfm_no), cell_style), 
                    Paragraph('Description of Equipment:', header_cell_style), 
                    Paragraph(str(description or ''), cell_style)
                ],
                [
                    Paragraph('Custom Template:', header_cell_style), 
                    Paragraph(str(template_name), cell_style), 
                    Paragraph('Location of Equipment:', header_cell_style), 
                    Paragraph(str(location or ''), cell_style)
                ],
                [
                    Paragraph('Maintenance Technician:', header_cell_style), 
                    Paragraph('', cell_style), 
                    Paragraph('PM Cycle:', header_cell_style), 
                    Paragraph(str(pm_type), cell_style)
                ],
                [
                    Paragraph('Estimated Hours:', header_cell_style), 
                    Paragraph(f'{estimated_hours:.1f}h', cell_style), 
                    Paragraph('Date of Current PM:', header_cell_style), 
                    Paragraph('', cell_style)
                ]
            ]
        
            if safety_notes:
                equipment_data.append([
                    Paragraph(f'SAFETY: {safety_notes}', cell_style), 
                    '', '', ''
                ])
        
            equipment_data.append([
                Paragraph(f'Printed: {datetime.now().strftime("%m/%d/%Y")}', cell_style), 
                '', '', ''
            ])
        
            equipment_table = Table(equipment_data, colWidths=[1.8*inch, 1.7*inch, 1.8*inch, 1.7*inch])
            equipment_table.setStyle(TableStyle([
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ('LEFTPADDING', (0, 0), (-1, -1), 3),
                ('RIGHTPADDING', (0, 0), (-1, -1), 3),
                ('TOPPADDING', (0, 0), (-1, -1), 3),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
                ('SPAN', (0, -2), (-1, -2)),  # Safety spans all columns
                ('SPAN', (0, -1), (-1, -1)),  # Printed date spans all columns
            ]))
        
            story.append(equipment_table)
            story.append(Spacer(1, 15))
        
            # Custom checklist table
            checklist_data = [
                [
                    Paragraph('', header_cell_style), 
                    Paragraph('CUSTOM PM CHECKLIST:', header_cell_style), 
                    Paragraph('', header_cell_style), 
                    Paragraph('Completed', header_cell_style), 
                    Paragraph('Labor Time', header_cell_style)
                ]
            ]
        
            # Add custom checklist items
            try:
                checklist_items = json.loads(checklist_json) if checklist_json else []
            except:
                checklist_items = []
        
            if not checklist_items:
                checklist_items = ["No custom checklist defined - using default steps"]
        
            for idx, item in enumerate(checklist_items, 1):
                checklist_data.append([
                    Paragraph(str(idx), cell_style), 
                    Paragraph(item, cell_style), 
                    Paragraph('', cell_style), 
                    Paragraph('Yes', cell_style), 
                    Paragraph('hours    minutes', cell_style)
                ])
        
            checklist_table = Table(checklist_data, colWidths=[0.3*inch, 4.2*inch, 0.4*inch, 0.7*inch, 1.4*inch])
            checklist_table.setStyle(TableStyle([
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey),
                ('LEFTPADDING', (0, 0), (-1, -1), 2),
                ('RIGHTPADDING', (0, 0), (-1, -1), 2),
                ('TOPPADDING', (0, 0), (-1, -1), 2),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
            ]))
        
            story.append(checklist_table)
            story.append(Spacer(1, 15))
        
            # Special instructions section
            if special_instructions and special_instructions.strip():
                instructions_data = [
                    [Paragraph('SPECIAL INSTRUCTIONS:', header_cell_style)],
                    [Paragraph(special_instructions, cell_style)]
                ]
            
                instructions_table = Table(instructions_data, colWidths=[7*inch])
                instructions_table.setStyle(TableStyle([
                    ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                    ('FONTSIZE', (0, 0), (-1, -1), 8),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black),
                    ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                    ('BACKGROUND', (0, 0), (0, 0), colors.lightgrey),
                    ('LEFTPADDING', (0, 0), (-1, -1), 3),
                    ('RIGHTPADDING', (0, 0), (-1, -1), 3),
                    ('TOPPADDING', (0, 0), (-1, -1), 3),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
                ]))
            
                story.append(instructions_table)
                story.append(Spacer(1, 15))
        
            # Completion section
            completion_data = [
                [
                    Paragraph('Notes from Technician:', header_cell_style), 
                    Paragraph('', cell_style), 
                    Paragraph('Next Annual PM Date:', header_cell_style)
                ],
                [
                    Paragraph('', cell_style), 
                    Paragraph('', cell_style), 
                    Paragraph('', cell_style)
                ],
                [
                    Paragraph('All Data Entered Into System:', header_cell_style), 
                    Paragraph('', cell_style), 
                    Paragraph('Total Time', header_cell_style)
                ],
                [
                    Paragraph('Document Name', header_cell_style), 
                    Paragraph('Revision', header_cell_style), 
                    Paragraph('', cell_style)
                ],
                [
                    Paragraph(f'Custom_PM_Template_{template_name}', cell_style), 
                    Paragraph('A1', cell_style), 
                    Paragraph('', cell_style)
                ]
            ]
        
            completion_table = Table(completion_data, colWidths=[2.8*inch, 2.2*inch, 2*inch])
            completion_table.setStyle(TableStyle([
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ('LEFTPADDING', (0, 0), (-1, -1), 3),
                ('RIGHTPADDING', (0, 0), (-1, -1), 3),
                ('TOPPADDING', (0, 0), (-1, -1), 3),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
            ]))
        
            story.append(completion_table)
        
            # Build PDF
            doc.build(story)
        
        except Exception as e:
            print(f"Error creating custom PM template PDF: {e}")
            raise

    # Additional methods to integrate with existing PM completion system

    def get_pm_template_for_equipment(self, bfm_no, pm_type):
        """Get custom PM template for specific equipment and PM type"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT checklist_items, special_instructions, safety_notes, estimated_hours
                FROM pm_templates 
                WHERE bfm_equipment_no = %s AND pm_type = %s
                ORDER BY updated_date DESC LIMIT 1
            ''', (bfm_no, pm_type))
        
            result = cursor.fetchone()
            if result:
                checklist_json, special_instructions, safety_notes, estimated_hours = result
                try:
                    checklist_items = json.loads(checklist_json) if checklist_json else []
                    return {
                        'checklist_items': checklist_items,
                        'special_instructions': special_instructions,
                        'safety_notes': safety_notes,
                        'estimated_hours': estimated_hours
                    }
                except:
                    return None
            return None
        
        except Exception as e:
            print(f"Error getting PM template: {e}")
            return None

    def update_pm_completion_form_with_template(self):
        """Update PM completion form when equipment is selected

        ENHANCED: Auto-populate PM type AND PM Due Date from weekly_pm_schedules
        This prevents errors where wrong PM type is selected (e.g., Monthly logged as Annual)
        """
        bfm_no = self.completion_bfm_var.get().strip()
        pm_type = self.pm_type_var.get()

        if bfm_no:
            # CRITICAL FIX: Auto-populate PM type from schedule if not already selected
            # This prevents Monthly PMs from being logged as Annual PMs
            if not pm_type:
                try:
                    cursor = self.conn.cursor()
                    # Find the most recent scheduled PM for this equipment
                    cursor.execute('''
                        SELECT pm_type, scheduled_date, assigned_technician
                        FROM weekly_pm_schedules
                        WHERE bfm_equipment_no = %s AND status = 'Scheduled'
                        ORDER BY week_start_date DESC, scheduled_date DESC
                        LIMIT 1
                    ''', (bfm_no,))

                    schedule_result = cursor.fetchone()
                    if schedule_result:
                        scheduled_pm_type = schedule_result[0]
                        scheduled_date = schedule_result[1]
                        assigned_tech = schedule_result[2]

                        # Auto-fill PM type from schedule
                        self.pm_type_var.set(scheduled_pm_type)
                        self.pm_due_date_var.set(scheduled_date)

                        # Also pre-fill technician if available
                        if assigned_tech:
                            self.completion_tech_var.set(assigned_tech)

                        self.update_status(f"Auto-filled from schedule: {scheduled_pm_type} PM due {scheduled_date}")
                        pm_type = scheduled_pm_type
                except Exception as e:
                    print(f"Warning: Could not retrieve scheduled PM: {e}")

        if bfm_no and pm_type:
            # Auto-populate PM Due Date with scheduled_date from weekly_pm_schedules
            try:
                cursor = self.conn.cursor()
                cursor.execute('''
                    SELECT scheduled_date, week_start_date
                    FROM weekly_pm_schedules
                    WHERE bfm_equipment_no = %s AND pm_type = %s
                    ORDER BY week_start_date DESC
                    LIMIT 1
                ''', (bfm_no, pm_type))

                schedule_result = cursor.fetchone()
                if schedule_result and schedule_result[0]:
                    scheduled_date = schedule_result[0]
                    # Auto-populate PM Due Date field with the scheduled date
                    self.pm_due_date_var.set(scheduled_date)
                    self.update_status(f"PM Due Date auto-populated with scheduled date: {scheduled_date}")
            except Exception as e:
                print(f"Warning: Could not retrieve scheduled date: {e}")

            template = self.get_pm_template_for_equipment(bfm_no, pm_type)
            if template:
                # Update estimated hours
                self.labor_hours_var.set(str(int(template['estimated_hours'])))
                self.labor_minutes_var.set(str(int((template['estimated_hours'] % 1) * 60)))

                # Show template info
                self.update_status(f"Custom template found for {bfm_no} - {pm_type} PM")
            else:
                self.update_status(f"No custom template found for {bfm_no} - {pm_type} PM, using default")

    def create_equipment_pm_lookup_with_templates(self):
        """Enhanced equipment lookup that shows custom templates"""
        dialog = tk.Toplevel(self.root)
        dialog.title("Equipment PM Schedule & Templates")
        dialog.geometry("900x700")
        dialog.transient(self.root)
        dialog.grab_set()
    
        # Equipment search
        search_frame = ttk.LabelFrame(dialog, text="Equipment Search", padding=15)
        search_frame.pack(fill='x', padx=10, pady=5)
    
        ttk.Label(search_frame, text="BFM Equipment Number:", font=('Arial', 10, 'bold')).grid(row=0, column=0, sticky='w', pady=5)
    
        bfm_var = tk.StringVar()
        bfm_entry = ttk.Entry(search_frame, textvariable=bfm_var, width=20, font=('Arial', 11))
        bfm_entry.grid(row=0, column=1, padx=10, pady=5)
    
        search_btn = ttk.Button(search_frame, text="Look Up Equipment", 
                            command=lambda: self.lookup_equipment_with_templates(bfm_var.get().strip(), results_frame))
        search_btn.grid(row=0, column=2, padx=10, pady=5)
    
        # Results frame
        results_frame = ttk.LabelFrame(dialog, text="Equipment Information & Templates", padding=10)
        results_frame.pack(fill='both', expand=True, padx=10, pady=5)
    
        bfm_entry.focus_set()
        bfm_entry.bind('<Return>', lambda e: search_btn.invoke())

    def lookup_equipment_with_templates(self, bfm_no, parent_frame):
        """Lookup equipment with custom template information"""
        if not bfm_no:
            messagebox.showwarning("Warning", "Please enter a BFM Equipment Number")
            return
    
        try:
            cursor = self.conn.cursor()
        
            # Clear previous results
            for widget in parent_frame.winfo_children():
                widget.destroy()
        
            # Get equipment info
            cursor.execute('''
                SELECT sap_material_no, description, location, status
                FROM equipment 
                WHERE bfm_equipment_no = %s
            ''', (bfm_no,))
        
            equipment_data = cursor.fetchone()
            if not equipment_data:
                error_label = ttk.Label(parent_frame, 
                                    text=f"Equipment '{bfm_no}' not found in database",
                                    font=('Arial', 12, 'bold'), foreground='red')
                error_label.pack(pady=20)
                return
        
            # Equipment header
            header_text = f"Equipment: {bfm_no}\n"
            header_text += f"Description: {equipment_data[1] or 'N/A'}\n"
            header_text += f"Location: {equipment_data[2] or 'N/A'}\n"
            header_text += f"Status: {equipment_data[3] or 'Active'}"
        
            header_label = ttk.Label(parent_frame, text=header_text, font=('Arial', 10))
            header_label.pack(pady=10)
        
            # Get custom templates
            cursor.execute('''
                SELECT template_name, pm_type, checklist_items, estimated_hours, updated_date
                FROM pm_templates 
                WHERE bfm_equipment_no = %s
                ORDER BY pm_type, template_name
            ''', (bfm_no,))
        
            templates = cursor.fetchall()
        
            if templates:
                templates_frame = ttk.LabelFrame(parent_frame, text="Custom PM Templates", padding=10)
                templates_frame.pack(fill='x', pady=10)
            
                for template in templates:
                    name, pm_type, checklist_json, est_hours, updated = template
                    try:
                        checklist_items = json.loads(checklist_json) if checklist_json else []
                        step_count = len(checklist_items)
                    except:
                        step_count = 0
                
                    template_text = f"- {name} ({pm_type} PM) - {step_count} steps, {est_hours:.1f}h estimated"
                    ttk.Label(templates_frame, text=template_text, font=('Arial', 9)).pack(anchor='w')
            else:
                no_templates_label = ttk.Label(parent_frame, 
                                            text="No custom PM templates found for this equipment",
                                            font=('Arial', 10), foreground='orange')
                no_templates_label.pack(pady=10)
        
            # Regular PM schedule info (existing functionality)
            self.lookup_equipment_pm_schedule(bfm_no, parent_frame)
        
        except Exception as e:
            error_label = ttk.Label(parent_frame, 
                                text=f"Error looking up equipment: {str(e)}", 
                                font=('Arial', 10), foreground='red')
            error_label.pack(pady=20)
    
    
    
    def update_existing_annual_pm_dates(self):
        """One-time update to spread out existing annual PM dates"""
        try:
            cursor = self.conn.cursor()
        
            # Get all PM completions with the same annual date (like 2026-08-18)
            cursor.execute('''
                SELECT id, bfm_equipment_no, next_annual_pm_date 
                FROM pm_completions 
                WHERE next_annual_pm_date = '2026-08-18'
            ''')
        
            records = cursor.fetchall()
            updated_count = 0
        
            for record_id, bfm_no, current_date in records:
                try:
                    # Apply same offset logic as the new code
                    numeric_part = re.findall(r'\d+', bfm_no)
                    if numeric_part:
                        last_digits = int(numeric_part[-1]) % 61  # 0-60
                        offset_days = last_digits - 30  # -30 to +30 days
                    else:
                        offset_days = (hash(bfm_no) % 61) - 30  # -30 to +30 days
                
                    # Calculate new date
                    base_date = datetime.strptime(current_date, '%Y-%m-%d')
                    new_date = (base_date + timedelta(days=offset_days)).strftime('%Y-%m-%d')
                
                    # Update the record
                    cursor.execute('''
                        UPDATE pm_completions 
                        SET next_annual_pm_date = %s
                        WHERE id = %s
                    ''', (new_date, record_id))
                
                    updated_count += 1
                
                except Exception as e:
                    print(f"Error updating record {record_id}: {e}")
                    continue
        
            # Also update the equipment table next_annual_pm dates
            cursor.execute('''
                SELECT bfm_equipment_no, next_annual_pm 
                FROM equipment 
                WHERE next_annual_pm = '2026-08-18'
            ''')
        
            equipment_records = cursor.fetchall()
        
            for bfm_no, current_date in equipment_records:
                try:
                    numeric_part = re.findall(r'\d+', bfm_no)
                    if numeric_part:
                        last_digits = int(numeric_part[-1]) % 61
                        offset_days = last_digits - 30
                    else:
                        offset_days = (hash(bfm_no) % 61) - 30
                
                    base_date = datetime.strptime(current_date, '%Y-%m-%d')
                    new_date = (base_date + timedelta(days=offset_days)).strftime('%Y-%m-%d')
                
                    cursor.execute('''
                        UPDATE equipment 
                        SET next_annual_pm = %s 
                        WHERE bfm_equipment_no = %s
                    ''', (new_date, bfm_no))
                
                    updated_count += 1
                
                except Exception as e:
                    print(f"Error updating equipment {bfm_no}: {e}")
                    continue
        
            self.conn.commit()
            messagebox.showinfo("Success", f"Updated {updated_count} records with spread dates!")
        
        except Exception as e:
            messagebox.showerror("Error", f"Failed to update database: {str(e)}")
    
    
    def standardize_all_database_dates(self):
        """Standardize all dates in the database to YYYY-MM-DD format"""
        
        # Confirmation dialog
        result = messagebox.askyesno(
            "Confirm Date Standardization",
            "This will standardize ALL dates in the database to YYYY-MM-DD format.\n\n"
            "Tables affected:\n"
            "- Equipment (PM dates)\n"
            "- PM Completions\n"
            "- Weekly Schedules\n"
            "- Corrective Maintenance\n"
            "- Cannot Find Assets\n"
            "- Run to Failure Assets\n\n"
            "This action cannot be undone. Continue?",
            icon='warning'
        )
        
        if not result:
            return
        
        try:
            # Create progress dialog
            progress_dialog = tk.Toplevel(self.root)
            progress_dialog.title("Standardizing Dates...")
            progress_dialog.geometry("400x150")
            progress_dialog.transient(self.root)
            progress_dialog.grab_set()
            
            ttk.Label(progress_dialog, text="Standardizing dates in database...", 
                     font=('Arial', 12)).pack(pady=20)
            
            progress_var = tk.StringVar(value="Initializing...")
            progress_label = ttk.Label(progress_dialog, textvariable=progress_var)
            progress_label.pack(pady=10)
            
            progress_bar = ttk.Progressbar(progress_dialog, mode='indeterminate')
            progress_bar.pack(pady=10, padx=20, fill='x')
            progress_bar.start()
            
            # Update GUI
            self.root.update()
            
            # Perform standardization
            progress_var.set("Processing database...")
            self.root.update()
            
            standardizer = DateStandardizer(self.conn)
            total_updated, errors = standardizer.standardize_all_dates()
            
            progress_bar.stop()
            progress_dialog.destroy()
            
            # Show results
            if errors:
                error_msg = f"Date standardization completed with {len(errors)} errors:\n\n"
                error_msg += "\n".join(errors[:10])  # Show first 10 errors
                if len(errors) > 10:
                    error_msg += f"\n... and {len(errors) - 10} more errors"
                
                messagebox.showwarning("Standardization Complete (With Errors)", 
                                     f"Updated {total_updated} records.\n\n{error_msg}")
            else:
                messagebox.showinfo("Success", 
                                  f"Date standardization completed successfully!\n\n"
                                  f"Updated {total_updated} date records to YYYY-MM-DD format.\n\n"
                                  f"All dates are now standardized.")
            
            # Refresh displays
            self.refresh_equipment_list()
            self.load_recent_completions()
            if hasattr(self, 'load_cannot_find_assets'):
                self.load_cannot_find_assets()
            if hasattr(self, 'load_run_to_failure_assets'):
                self.load_run_to_failure_assets()
            
            self.update_status(f"Date standardization complete: {total_updated} records updated")
            
        except Exception as e:
            if 'progress_dialog' in locals():
                progress_dialog.destroy()
            messagebox.showerror("Error", f"Failed to standardize dates: {str(e)}")

    def format_date_display(self, date_str):
        """Format date for consistent display"""
        if not date_str:
            return ''
        try:
            # Parse using flexible method
            standardizer = DateStandardizer(self.conn)
            standardized = standardizer.parse_date_flexible(date_str)
            return standardized if standardized else date_str
        except:
            return date_str

    def get_current_date_standard(self):
        """Get current date in standard format"""
        return datetime.now().strftime('%Y-%m-%d')
    
    def __init__(self, root):
        self.root = root
        # === NEON CLOUD DATABASE CONFIGURATION ===
        self.DB_CONFIG = {
            'host': 'ep-tiny-paper-ad8glt26-pooler.c-2.us-east-1.aws.neon.tech',
            'port': 5432,
            'database': 'neondb',
            'user': 'neondb_owner',
            'password': 'npg_2Nm6hyPVWiIH',  # Click "Show password" and copy it
            'sslmode': 'require'
        }
        self.conn = None
        self.session_start_time = datetime.now()
        self.session_id = None  # Track user session for multi-user support
        self.user_id = None  # Database user ID
        self.root.title("AIT Complete CMMS - Computerized Maintenance Management System")

        # Apply UI scaling based on screen resolution
        # This is critical for 4K displays to make text/buttons readable
        # With DPI awareness set, this scaling will work correctly
        try:
            scaling_factor = get_scaling_factor()
            self.root.tk.call('tk', 'scaling', scaling_factor)
            print(f"Applied Tkinter scaling: {scaling_factor}")
        except Exception as e:
            print(f"Could not apply scaling: {e}")

        # Set default font sizes for all widgets to improve readability
        try:
            import tkinter.font as tkfont
            default_font = tkfont.nametofont("TkDefaultFont")
            default_font.configure(size=12)  # Increase default font size
            text_font = tkfont.nametofont("TkTextFont")
            text_font.configure(size=12)
            fixed_font = tkfont.nametofont("TkFixedFont")
            fixed_font.configure(size=11)
            print("Increased default font sizes for better readability")
        except Exception as e:
            print(f"Could not set default fonts: {e}")

        # Set a reasonable minimum window size
        # Don't set specific geometry - let maximize handle it
        self.root.minsize(1200, 800)

        # Maximize window immediately
        # This works best with DPI awareness enabled
        try:
            self.root.state('zoomed')  # Maximize window on Windows
            print("Window maximized (Windows)")
        except:
            try:
                self.root.attributes('-zoomed', True)  # Alternative for Linux
                print("Window maximized (Linux)")
            except:
                # If maximization fails, set a large default geometry
                self.root.geometry("1600x900")
                print("Window geometry set to default")

        # ===== ROLE-BASED ACCESS CONTROL =====
        self.current_user_role = None  # Will be set by login
        self.user_name = None

        # Technicians list - will be loaded from database after initialization
        self.technicians = []

        # ===== Initialize Database Connection Pool BEFORE Login =====
        # This must happen before login dialog because login needs database access
        print("Starting AIT CMMS Application...")
        try:
            # PERFORMANCE FIX: Reduced from min_conn=2, max_conn=20 to 1-10
            # Pool will grow as needed, but starts faster with fewer connections
            db_pool.initialize(self.DB_CONFIG, min_conn=1, max_conn=10)
            print("Database connection pool initialized successfully")
        except Exception as e:
            messagebox.showerror("Database Error",
                f"Failed to initialize database connection:\n{str(e)}\n\nPlease check your internet connection and try again.")
            self.root.destroy()
            return

        # Initialize users table and create default users BEFORE login
        try:
            self.init_users_table_before_login()
        except Exception as e:
            messagebox.showerror("Database Error",
                f"Failed to initialize users table:\n{str(e)}\n\nPlease check your database configuration.")
            self.root.destroy()
            return

        # Show login dialog after database pool is ready
        if not self.show_login_dialog():
            self.root.destroy()
            return

        # Ensure window is maximized after login
        self.root.update_idletasks()
        try:
            self.root.state('zoomed')
        except:
            try:
                self.root.attributes('-zoomed', True)
            except:
                pass

        # Load technicians list from database (after successful login)
        self.load_technicians_from_database()

        # ===== Initialize PostgreSQL Database =====
        self.init_database()
        self.mro_manager = MROStockManager(self)
        self.manuals_manager = ManualsManager(self)
        self.parts_integration = CMPartsIntegration(self)
        self.init_pm_templates_database()

        # PERFORMANCE FIX: Defer KPI initialization for managers to after UI loads
        # This saves 10-20 seconds at startup
        # KPI system will be initialized in deferred tasks

        # Add logo header
        self.add_logo_to_main_window()
    
        # PM Frequencies and cycles
        self.pm_frequencies = {
            'Monthly': 30,
            'Six Month': 180,
            'Annual': 365,
            'Run to Failure': 0,
            'CANNOT FIND': 0
        }
    
        # Weekly PM target
        self.weekly_pm_target = 130

        # Current week tracking
        self.current_week_start = self.get_week_start(datetime.now())
    
        # Create GUI based on user role
        self.create_gui()


        # Defer initial data loading to keep UI responsive at startup
        # This prevents the app from freezing during initialization
        self.root.after(100, self._deferred_startup_tasks)
    
        print(f"CHECK: AIT Complete CMMS System initialized successfully for {self.user_name} ({self.current_user_role})")

       
    
        # Add this at the very end of __init__:
    
        # Set up window close handler
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        self.setup_program_colors()
        print(f"AIT Complete CMMS System initialized successfully for {self.user_name} ({self.current_user_role})")

    def _deferred_startup_tasks(self):
        """Load data after UI is displayed to keep startup responsive"""
        try:
            # PERFORMANCE FIX: Don't load equipment data at startup
            # It will be loaded on-demand when first accessed
            # This saves 20-30 seconds at startup for large equipment tables

            # Update status
            if hasattr(self, 'update_status'):
                self.update_status("Checking database status...")

            # Check if database needs restore
            self.check_empty_database_and_offer_restore()

            # AUTO-MIGRATION: Fix Cannot Find schedules retroactively
            # This will update any past PM schedules that should be marked as "Cannot Find"
            if hasattr(self, 'update_status'):
                self.update_status("Checking for Cannot Find schedule updates...")
            try:
                updated_count = self.fix_cannot_find_schedules_retroactive(silent=True)
                if updated_count > 0:
                    print(f"AUTO-MIGRATION: Updated {updated_count} PM schedules to 'Cannot Find' status")
            except Exception as e:
                print(f"Error in Cannot Find schedule migration: {e}")

            # PERFORMANCE FIX: Initialize KPI system for managers asynchronously
            if self.current_user_role == 'Manager':
                if hasattr(self, 'update_status'):
                    self.update_status("Initializing KPI system in background...")
                # Initialize KPI system asynchronously
                self.root.after(500, self._async_init_kpi)
            else:
                # Final status update
                if hasattr(self, 'update_status'):
                    self.update_status("Ready")

        except Exception as e:
            print(f"Error in deferred startup tasks: {e}")
            import traceback
            traceback.print_exc()

    def _async_init_kpi(self):
        """Initialize KPI system asynchronously for managers"""
        try:
            self.init_kpi_system()
            if hasattr(self, 'update_status'):
                self.update_status("Ready - Updating statistics in background...")
            # After KPI init, schedule statistics update
            self.root.after(500, self._async_update_statistics)
        except Exception as e:
            print(f"Error initializing KPI system: {e}")
            if hasattr(self, 'update_status'):
                self.update_status("Ready")

    def _async_update_statistics(self):
        """Update statistics asynchronously without blocking UI"""
        try:
            self.update_equipment_statistics()
            if hasattr(self, 'update_status'):
                self.update_status("Ready")
        except Exception as e:
            print(f"Error updating statistics: {e}")
            if hasattr(self, 'update_status'):
                self.update_status("Ready (statistics update failed)")

    def close_cm_dialog(self):
        """Close selected CM with parts consumption tracking"""
        selected = self.cm_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a CM to close")
            return

        # Get selected CM data
        item = self.cm_tree.item(selected[0])
        cm_number = item['values'][0]
    
        # Fetch CM details
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT cm_number, bfm_equipment_no, description, assigned_technician, 
                status, labor_hours, notes, root_cause, corrective_action
            FROM corrective_maintenance 
            WHERE cm_number = %s
        ''', (cm_number,))
    
        cm_data = cursor.fetchone()
        if not cm_data:
            messagebox.showerror("Error", "CM not found")
            return
    
        (cm_num, equipment, desc, tech, status, labor_hrs, 
         notes, root_cause, corr_action) = cm_data
    
        # Check if already closed
        if status in ['Closed', 'Completed']:
            messagebox.showinfo("Info", f"CM {cm_number} is already closed")
            return
    
        # Create closure dialog
        dialog = tk.Toplevel(self.root)
        dialog.title(f"Close CM - {cm_number}")
        dialog.geometry("700x600")
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Header
        header_frame = ttk.Frame(dialog)
        header_frame.pack(fill='x', padx=10, pady=10)
    
        ttk.Label(header_frame, text=f"Close Corrective Maintenance", 
                font=('Arial', 12, 'bold')).pack()
        ttk.Label(header_frame, text=f"CM Number: {cm_number}", 
                font=('Arial', 10)).pack()
        ttk.Label(header_frame, text=f"Equipment: {equipment}", 
                font=('Arial', 10)).pack()
    
        # Main form frame with scrollbar
        canvas = tk.Canvas(dialog)
        scrollbar = ttk.Scrollbar(dialog, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
    
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
    
        canvas.pack(side="left", fill="both", expand=True, padx=10, pady=10)
        scrollbar.pack(side="right", fill="y")
    
        # Form fields
        row = 0
    
        # Completion Date
        ttk.Label(scrollable_frame, text="Completion Date*:", 
                font=('Arial', 10, 'bold')).grid(row=row, column=0, sticky='w', padx=10, pady=5)
        completion_date_var = tk.StringVar(value=datetime.now().strftime('%Y-%m-%d'))
        ttk.Entry(scrollable_frame, textvariable=completion_date_var, width=40).grid(
            row=row, column=1, sticky='w', padx=10, pady=5)
        ttk.Label(scrollable_frame, text="(Format: YYYY-MM-DD)", 
                font=('Arial', 8, 'italic')).grid(row=row, column=2, sticky='w')
        row += 1
    
        # Labor Hours
        ttk.Label(scrollable_frame, text="Total Labor Hours*:", 
                font=('Arial', 10, 'bold')).grid(row=row, column=0, sticky='w', padx=10, pady=5)
        labor_hours_var = tk.StringVar(value=str(labor_hrs) if labor_hrs else '')
        ttk.Entry(scrollable_frame, textvariable=labor_hours_var, width=40).grid(
            row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1
    
        ttk.Separator(scrollable_frame, orient='horizontal').grid(
            row=row, column=0, columnspan=3, sticky='ew', pady=10)
        row += 1
    
        # Root Cause
        ttk.Label(scrollable_frame, text="Root Cause*:", 
                font=('Arial', 10, 'bold')).grid(row=row, column=0, sticky='nw', padx=10, pady=5)
        root_cause_text = tk.Text(scrollable_frame, width=50, height=4)
        root_cause_text.insert('1.0', root_cause or '')
        root_cause_text.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1
    
        # Corrective Action
        ttk.Label(scrollable_frame, text="Corrective Action Taken*:", 
                font=('Arial', 10, 'bold')).grid(row=row, column=0, sticky='nw', padx=10, pady=5)
        corr_action_text = tk.Text(scrollable_frame, width=50, height=4)
        corr_action_text.insert('1.0', corr_action or '')
        corr_action_text.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1
    
        # Additional Notes
        ttk.Label(scrollable_frame, text="Additional Notes:", 
                font=('Arial', 10, 'bold')).grid(row=row, column=0, sticky='nw', padx=10, pady=5)
        notes_text = tk.Text(scrollable_frame, width=50, height=4)
        notes_text.insert('1.0', notes or '')
        notes_text.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1
    
        ttk.Separator(scrollable_frame, orient='horizontal').grid(
            row=row, column=0, columnspan=3, sticky='ew', pady=10)
        row += 1
    
        # Parts consumption question - THIS IS THE KEY INTEGRATION POINT
        ttk.Label(scrollable_frame, text="Were any parts used from MRO Stock?", 
                font=('Arial', 11, 'bold'), foreground='blue').grid(
                    row=row, column=0, columnspan=2, sticky='w', padx=10, pady=10)
        row += 1
    
        parts_used_var = tk.StringVar(value="No")
        parts_dialog_state = {'open': False}

        def gather_form_values():
            """Validate required fields and return a dict of form values, or None if invalid"""
            # Validate required fields
            if not completion_date_var.get().strip():
                messagebox.showerror("Error", "Completion date is required")
                return None
            # Accept multiple common date formats and normalize to YYYY-MM-DD
            date_input = completion_date_var.get().strip()
            parsed_date = None
            for fmt in ('%Y-%m-%d', '%m/%d/%Y', '%m/%d/%y', '%m-%d-%Y', '%m-%d-%y'):
                try:
                    parsed_date = datetime.strptime(date_input, fmt)
                    break
                except ValueError:
                    continue
            if not parsed_date:
                messagebox.showerror("Error", "Invalid date. Use YYYY-MM-DD or MM/DD/YY.")
                return None
            if not labor_hours_var.get().strip():
                messagebox.showerror("Error", "Labor hours is required")
                return None
            try:
                labor_hrs_value = float(labor_hours_var.get())
                if labor_hrs_value < 0:
                    messagebox.showerror("Error", "Labor hours cannot be negative")
                    return None
            except ValueError:
                messagebox.showerror("Error", "Invalid labor hours value")
                return None
            root_cause_value = root_cause_text.get('1.0', 'end-1c').strip()
            if not root_cause_value:
                messagebox.showerror("Error", "Root cause is required")
                return None
            corr_action_value = corr_action_text.get('1.0', 'end-1c').strip()
            if not corr_action_value:
                messagebox.showerror("Error", "Corrective action is required")
                return None
            additional_notes = notes_text.get('1.0', 'end-1c').strip()
            return {
                'completion_date': parsed_date.strftime('%Y-%m-%d'),
                'labor_hours': labor_hrs_value,
                'root_cause': root_cause_value,
                'corrective_action': corr_action_value,
                'notes': additional_notes,
            }

        def finalize_closure(form_values, parts_recorded):
            """Finalize CM closure after parts handling"""
            if not parts_recorded and parts_used_var.get() == "Yes":
                # User cancelled parts dialog, don't close CM
                parts_dialog_state['open'] = False
                return

            try:
                cursor = self.conn.cursor()

                # Update CM record
                cursor.execute('''
                    UPDATE corrective_maintenance
                    SET status = 'Closed',
                        completion_date = %s,
                        labor_hours = %s,
                        root_cause = %s,
                        corrective_action = %s,
                        notes = %s
                    WHERE cm_number = %s
                ''', (
                    form_values['completion_date'],
                    form_values['labor_hours'],
                    form_values['root_cause'],
                    form_values['corrective_action'],
                    form_values['notes'],
                    cm_number
                ))

                self.conn.commit()

                messagebox.showinfo("Success", 
                    f"CM {cm_number} completed successfully!\n\n"
                    f"Completion Date: {form_values['completion_date']}\n"
                    f"Labor Hours: {form_values['labor_hours']}\n"
                    f"Status: Closed")

                parts_dialog_state['open'] = False
                dialog.destroy()
                self.load_corrective_maintenance()

            except Exception as e:
                parts_dialog_state['open'] = False
                self.conn.rollback()
                messagebox.showerror("Error", f"Failed to complete CM: {str(e)}")

        def on_parts_choice():
            # Open parts dialog immediately when selecting Yes; prevent multiple openings
            try:
                if parts_used_var.get() == "Yes" and not parts_dialog_state['open']:
                    form_values = gather_form_values()
                    if form_values is None:
                        # Revert choice if form invalid
                        parts_used_var.set("No")
                        return
                    if hasattr(self, 'parts_integration'):
                        parts_dialog_state['open'] = True
                        # Open without closing this form; user can return and complete later
                        dlg = self.parts_integration.show_parts_consumption_dialog(
                            cm_number=cm_number,
                            technician_name=tech or 'Unknown',
                            callback=lambda success: finalize_closure(form_values, success)
                        )
                        # If the integration returns a dialog, track its close to reset flag
                        try:
                            if dlg is not None:
                                dlg.bind("<Destroy>", lambda e: parts_dialog_state.update({'open': False}))
                            else:
                                # If no dialog object is returned, reset immediately so user can open again
                                parts_dialog_state['open'] = False
                        except Exception:
                            parts_dialog_state['open'] = False
                    else:
                        messagebox.showerror("Error", 
                            "Parts integration module not initialized.\nPlease contact system administrator.")
            except Exception:
                parts_dialog_state['open'] = False

        ttk.Radiobutton(scrollable_frame, text="No parts were used", 
                    variable=parts_used_var, value="No", command=on_parts_choice).grid(
                        row=row, column=0, columnspan=2, sticky='w', padx=30, pady=5)
        row += 1
    
        ttk.Radiobutton(scrollable_frame, text="Yes, parts were used (will open parts dialog)", 
                    variable=parts_used_var, value="Yes", command=on_parts_choice).grid(
                        row=row, column=0, columnspan=2, sticky='w', padx=30, pady=5)
        row += 1
    
        # Button frame
        button_frame = ttk.Frame(dialog)
        button_frame.pack(fill='x', padx=10, pady=10)
    
        def validate_and_proceed():
            """Validate closure form and proceed to parts or close"""
            # Validate required fields
            if not completion_date_var.get().strip():
                messagebox.showerror("Error", "Completion date is required")
                return
        
            try:
                datetime.strptime(completion_date_var.get(), '%Y-%m-%d')
            except ValueError:
                messagebox.showerror("Error", "Invalid date format. Use YYYY-MM-DD")
                return
        
            if not labor_hours_var.get().strip():
                messagebox.showerror("Error", "Labor hours is required")
                return
        
            try:
                labor_hrs_value = float(labor_hours_var.get())
                if labor_hrs_value < 0:
                    messagebox.showerror("Error", "Labor hours cannot be negative")
                    return
            except ValueError:
                messagebox.showerror("Error", "Invalid labor hours value")
                return
        
            root_cause_value = root_cause_text.get('1.0', 'end-1c').strip()
            if not root_cause_value:
                messagebox.showerror("Error", "Root cause is required")
                return
        
            corr_action_value = corr_action_text.get('1.0', 'end-1c').strip()
            if not corr_action_value:
                messagebox.showerror("Error", "Corrective action is required")
                return
        
            # Get all form values
            completion_date = completion_date_var.get()
            labor_hours = float(labor_hours_var.get())
            root_cause = root_cause_value
            corrective_action = corr_action_value
            additional_notes = notes_text.get('1.0', 'end-1c').strip()
        
            # Combine notes
            all_notes = additional_notes
        
            def finalize_closure(parts_recorded):
                """Finalize CM closure after parts handling"""
                if not parts_recorded and parts_used_var.get() == "Yes":
                    # User cancelled parts dialog, don't close CM
                    return
            
                try:
                    cursor = self.conn.cursor()
                
                    # Update CM record
                    cursor.execute('''
                        UPDATE corrective_maintenance
                        SET status = 'Closed',
                            completion_date = %s,
                            labor_hours = %s,
                            root_cause = %s,
                            corrective_action = %s,
                            notes = %s
                        WHERE cm_number = %s
                    ''', (completion_date, labor_hours, root_cause, 
                        corrective_action, all_notes, cm_number))
                
                    self.conn.commit()
                
                    messagebox.showinfo("Success", 
                        f"CM {cm_number} closed successfully!\n\n"
                        f"Completion Date: {completion_date}\n"
                        f"Labor Hours: {labor_hours}\n"
                        f"Status: Closed")
                
                    dialog.destroy()
                    self.load_corrective_maintenance()
                
                except Exception as e:
                    self.conn.rollback()
                    messagebox.showerror("Error", f"Failed to close CM: {str(e)}")
        
            # Check if parts were used
            if parts_used_var.get() == "Yes":
                # Close this dialog and open parts consumption dialog
                dialog.destroy()
            
                # Open parts consumption dialog
                # This requires the CMPartsIntegration module to be initialized
                if hasattr(self, 'parts_integration'):
                    self.parts_integration.show_parts_consumption_dialog(
                        cm_number=cm_number,
                        technician_name=tech or 'Unknown',
                        callback=finalize_closure
                    )
                else:
                    messagebox.showerror("Error", 
                        "Parts integration module not initialized.\n"
                        "Please contact system administrator.")
                    # Still update CM but without parts
                    finalize_closure(True)
            else:
                # No parts used, close directly
                finalize_closure(True)
    
        ttk.Button(button_frame, text="Proceed to Close CM", 
                command=validate_and_proceed).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Cancel", 
                command=dialog.destroy).pack(side='left', padx=5)
    
    
    
    
    
    
    # sync_database_before_init removed - using PostgreSQL only

    def show_login_dialog(self):
        """Show database-backed login dialog with multi-user authentication"""
        login_successful = False

        def create_login_dialog():
            nonlocal login_successful

            login_dialog = tk.Toplevel(self.root)
            login_dialog.title("AIT CMMS - User Login")
            login_dialog.geometry("400x250")
            login_dialog.transient(self.root)
            login_dialog.grab_set()

            # Center the dialog
            login_dialog.update_idletasks()
            x = (login_dialog.winfo_screenwidth() // 2) - (login_dialog.winfo_width() // 2)
            y = (login_dialog.winfo_screenheight() // 2) - (login_dialog.winfo_height() // 2)
            login_dialog.geometry(f"+{x}+{y}")

            # Prevent closing the dialog with X button
            login_dialog.protocol("WM_DELETE_WINDOW", lambda: None)

            # Header
            header_frame = ttk.Frame(login_dialog)
            header_frame.pack(fill='x', padx=20, pady=20)

            ttk.Label(header_frame, text="AIT CMMS LOGIN",
                    font=('Arial', 16, 'bold')).pack()
            ttk.Label(header_frame, text="Enter your credentials",
                    font=('Arial', 10)).pack(pady=5)

            # Login form
            form_frame = ttk.Frame(login_dialog)
            form_frame.pack(fill='both', expand=True, padx=20, pady=10)

            # Username
            ttk.Label(form_frame, text="Username:", font=('Arial', 10)).grid(row=0, column=0, sticky='w', pady=5)
            username_var = tk.StringVar()
            username_entry = ttk.Entry(form_frame, textvariable=username_var, width=25)
            username_entry.grid(row=0, column=1, sticky='ew', pady=5)
            username_entry.focus_set()

            # Password
            ttk.Label(form_frame, text="Password:", font=('Arial', 10)).grid(row=1, column=0, sticky='w', pady=5)
            password_var = tk.StringVar()
            password_entry = ttk.Entry(form_frame, textvariable=password_var, show="*", width=25)
            password_entry.grid(row=1, column=1, sticky='ew', pady=5)

            form_frame.columnconfigure(1, weight=1)

            # Status label
            status_var = tk.StringVar()
            status_label = ttk.Label(form_frame, textvariable=status_var, foreground='red', font=('Arial', 9))
            status_label.grid(row=2, column=0, columnspan=2, pady=5)

            login_in_progress = False

            def do_login():
                nonlocal login_successful, login_in_progress

                if login_in_progress:
                    return

                login_in_progress = True
                status_var.set("")

                try:
                    username = username_var.get().strip()
                    password = password_var.get()

                    if not username or not password:
                        status_var.set("Please enter both username and password")
                        return

                    # Authenticate using database
                    try:
                        with db_pool.get_cursor() as cursor:
                            user = UserManager.authenticate(cursor, username, password)

                            if user:
                                # Update last login time
                                cursor.execute(
                                    "UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = %s",
                                    (user['id'],)
                                )

                                # Create session
                                self.session_id = UserManager.create_session(cursor, user['id'], user['username'])

                                # Set user info
                                self.user_id = user['id']
                                self.user_name = user['full_name']
                                self.current_user_role = user['role']

                                login_successful = True
                                dialog.quit()
                            else:
                                status_var.set("Invalid username or password")
                                password_var.set("")
                                password_entry.focus_set()

                    except Exception as e:
                        print(f"Login error: {e}")
                        status_var.set("Login failed. Please try again.")
                        password_var.set("")

                finally:
                    login_in_progress = False

            def cancel_login():
                nonlocal login_successful
                login_successful = False
                dialog.quit()

            # Buttons
            button_frame = ttk.Frame(login_dialog)
            button_frame.pack(side='bottom', fill='x', padx=20, pady=20)

            login_button = ttk.Button(button_frame, text="Login", command=do_login)
            login_button.pack(side='left', padx=5)
            ttk.Button(button_frame, text="Exit", command=cancel_login).pack(side='right', padx=5)

            # Enter key bindings
            def on_enter_key(event):
                if not login_in_progress:
                    do_login()

            username_entry.bind('<Return>', on_enter_key)
            password_entry.bind('<Return>', on_enter_key)

            return login_dialog

        # Create and run the dialog
        dialog = create_login_dialog()
        dialog.mainloop()
        dialog.destroy()

        return login_successful

    def load_technicians_from_database(self):
        """Load list of active technicians from the database (Technician role only)"""
        try:
            with db_pool.get_cursor() as cursor:
                cursor.execute("""
                    SELECT full_name
                    FROM users
                    WHERE is_active = TRUE AND role = 'Technician'
                    ORDER BY full_name
                """)

                rows = cursor.fetchall()
                self.technicians = [row['full_name'] for row in rows]

                print(f"Loaded {len(self.technicians)} technicians from database: {self.technicians}")

                # If no technicians found, use a fallback list
                if not self.technicians:
                    print("WARNING: No technicians found in database, using fallback list")
                    self.technicians = [
                        "Mark Michaels", "Jerone Bosarge", "Jon Hymel", "Nick Whisenant",
                        "James Dunnam", "Wayne Dunnam", "Nate Williams", "Rey Marikit", "Ronald Houghs",
                    ]

        except Exception as e:
            print(f"Error loading technicians from database: {e}")
            # Use fallback list on error
            self.technicians = [
                "Mark Michaels", "Jerone Bosarge", "Jon Hymel", "Nick Whisenant",
                "James Dunnam", "Wayne Dunnam", "Nate Williams", "Rey Marikit", "Ronald Houghs",
            ]

        # Update the exclusion list if the UI has been created
        if hasattr(self, 'excluded_technicians_listbox'):
            self.populate_technician_exclusion_list()


    def get_week_start(self, date):
        """Get the start of the week (Monday) for a given date"""
        days_since_monday = date.weekday()
        return date - timedelta(days=days_since_monday)
    
    def init_pm_templates_database(self):
        """Initialize PM templates database tables"""
        cursor = self.conn.cursor()

        # PERFORMANCE FIX: Check if PM templates tables already exist
        cursor.execute("""
            SELECT EXISTS (
                SELECT FROM information_schema.tables
                WHERE table_schema = 'public'
                AND table_name = 'pm_templates'
            )
        """)
        if cursor.fetchone()[0]:
            # Tables already exist, skip initialization
            return

        # PM Templates table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS pm_templates (
                id SERIAL PRIMARY KEY,
                bfm_equipment_no TEXT,
                template_name TEXT,
                pm_type TEXT,
                checklist_items TEXT,  -- JSON string
                special_instructions TEXT,
                safety_notes TEXT,
                estimated_hours REAL,
                created_date TEXT DEFAULT CURRENT_TIMESTAMP,
                updated_date TEXT DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (bfm_equipment_no) REFERENCES equipment (bfm_equipment_no)
            )
        ''')

        # Default checklist items for fallback
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS default_pm_checklist (
                id SERIAL PRIMARY KEY,
                pm_type TEXT,
                step_number INTEGER,
                description TEXT,
                is_active BOOLEAN DEFAULT TRUE
            )
        ''')

        # Insert default checklist if empty
        cursor.execute('SELECT COUNT(*) FROM default_pm_checklist')
        if cursor.fetchone()[0] == 0:
            default_items = [
                (1, "Special Equipment Used (List):"),
                (2, "Validate your maintenance with Date / Stamp / Hours"),
                (3, "Refer to drawing when performing maintenance"),
                (4, "Make sure all instruments are properly calibrated"),
                (5, "Make sure tool is properly identified"),
                (6, "Make sure all mobile mechanisms move fluidly"),
                (7, "Visually inspect the welds"),
                (8, "Take note of any anomaly or defect (create a CM if needed)"),
                (9, "Check all screws. Tighten if needed."),
                (10, "Check the pins for wear"),
                (11, "Make sure all tooling is secured to the equipment with cable"),
                (12, "Ensure all tags (BFM and SAP) are applied and securely fastened"),
                (13, "All documentation are picked up from work area"),
                (14, "All parts and tools have been picked up"),
                (15, "Workspace has been cleaned up"),
                (16, "Dry runs have been performed (tests, restarts, etc.)"),
                (17, "Ensure that AIT Sticker is applied")
            ]

            for step_num, description in default_items:
                cursor.execute('''
                    INSERT INTO default_pm_checklist (pm_type, step_number, description)
                    VALUES ('All', %s, %s)
                ''', (step_num, description))

        self.conn.commit()

    def create_custom_pm_templates_tab(self):
        """Create PM Templates management tab"""
        self.pm_templates_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.pm_templates_frame, text="PM Templates")

        # Controls
        controls_frame = ttk.LabelFrame(self.pm_templates_frame, text="PM Template Controls", padding=10)
        controls_frame.pack(fill='x', padx=10, pady=5)

        ttk.Button(controls_frame, text="Create Custom Template",
                command=self.create_custom_pm_template_dialog).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Edit Template",
                command=self.edit_pm_template_dialog).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Preview Template",
                command=self.preview_pm_template).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Delete Template",
                command=self.delete_pm_template).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Export Template to PDF",
                command=self.export_custom_template_pdf).pack(side='left', padx=5)

        # Create main content area with paned window for resizable sections
        main_paned = ttk.PanedWindow(self.pm_templates_frame, orient='vertical')
        main_paned.pack(fill='both', expand=True, padx=10, pady=5)

        # Top section: Equipment Search and List
        equipment_section = ttk.Frame(main_paned)
        main_paned.add(equipment_section, weight=1)

        # Equipment search frame
        equipment_search_frame = ttk.LabelFrame(equipment_section, text="Search Equipment by BFM/SAP/Name", padding=5)
        equipment_search_frame.pack(fill='x', padx=5, pady=5)

        ttk.Label(equipment_search_frame, text="Search:").pack(side='left', padx=5)
        self.equipment_search_var = tk.StringVar()
        self.equipment_search_var.trace('w', self.filter_equipment_for_pm_templates)
        equipment_search_entry = ttk.Entry(equipment_search_frame, textvariable=self.equipment_search_var, width=40)
        equipment_search_entry.pack(side='left', padx=5)
        ttk.Label(equipment_search_frame, text="(Search by BFM No, SAP No, or Equipment Name)").pack(side='left', padx=5)

        # Equipment list frame
        equipment_list_frame = ttk.LabelFrame(equipment_section, text="Equipment List - Double-click to view PM Templates", padding=10)
        equipment_list_frame.pack(fill='both', expand=True, padx=5, pady=5)

        self.equipment_pm_tree = ttk.Treeview(equipment_list_frame,
                                            columns=('BFM No', 'SAP No', 'Description', 'Location'),
                                            show='headings', height=8)

        equipment_columns = {
            'BFM No': ('BFM Equipment No', 150),
            'SAP No': ('SAP Material No', 150),
            'Description': ('Equipment Description', 300),
            'Location': ('Location', 150)
        }

        for col, (heading, width) in equipment_columns.items():
            self.equipment_pm_tree.heading(col, text=heading)
            self.equipment_pm_tree.column(col, width=width)

        # Scrollbars for equipment tree
        equipment_v_scrollbar = ttk.Scrollbar(equipment_list_frame, orient='vertical', command=self.equipment_pm_tree.yview)
        equipment_h_scrollbar = ttk.Scrollbar(equipment_list_frame, orient='horizontal', command=self.equipment_pm_tree.xview)
        self.equipment_pm_tree.configure(yscrollcommand=equipment_v_scrollbar.set, xscrollcommand=equipment_h_scrollbar.set)

        self.equipment_pm_tree.grid(row=0, column=0, sticky='nsew')
        equipment_v_scrollbar.grid(row=0, column=1, sticky='ns')
        equipment_h_scrollbar.grid(row=1, column=0, sticky='ew')

        equipment_list_frame.grid_rowconfigure(0, weight=1)
        equipment_list_frame.grid_columnconfigure(0, weight=1)

        # Bind double-click event to show templates for selected equipment
        self.equipment_pm_tree.bind('<Double-Button-1>', self.show_equipment_pm_templates)

        # Bottom section: Templates for selected equipment
        templates_section = ttk.Frame(main_paned)
        main_paned.add(templates_section, weight=1)

        # Template search frame (kept for backward compatibility)
        search_frame = ttk.Frame(templates_section)
        search_frame.pack(fill='x', padx=5, pady=5)

        ttk.Label(search_frame, text="Filter Templates:").pack(side='left', padx=5)
        self.template_search_var = tk.StringVar()
        self.template_search_var.trace('w', self.filter_template_list)
        search_entry = ttk.Entry(search_frame, textvariable=self.template_search_var, width=30)
        search_entry.pack(side='left', padx=5)

        # Templates list
        list_frame = ttk.LabelFrame(templates_section, text="PM Templates (Double-click equipment above to filter, or view all below)", padding=10)
        list_frame.pack(fill='both', expand=True, padx=5, pady=5)

        self.templates_tree = ttk.Treeview(list_frame,
                                        columns=('BFM No', 'Template Name', 'PM Type', 'Steps', 'Est Hours', 'Updated'),
                                        show='headings', height=8)

        template_columns = {
            'BFM No': ('BFM Equipment No', 120),
            'Template Name': ('Template Name', 200),
            'PM Type': ('PM Type', 100),
            'Steps': ('# Steps', 80),
            'Est Hours': ('Est Hours', 80),
            'Updated': ('Last Updated', 120)
        }

        for col, (heading, width) in template_columns.items():
            self.templates_tree.heading(col, text=heading)
            self.templates_tree.column(col, width=width)

        # Scrollbars
        template_v_scrollbar = ttk.Scrollbar(list_frame, orient='vertical', command=self.templates_tree.yview)
        template_h_scrollbar = ttk.Scrollbar(list_frame, orient='horizontal', command=self.templates_tree.xview)
        self.templates_tree.configure(yscrollcommand=template_v_scrollbar.set, xscrollcommand=template_h_scrollbar.set)

        # Pack treeview and scrollbars
        self.templates_tree.grid(row=0, column=0, sticky='nsew')
        template_v_scrollbar.grid(row=0, column=1, sticky='ns')
        template_h_scrollbar.grid(row=1, column=0, sticky='ew')

        list_frame.grid_rowconfigure(0, weight=1)
        list_frame.grid_columnconfigure(0, weight=1)

        # Load equipment and templates
        self.load_equipment_for_pm_templates()
        self.load_pm_templates()

    def init_kpi_system(self):
        """Initialize KPI system - run migration and create manager"""
        try:
            # Run KPI database migration
            print("Initializing KPI system...")
            migrate_kpi_database()

            # Create KPI manager instance
            self.kpi_manager = KPIManager(db_pool)

            print("KPI system initialized successfully")
        except Exception as e:
            print(f"Error initializing KPI system: {e}")
            import traceback
            traceback.print_exc()

    def create_custom_pm_template_dialog(self):
        """Dialog to create custom PM template for specific equipment"""
        print("="*60)
        print("CREATE CUSTOM PM TEMPLATE DIALOG - Starting...")
        print("="*60)

        dialog = tk.Toplevel(self.root)
        dialog.title("Create Custom PM Template")
        dialog.geometry("800x750")
        dialog.transient(self.root)
        dialog.grab_set()

        print("Dialog window created successfully")

        # Equipment selection
        header_frame = ttk.LabelFrame(dialog, text="Template Information", padding=10)
        header_frame.pack(fill='x', padx=10, pady=5)

        print("Header frame created")

        # BFM Equipment selection
        ttk.Label(header_frame, text="BFM Equipment Number:").grid(row=0, column=0, sticky='w', pady=5)
        bfm_var = tk.StringVar()
        bfm_combo = ttk.Combobox(header_frame, textvariable=bfm_var, width=25)
        bfm_combo.grid(row=0, column=1, sticky='w', padx=5, pady=5)

        # Populate equipment list
        try:
            cursor = self.conn.cursor()
            cursor.execute('SELECT bfm_equipment_no, description FROM equipment ORDER BY bfm_equipment_no')
            equipment_list = cursor.fetchall()

            # Handle None/NULL descriptions properly
            equipment_values = []
            for bfm, desc in equipment_list:
                if desc and len(desc) > 30:
                    equipment_values.append(f"{bfm} - {desc[:30]}...")
                elif desc:
                    equipment_values.append(f"{bfm} - {desc}")
                else:
                    equipment_values.append(f"{bfm} - (No Description)")

            bfm_combo['values'] = equipment_values
            print(f"Loaded {len(equipment_list)} equipment items for template creation")
        except Exception as e:
            print(f"ERROR: Could not load equipment list: {e}")
            messagebox.showerror("Database Error", f"Could not load equipment list:\n{e}\n\nPlease check database connection.")
            dialog.destroy()
            return

        # Template name
        ttk.Label(header_frame, text="Template Name:").grid(row=0, column=2, sticky='w', pady=5, padx=(20,5))
        template_name_var = tk.StringVar()
        ttk.Entry(header_frame, textvariable=template_name_var, width=25).grid(row=0, column=3, sticky='w', padx=5, pady=5)

        # PM Type
        ttk.Label(header_frame, text="PM Type:").grid(row=1, column=0, sticky='w', pady=5)
        pm_type_var = tk.StringVar(value='Annual')
        pm_type_combo = ttk.Combobox(header_frame, textvariable=pm_type_var, 
                                    values=['Weekly', 'Monthly', 'Six Month', 'Annual'], width=22)
        pm_type_combo.grid(row=1, column=1, sticky='w', padx=5, pady=5)

        # Estimated hours
        ttk.Label(header_frame, text="Estimated Hours:").grid(row=1, column=2, sticky='w', pady=5, padx=(20,5))
        est_hours_var = tk.StringVar(value="1.0")
        ttk.Entry(header_frame, textvariable=est_hours_var, width=10).grid(row=1, column=3, sticky='w', padx=5, pady=5)

        # Custom checklist section
        checklist_frame = ttk.LabelFrame(dialog, text="Custom PM Checklist", padding=10)
        checklist_frame.pack(fill='both', expand=True, padx=10, pady=5)

        # Checklist controls
        controls_subframe = ttk.Frame(checklist_frame)
        controls_subframe.pack(fill='x', pady=5)

        # Checklist listbox with scrollbar
        list_frame = ttk.Frame(checklist_frame)
        list_frame.pack(fill='both', expand=True, pady=5)

        checklist_listbox = tk.Listbox(list_frame, height=15, font=('Arial', 9))
        list_scrollbar = ttk.Scrollbar(list_frame, orient='vertical', command=checklist_listbox.yview)
        checklist_listbox.configure(yscrollcommand=list_scrollbar.set)

        checklist_listbox.pack(side='left', fill='both', expand=True)
        list_scrollbar.pack(side='right', fill='y')

        # Step editing
        edit_frame = ttk.LabelFrame(checklist_frame, text="Edit Selected Step", padding=5)
        edit_frame.pack(fill='x', pady=5)

        step_text_var = tk.StringVar()
        step_entry = ttk.Entry(edit_frame, textvariable=step_text_var, width=80)
        step_entry.pack(side='left', fill='x', expand=True, padx=5)

        # Special instructions and safety notes
        notes_frame = ttk.LabelFrame(dialog, text="Additional Information", padding=10)
        notes_frame.pack(fill='x', padx=10, pady=5)

        ttk.Label(notes_frame, text="Special Instructions:").grid(row=0, column=0, sticky='nw', pady=2)
        special_instructions_text = tk.Text(notes_frame, height=3, width=50)
        special_instructions_text.grid(row=0, column=1, sticky='ew', padx=5, pady=2)

        ttk.Label(notes_frame, text="Safety Notes:").grid(row=1, column=0, sticky='nw', pady=2)
        safety_notes_text = tk.Text(notes_frame, height=3, width=50)
        safety_notes_text.grid(row=1, column=1, sticky='ew', padx=5, pady=2)

        notes_frame.grid_columnconfigure(1, weight=1)

        # DEFINE ALL HELPER FUNCTIONS FIRST
        def add_checklist_step():
            step_text = step_text_var.get().strip()
            if step_text:
                step_num = checklist_listbox.size() + 1
                checklist_listbox.insert('end', f"{step_num}. {step_text}")
                step_text_var.set('')

        def remove_checklist_step():
            selection = checklist_listbox.curselection()
            if selection:
                checklist_listbox.delete(selection[0])
                renumber_steps()

        def renumber_steps():
            items = []
            for i in range(checklist_listbox.size()):
                step_text = checklist_listbox.get(i)
                step_content = '. '.join(step_text.split('. ')[1:]) if '. ' in step_text else step_text
                items.append(f"{i+1}. {step_content}")
        
            checklist_listbox.delete(0, 'end')
            for item in items:
                checklist_listbox.insert('end', item)

        def update_selected_step():
            selection = checklist_listbox.curselection()
            if selection and step_text_var.get().strip():
                step_num = selection[0] + 1
                new_text = f"{step_num}. {step_text_var.get().strip()}"
                checklist_listbox.delete(selection[0])
                checklist_listbox.insert(selection[0], new_text)

        def move_step_up():
            selection = checklist_listbox.curselection()
            if selection and selection[0] > 0:
                idx = selection[0]
                item = checklist_listbox.get(idx)
                checklist_listbox.delete(idx)
                checklist_listbox.insert(idx-1, item)
                checklist_listbox.selection_set(idx-1)
                renumber_steps()

        def move_step_down():
            selection = checklist_listbox.curselection()
            if selection and selection[0] < checklist_listbox.size()-1:
                idx = selection[0]
                item = checklist_listbox.get(idx)
                checklist_listbox.delete(idx)
                checklist_listbox.insert(idx+1, item)
                checklist_listbox.selection_set(idx+1)
                renumber_steps()

        def load_default_template():
            cursor = self.conn.cursor()
            cursor.execute('SELECT description FROM default_pm_checklist ORDER BY step_number')
            default_steps = cursor.fetchall()

            checklist_listbox.delete(0, 'end')
            for i, (step,) in enumerate(default_steps, 1):
                checklist_listbox.insert('end', f"{i}. {step}")

        def save_template():
            try:
                # Validate inputs
                if not bfm_var.get():
                    messagebox.showerror("Error", "Please select equipment")
                    return

                if not template_name_var.get().strip():
                    messagebox.showerror("Error", "Please enter template name")
                    return

                # Extract BFM number from combo selection
                bfm_no = bfm_var.get().split(' - ')[0]

                # Ensure database connection is alive before operations
                self._ensure_connection()
                cursor = self.conn.cursor()

                # Validate BFM number exists in equipment table
                cursor.execute('SELECT bfm_equipment_no, sap_material_no FROM equipment WHERE bfm_equipment_no = %s', (bfm_no,))
                equipment_result = cursor.fetchone()

                if not equipment_result:
                    messagebox.showerror("Validation Error",
                        f"BFM number '{bfm_no}' does not exist in the equipment database.\n\n"
                        "Please select a valid equipment from the dropdown.")
                    return

                # Validate SAP number if it exists
                bfm_from_db, sap_no = equipment_result
                if not sap_no or sap_no.strip() == '':
                    # Warn about missing SAP number but allow to continue
                    response = messagebox.askyesno("Warning: Missing SAP Number",
                        f"Equipment '{bfm_no}' does not have a SAP Material Number assigned.\n\n"
                        "This may cause issues with asset tracking and reporting.\n\n"
                        "Do you want to continue anyway?")
                    if not response:
                        return

                # Get checklist items
                checklist_items = []
                for i in range(checklist_listbox.size()):
                    step_text = checklist_listbox.get(i)
                    step_content = '. '.join(step_text.split('. ')[1:]) if '. ' in step_text else step_text
                    checklist_items.append(step_content)

                if not checklist_items:
                    messagebox.showerror("Error", "Please add at least one checklist item")
                    return

                # Check if a template already exists for this equipment + PM type combination
                cursor.execute('''
                    SELECT id, template_name FROM pm_templates
                    WHERE bfm_equipment_no = %s AND pm_type = %s
                    ORDER BY updated_date DESC LIMIT 1
                ''', (bfm_no, pm_type_var.get()))

                existing_template = cursor.fetchone()

                if existing_template:
                    existing_id, existing_name = existing_template
                    # Template exists - UPDATE it automatically
                    response = messagebox.askyesno("Replace Existing Template",
                        f"A PM template already exists for {bfm_no} ({pm_type_var.get()}):\n"
                        f"  Current template: '{existing_name}'\n"
                        f"  New template: '{template_name_var.get().strip()}'\n\n"
                        "This will replace the existing template with the new one.\n\n"
                        "Do you want to continue?")

                    if not response:
                        return

                    # UPDATE existing template
                    cursor.execute('''
                        UPDATE pm_templates
                        SET template_name = %s,
                            checklist_items = %s,
                            special_instructions = %s,
                            safety_notes = %s,
                            estimated_hours = %s,
                            updated_date = CURRENT_TIMESTAMP
                        WHERE id = %s
                    ''', (
                        template_name_var.get().strip(),
                        json.dumps(checklist_items),
                        special_instructions_text.get('1.0', 'end-1c'),
                        safety_notes_text.get('1.0', 'end-1c'),
                        float(est_hours_var.get() or 1.0),
                        existing_id
                    ))

                    self.conn.commit()
                    messagebox.showinfo("Success",
                        f"PM template updated successfully!\n\n"
                        f"Equipment: {bfm_no}\n"
                        f"PM Type: {pm_type_var.get()}\n"
                        f"Template: '{template_name_var.get().strip()}'")
                    dialog.destroy()
                    self.load_pm_templates()

                else:
                    # No existing template - INSERT new one
                    cursor.execute('''
                        INSERT INTO pm_templates
                        (bfm_equipment_no, template_name, pm_type, checklist_items,
                        special_instructions, safety_notes, estimated_hours)
                        VALUES (%s, %s, %s, %s, %s, %s, %s)
                    ''', (
                        bfm_no,
                        template_name_var.get().strip(),
                        pm_type_var.get(),
                        json.dumps(checklist_items),
                        special_instructions_text.get('1.0', 'end-1c'),
                        safety_notes_text.get('1.0', 'end-1c'),
                        float(est_hours_var.get() or 1.0)
                    ))

                    self.conn.commit()
                    messagebox.showinfo("Success",
                        f"Custom PM template created successfully!\n\n"
                        f"Equipment: {bfm_no}\n"
                        f"PM Type: {pm_type_var.get()}\n"
                        f"Template: '{template_name_var.get().strip()}'")
                    dialog.destroy()
                    self.load_pm_templates()

            except Exception as e:
                # Handle rollback safely - connection might already be closed
                try:
                    if hasattr(self, 'conn') and self.conn and not self.conn.closed:
                        self.conn.rollback()
                except (psycopg2.InterfaceError, psycopg2.OperationalError):
                    pass  # Connection already closed, nothing to rollback
                messagebox.showerror("Error", f"Failed to save template: {str(e)}")

        def on_step_select(event):
            selection = checklist_listbox.curselection()
            if selection:
                step_text = checklist_listbox.get(selection[0])
                step_content = '. '.join(step_text.split('. ')[1:]) if '. ' in step_text else step_text
                step_text_var.set(step_content)

        def parse_word_document(file_path):
            """Parse Word document and extract PM template information"""
            try:
                if not DOCX_AVAILABLE:
                    messagebox.showerror("Error",
                        "python-docx library is not installed.\n\n"
                        "Please install it using: pip install python-docx")
                    return None

                doc = Document(file_path)

                # Extract all paragraphs and tables
                checklist_items = []
                special_instructions = []
                safety_notes = []
                all_text_lines = []  # Fallback: collect all text

                # Track sections based on common PM document structure
                current_section = None

                for para in doc.paragraphs:
                    text = para.text.strip()
                    if not text:
                        continue

                    # Store all non-empty lines for fallback
                    all_text_lines.append(text)

                    # Detect section headers (case-insensitive)
                    text_lower = text.lower()

                    # Check if this is a section header
                    is_header = False
                    if any(keyword in text_lower for keyword in ['checklist', 'procedure', 'steps', 'instructions', 'tasks']):
                        current_section = 'checklist'
                        is_header = True
                    elif any(keyword in text_lower for keyword in ['special instruction', 'notes', 'additional', 'remarks']):
                        current_section = 'special'
                        is_header = True
                    elif any(keyword in text_lower for keyword in ['safety', 'caution', 'warning', 'ppe', 'hazard']):
                        current_section = 'safety'
                        is_header = True

                    if is_header:
                        continue

                    # More flexible pattern matching for checklist items
                    # Matches: "1.", "1)", "", "-", "*", "Step 1:", "Task 1", etc.
                    is_list_item = (
                        re.match(r'^[\d]+[.):\-\s]+', text) or  # Numbers with various separators
                        re.match(r'^[\-*]\s+', text) or  # Bullet points
                        re.match(r'^step\s*\d+', text_lower) or  # "Step 1", "Step 2"
                        re.match(r'^task\s*\d+', text_lower) or  # "Task 1", "Task 2"
                        re.match(r'^\d+\s*[-]\s*', text)  # "1 - ", "1  ", "1  "
                    )

                    if is_list_item:
                        # Remove various numbering/bullet patterns
                        clean_text = re.sub(r'^[\d]+[.):\-\s]+', '', text)
                        clean_text = re.sub(r'^[\-*]\s+', '', clean_text)
                        clean_text = re.sub(r'^step\s*\d+[:\-\s]*', '', clean_text, flags=re.IGNORECASE)
                        clean_text = re.sub(r'^task\s*\d+[:\-\s]*', '', clean_text, flags=re.IGNORECASE)
                        clean_text = re.sub(r'^\d+\s*[-]\s*', '', clean_text)
                        clean_text = clean_text.strip()

                        if clean_text:  # Only add if there's content after removing numbering
                            if current_section == 'safety':
                                safety_notes.append(clean_text)
                            elif current_section == 'special':
                                special_instructions.append(clean_text)
                            else:
                                # Default to checklist
                                checklist_items.append(clean_text)
                    else:
                        # Non-list-item text
                        if current_section == 'safety':
                            safety_notes.append(text)
                        elif current_section == 'special':
                            special_instructions.append(text)
                        elif current_section == 'checklist':
                            # If we're in checklist section, treat all lines as checklist items
                            checklist_items.append(text)

                # Process tables (common in PM documents)
                for table in doc.tables:
                    for row in table.rows:
                        row_text = []
                        for cell in row.cells:
                            cell_text = cell.text.strip()
                            if cell_text:
                                row_text.append(cell_text)

                        if row_text:
                            # If row has multiple cells, join them
                            combined_text = ' - '.join(row_text)
                            all_text_lines.append(combined_text)

                            # Don't be too strict - add table rows to checklist
                            if combined_text and len(combined_text) > 3:  # At least some content
                                # Remove numbering if present
                                clean_combined = re.sub(r'^[\d]+[.):\-\s]+', '', combined_text).strip()
                                if clean_combined:
                                    checklist_items.append(clean_combined)

                # FALLBACK: If no checklist items were found, use all text lines
                if not checklist_items and all_text_lines:
                    # Filter out very short lines (likely headers) and use the rest
                    checklist_items = [line for line in all_text_lines if len(line) > 10]

                return {
                    'checklist_items': checklist_items,
                    'special_instructions': '\n'.join(special_instructions),
                    'safety_notes': '\n'.join(safety_notes)
                }

            except Exception as e:
                messagebox.showerror("Error", f"Failed to parse Word document:\n{str(e)}\n\nTraceback:\n{traceback.format_exc()}")
                return None

        def upload_word_document():
            """Open file dialog and import Word document content"""
            if not DOCX_AVAILABLE:
                messagebox.showerror("Error",
                    "python-docx library is not installed.\n\n"
                    "Please install it using: pip install python-docx\n"
                    "or run: pip install -r requirements.txt")
                return

            file_path = filedialog.askopenfilename(
                title="Select Word Document",
                filetypes=[
                    ("Word Documents", "*.docx"),
                    ("All Files", "*.*")
                ]
            )

            if not file_path:
                return

            # Parse the document
            parsed_data = parse_word_document(file_path)

            if not parsed_data:
                return

            # Confirm before auto-filling
            checklist_count = len(parsed_data['checklist_items'])
            has_instructions = bool(parsed_data['special_instructions'])
            has_safety = bool(parsed_data['safety_notes'])

            msg = f"Found in Word document:\n"
            msg += f"   {checklist_count} checklist items\n"
            msg += f"   Special Instructions: {'Yes' if has_instructions else 'No'}\n"
            msg += f"   Safety Notes: {'Yes' if has_safety else 'No'}\n\n"
            msg += "This will replace current form content.\n\nContinue?"

            if not messagebox.askyesno("Import Word Document", msg):
                return

            # Clear existing checklist
            checklist_listbox.delete(0, 'end')

            # Add checklist items
            for i, item in enumerate(parsed_data['checklist_items'], 1):
                checklist_listbox.insert('end', f"{i}. {item}")

            # Set special instructions
            if parsed_data['special_instructions']:
                special_instructions_text.delete('1.0', 'end')
                special_instructions_text.insert('1.0', parsed_data['special_instructions'])

            # Set safety notes
            if parsed_data['safety_notes']:
                safety_notes_text.delete('1.0', 'end')
                safety_notes_text.insert('1.0', parsed_data['safety_notes'])

            messagebox.showinfo("Success",
                f"Word document imported successfully!\n\n"
                f"Added {checklist_count} checklist items.\n"
                f"Review and adjust as needed before saving.")

        # NOW CREATE ALL BUTTONS - AFTER ALL FUNCTIONS ARE DEFINED
        ttk.Button(controls_subframe, text="Add Step", command=add_checklist_step).pack(side='left', padx=5)
        ttk.Button(controls_subframe, text="Remove Step", command=remove_checklist_step).pack(side='left', padx=5)
        ttk.Button(controls_subframe, text="Load Default Template", command=load_default_template).pack(side='left', padx=5)
        ttk.Button(controls_subframe, text="Upload Word Doc", command=upload_word_document).pack(side='left', padx=5)
        ttk.Button(controls_subframe, text="Move Up", command=move_step_up).pack(side='left', padx=5)
        ttk.Button(controls_subframe, text="Move Down", command=move_step_down).pack(side='left', padx=5)

        ttk.Button(edit_frame, text="Update Step", command=update_selected_step).pack(side='right', padx=5)

        # Bind listbox selection
        checklist_listbox.bind('<<ListboxSelect>>', on_step_select)

        # Load default template initially
        try:
            load_default_template()
        except Exception as e:
            print(f"Warning: Could not load default template on dialog open: {e}")
            # Continue anyway - user can add steps manually

        # Save and Cancel buttons
        button_frame = ttk.Frame(dialog)
        button_frame.pack(side='bottom', fill='x', padx=10, pady=10)

        ttk.Button(button_frame, text="Save Template", command=save_template).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side='right', padx=5)

    def load_pm_templates(self):
        """Load PM templates into the tree"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT pt.bfm_equipment_no, pt.template_name, pt.pm_type, 
                    pt.checklist_items, pt.estimated_hours, pt.updated_date
                FROM pm_templates pt
                ORDER BY pt.bfm_equipment_no, pt.template_name
            ''')
        
            # Clear existing items
            for item in self.templates_tree.get_children():
                self.templates_tree.delete(item)
        
            # Add templates
            for template in cursor.fetchall():
                bfm_no, name, pm_type, checklist_json, est_hours, updated = template
            
                # Count checklist items
                try:
                    checklist_items = json.loads(checklist_json) if checklist_json else []
                    step_count = len(checklist_items)
                except:
                    step_count = 0
            
                self.templates_tree.insert('', 'end', values=(
                    bfm_no, name, pm_type, step_count, f"{est_hours:.1f}h", str(updated)[:10] if updated else "N/A"
                ))
            
        except Exception as e:
            print(f"Error loading PM templates: {e}")

    def filter_template_list(self, *args):
        """Filter template list based on search term"""
        search_term = self.template_search_var.get().lower()
    
        try:
            cursor = self.conn.cursor()
            if search_term:
                cursor.execute('''
                    SELECT pt.bfm_equipment_no, pt.template_name, pt.pm_type, 
                        pt.checklist_items, pt.estimated_hours, pt.updated_date
                    FROM pm_templates pt
                    WHERE LOWER(pt.bfm_equipment_no) LIKE %s 
                    OR LOWER(pt.template_name) LIKE %s
                    ORDER BY pt.bfm_equipment_no, pt.template_name
                ''', (f'%{search_term}%', f'%{search_term}%'))
            else:
                cursor.execute('''
                    SELECT pt.bfm_equipment_no, pt.template_name, pt.pm_type, 
                        pt.checklist_items, pt.estimated_hours, pt.updated_date
                    FROM pm_templates pt
                    ORDER BY pt.bfm_equipment_no, pt.template_name
                ''')
        
            # Clear and repopulate
            for item in self.templates_tree.get_children():
                self.templates_tree.delete(item)
        
            for template in cursor.fetchall():
                bfm_no, name, pm_type, checklist_json, est_hours, updated = template
            
                try:
                    checklist_items = json.loads(checklist_json) if checklist_json else []
                    step_count = len(checklist_items)
                except:
                    step_count = 0
            
                self.templates_tree.insert('', 'end', values=(
                    bfm_no, name, pm_type, step_count, f"{est_hours:.1f}h", str(updated)[:10] if updated else "N/A"
                ))
    
        except Exception as e:
            print(f"Error filtering templates: {e}")

    def load_equipment_for_pm_templates(self):
        """Load equipment list for PM templates tab"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT bfm_equipment_no, sap_material_no, description, location
                FROM equipment
                ORDER BY bfm_equipment_no
            ''')

            # Clear existing items
            for item in self.equipment_pm_tree.get_children():
                self.equipment_pm_tree.delete(item)

            # Add equipment
            for equipment in cursor.fetchall():
                bfm_no, sap_no, description, location = equipment
                self.equipment_pm_tree.insert('', 'end', values=(
                    bfm_no or '',
                    sap_no or '',
                    description or '',
                    location or ''
                ))

        except Exception as e:
            print(f"Error loading equipment for PM templates: {e}")

    def filter_equipment_for_pm_templates(self, *args):
        """Filter equipment list based on search term"""
        search_term = self.equipment_search_var.get().lower()

        try:
            cursor = self.conn.cursor()
            if search_term:
                cursor.execute('''
                    SELECT bfm_equipment_no, sap_material_no, description, location
                    FROM equipment
                    WHERE LOWER(bfm_equipment_no) LIKE %s
                    OR LOWER(sap_material_no) LIKE %s
                    OR LOWER(description) LIKE %s
                    ORDER BY bfm_equipment_no
                ''', (f'%{search_term}%', f'%{search_term}%', f'%{search_term}%'))
            else:
                cursor.execute('''
                    SELECT bfm_equipment_no, sap_material_no, description, location
                    FROM equipment
                    ORDER BY bfm_equipment_no
                ''')

            # Clear and repopulate
            for item in self.equipment_pm_tree.get_children():
                self.equipment_pm_tree.delete(item)

            for equipment in cursor.fetchall():
                bfm_no, sap_no, description, location = equipment
                self.equipment_pm_tree.insert('', 'end', values=(
                    bfm_no or '',
                    sap_no or '',
                    description or '',
                    location or ''
                ))

        except Exception as e:
            print(f"Error filtering equipment: {e}")

    def show_equipment_pm_templates(self, event):
        """Show PM templates for selected equipment when double-clicked"""
        selected = self.equipment_pm_tree.selection()
        if not selected:
            return

        # Get selected equipment BFM number
        item = self.equipment_pm_tree.item(selected[0])
        bfm_no = str(item['values'][0])

        if not bfm_no:
            return

        try:
            # Load templates for this equipment
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT pt.bfm_equipment_no, pt.template_name, pt.pm_type,
                    pt.checklist_items, pt.estimated_hours, pt.updated_date
                FROM pm_templates pt
                WHERE pt.bfm_equipment_no = %s
                ORDER BY pt.template_name
            ''', (bfm_no,))

            # Clear templates tree
            for item in self.templates_tree.get_children():
                self.templates_tree.delete(item)

            # Add templates for selected equipment
            templates = cursor.fetchall()

            if not templates:
                # No custom templates - check what PM types are enabled for this equipment
                cursor.execute('''
                    SELECT weekly_pm, monthly_pm, six_month_pm, annual_pm
                    FROM equipment
                    WHERE bfm_equipment_no = %s
                ''', (bfm_no,))
                pm_flags = cursor.fetchone()

                if pm_flags:
                    weekly_enabled, monthly_enabled, six_month_enabled, annual_enabled = pm_flags
                    enabled_pm_types = []

                    if weekly_enabled:
                        enabled_pm_types.append('Weekly')
                    if monthly_enabled:
                        enabled_pm_types.append('Monthly')
                    if six_month_enabled:
                        enabled_pm_types.append('Six Month')
                    if annual_enabled:
                        enabled_pm_types.append('Annual')

                    if enabled_pm_types:
                        # Get default checklist count
                        cursor.execute('SELECT COUNT(*) FROM default_pm_checklist WHERE is_active = TRUE')
                        default_count = cursor.fetchone()[0]

                        if default_count > 0:
                            # Show default templates only for enabled PM types
                            for pm_type in enabled_pm_types:
                                self.templates_tree.insert('', 'end', values=(
                                    bfm_no,
                                    f"Default - {pm_type} PM",
                                    pm_type,
                                    default_count,
                                    "2.0h",
                                    "Default"
                                ))

                            messagebox.showinfo("Default Templates",
                                f"Showing default PM templates for equipment {bfm_no}\n\n"
                                f"Enabled PM types: {', '.join(enabled_pm_types)}\n\n"
                                f"These are standard templates. You can preview and customize them\n"
                                f"by clicking 'Customize This Template' in the preview window.")
                        else:
                            messagebox.showinfo("No Templates",
                                f"No default PM checklist items available.\n"
                                f"Please create custom templates for this equipment.")
                    else:
                        messagebox.showinfo("No PM Types Enabled",
                            f"Equipment {bfm_no} has no PM types enabled.\n\n"
                            f"Please enable PM types in the Equipment Management section.")
                else:
                    messagebox.showinfo("Equipment Not Found",
                        f"Equipment {bfm_no} not found in database.")
                return

            for template in templates:
                bfm, name, pm_type, checklist_json, est_hours, updated = template

                # Count checklist items
                try:
                    checklist_items = json.loads(checklist_json) if checklist_json else []
                    step_count = len(checklist_items)
                except:
                    step_count = 0

                self.templates_tree.insert('', 'end', values=(
                    bfm, name, pm_type, step_count,
                    f"{est_hours:.1f}h",
                    str(updated)[:10] if updated else "N/A"
                ))

            # Update the label to show we're viewing templates for specific equipment
            messagebox.showinfo("Templates Loaded",
                f"Showing {len(templates)} custom PM template(s) for equipment {bfm_no}")

        except Exception as e:
            print(f"Error showing equipment PM templates: {e}")
            messagebox.showerror("Error", f"Failed to load templates: {str(e)}")

    def preview_pm_template(self):
        """Preview selected PM template"""
        selected = self.templates_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a template to preview")
            return

        item = self.templates_tree.item(selected[0])
        bfm_no = str(item['values'][0])
        template_name = item['values'][1]
        pm_type = item['values'][2]

        cursor = self.conn.cursor()

        # Check if this is a default template
        is_default = template_name.startswith("Default - ")

        if is_default:
            # Load default template data
            cursor.execute('''
                SELECT description, sap_material_no, location
                FROM equipment
                WHERE bfm_equipment_no = %s
            ''', (bfm_no,))
            equipment_data = cursor.fetchone()

            if not equipment_data:
                messagebox.showerror("Error", "Equipment not found")
                return

            # Load default checklist items
            cursor.execute('''
                SELECT description
                FROM default_pm_checklist
                WHERE is_active = TRUE
                ORDER BY step_number
            ''')
            checklist_rows = cursor.fetchall()
            checklist_items = [row[0] for row in checklist_rows]

            equipment_desc = equipment_data[0]
            special_instructions = None
            safety_notes = None
            estimated_hours = 2.0
        else:
            # Load custom template data - MUST filter by pm_type to get correct template
            cursor.execute('''
                SELECT pt.*, e.description, e.sap_material_no, e.location
                FROM pm_templates pt
                LEFT JOIN equipment e ON pt.bfm_equipment_no = e.bfm_equipment_no
                WHERE pt.bfm_equipment_no = %s AND pt.template_name = %s AND pt.pm_type = %s
            ''', (bfm_no, template_name, pm_type))

            template_data = cursor.fetchone()
            if not template_data:
                messagebox.showerror("Error", "Template not found")
                return

            equipment_desc = template_data[9]
            checklist_items = json.loads(template_data[4]) if template_data[4] else []
            special_instructions = template_data[5]
            safety_notes = template_data[6]
            estimated_hours = template_data[7]

        # Create preview dialog
        preview_dialog = tk.Toplevel(self.root)
        preview_dialog.title(f"PM Template Preview - {bfm_no}")
        preview_dialog.geometry("700x650")
        preview_dialog.transient(self.root)
        preview_dialog.grab_set()

        # Template info
        info_frame = ttk.LabelFrame(preview_dialog, text="Template Information", padding=10)
        info_frame.pack(fill='x', padx=10, pady=5)

        info_text = f"Equipment: {bfm_no} - {equipment_desc or 'N/A'}\n"
        info_text += f"Template: {template_name}\n"
        info_text += f"PM Type: {pm_type}\n"
        info_text += f"Estimated Hours: {estimated_hours:.1f}h"

        if is_default:
            info_text += "\n\nType: DEFAULT TEMPLATE (can be customized)"

        ttk.Label(info_frame, text=info_text, font=('Arial', 10)).pack(anchor='w')

        # Checklist preview
        checklist_frame = ttk.LabelFrame(preview_dialog, text="PM Checklist", padding=10)
        checklist_frame.pack(fill='both', expand=True, padx=10, pady=5)

        checklist_text = tk.Text(checklist_frame, wrap='word', font=('Arial', 10))
        scrollbar = ttk.Scrollbar(checklist_frame, orient='vertical', command=checklist_text.yview)
        checklist_text.configure(yscrollcommand=scrollbar.set)

        # Format checklist content
        try:
            content = "PM CHECKLIST:\n" + "="*50 + "\n\n"

            for i, item in enumerate(checklist_items, 1):
                content += f"{i:2d}. {item}\n"

            if special_instructions:
                content += f"\n\nSPECIAL INSTRUCTIONS:\n{special_instructions}\n"

            if safety_notes:
                content += f"\n\nSAFETY NOTES:\n{safety_notes}\n"

            checklist_text.insert('1.0', content)
            checklist_text.config(state='disabled')

        except Exception as e:
            checklist_text.insert('1.0', f"Error loading template: {str(e)}")
            checklist_text.config(state='disabled')

        checklist_text.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')

        # Buttons
        button_frame = ttk.Frame(preview_dialog)
        button_frame.pack(side='bottom', fill='x', padx=10, pady=10)

        ttk.Button(button_frame, text="Close", command=preview_dialog.destroy).pack(side='right', padx=5)

        # If default template, add "Customize" button
        if is_default:
            def customize_default():
                preview_dialog.destroy()
                self.create_custom_from_default(bfm_no, pm_type, checklist_items)

            ttk.Button(button_frame, text="Customize This Template",
                      command=customize_default, style='Accent.TButton').pack(side='right', padx=5)

    def create_custom_from_default(self, bfm_no, pm_type, default_checklist_items):
        """Create a custom template based on default checklist for specific equipment"""
        dialog = tk.Toplevel(self.root)
        dialog.title(f"Customize PM Template for {bfm_no}")
        dialog.geometry("800x750")
        dialog.transient(self.root)
        dialog.grab_set()

        # Get equipment info
        cursor = self.conn.cursor()
        cursor.execute('SELECT description FROM equipment WHERE bfm_equipment_no = %s', (bfm_no,))
        equipment_info = cursor.fetchone()
        equipment_desc = equipment_info[0] if equipment_info else "Unknown"

        # Header with equipment info
        header_frame = ttk.LabelFrame(dialog, text="Template Information", padding=10)
        header_frame.pack(fill='x', padx=10, pady=5)

        info_text = f"Equipment: {bfm_no} - {equipment_desc}\nPM Type: {pm_type}"
        ttk.Label(header_frame, text=info_text, font=('Arial', 10, 'bold')).pack(anchor='w', pady=5)

        # Template name
        name_frame = ttk.Frame(header_frame)
        name_frame.pack(fill='x', pady=5)
        ttk.Label(name_frame, text="Template Name:").pack(side='left', padx=5)
        template_name_var = tk.StringVar(value=f"Custom {pm_type} PM")
        ttk.Entry(name_frame, textvariable=template_name_var, width=40).pack(side='left', padx=5)

        # Estimated hours
        hours_frame = ttk.Frame(header_frame)
        hours_frame.pack(fill='x', pady=5)
        ttk.Label(hours_frame, text="Estimated Hours:").pack(side='left', padx=5)
        est_hours_var = tk.StringVar(value="2.0")
        ttk.Entry(hours_frame, textvariable=est_hours_var, width=10).pack(side='left', padx=5)

        # Checklist section
        checklist_frame = ttk.LabelFrame(dialog, text="Customize PM Checklist", padding=10)
        checklist_frame.pack(fill='both', expand=True, padx=10, pady=5)

        # Controls for checklist
        controls_frame = ttk.Frame(checklist_frame)
        controls_frame.pack(fill='x', pady=5)

        # Listbox with default items pre-populated
        list_frame = ttk.Frame(checklist_frame)
        list_frame.pack(fill='both', expand=True, pady=5)

        checklist_listbox = tk.Listbox(list_frame, height=15, font=('Arial', 9))
        list_scrollbar = ttk.Scrollbar(list_frame, orient='vertical', command=checklist_listbox.yview)
        checklist_listbox.configure(yscrollcommand=list_scrollbar.set)

        checklist_listbox.pack(side='left', fill='both', expand=True)
        list_scrollbar.pack(side='right', fill='y')

        # Pre-populate with default items
        for item in default_checklist_items:
            checklist_listbox.insert('end', item)

        # Entry for new items
        entry_frame = ttk.Frame(checklist_frame)
        entry_frame.pack(fill='x', pady=5)
        ttk.Label(entry_frame, text="Add/Edit Item:").pack(side='left', padx=5)
        item_entry = ttk.Entry(entry_frame, width=60)
        item_entry.pack(side='left', padx=5, fill='x', expand=True)

        def add_item():
            text = item_entry.get().strip()
            if text:
                checklist_listbox.insert('end', text)
                item_entry.delete(0, 'end')

        def edit_item():
            selection = checklist_listbox.curselection()
            if selection:
                text = item_entry.get().strip()
                if text:
                    checklist_listbox.delete(selection[0])
                    checklist_listbox.insert(selection[0], text)
                    item_entry.delete(0, 'end')

        def delete_item():
            selection = checklist_listbox.curselection()
            if selection:
                checklist_listbox.delete(selection[0])

        def move_up():
            selection = checklist_listbox.curselection()
            if selection and selection[0] > 0:
                idx = selection[0]
                text = checklist_listbox.get(idx)
                checklist_listbox.delete(idx)
                checklist_listbox.insert(idx-1, text)
                checklist_listbox.selection_set(idx-1)

        def move_down():
            selection = checklist_listbox.curselection()
            if selection and selection[0] < checklist_listbox.size()-1:
                idx = selection[0]
                text = checklist_listbox.get(idx)
                checklist_listbox.delete(idx)
                checklist_listbox.insert(idx+1, text)
                checklist_listbox.selection_set(idx+1)

        def on_select(event):
            selection = checklist_listbox.curselection()
            if selection:
                item_entry.delete(0, 'end')
                item_entry.insert(0, checklist_listbox.get(selection[0]))

        checklist_listbox.bind('<<ListboxSelect>>', on_select)

        # Buttons for list management
        btn_frame = ttk.Frame(checklist_frame)
        btn_frame.pack(fill='x', pady=5)

        ttk.Button(btn_frame, text="Add Item", command=add_item).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="Edit Item", command=edit_item).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="Delete Item", command=delete_item).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="Move Up", command=move_up).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="Move Down", command=move_down).pack(side='left', padx=2)

        # Special instructions
        inst_frame = ttk.LabelFrame(dialog, text="Special Instructions", padding=10)
        inst_frame.pack(fill='x', padx=10, pady=5)
        special_instructions_text = tk.Text(inst_frame, height=3, font=('Arial', 9), wrap='word')
        special_instructions_text.pack(fill='both', expand=True)

        # Safety notes
        safety_frame = ttk.LabelFrame(dialog, text="Safety Notes", padding=10)
        safety_frame.pack(fill='x', padx=10, pady=5)
        safety_notes_text = tk.Text(safety_frame, height=3, font=('Arial', 9), wrap='word')
        safety_notes_text.pack(fill='both', expand=True)

        # Save button
        def save_custom_template():
            template_name = template_name_var.get().strip()
            if not template_name:
                messagebox.showerror("Error", "Please enter a template name")
                return

            # Collect checklist items
            checklist_items = []
            for i in range(checklist_listbox.size()):
                step_text = checklist_listbox.get(i)
                # Strip number prefix if present (e.g., "1. Check oil" -> "Check oil")
                step_content = '. '.join(step_text.split('. ')[1:]) if '. ' in step_text else step_text
                checklist_items.append(step_content)

            if not checklist_items:
                messagebox.showerror("Error", "Please add at least one checklist item")
                return

            try:
                est_hours = float(est_hours_var.get() or 2.0)
            except ValueError:
                messagebox.showerror("Error", "Invalid estimated hours value")
                return

            try:
                cursor = self.conn.cursor()

                # Check if template already exists - MUST filter by pm_type
                cursor.execute('''
                    SELECT id FROM pm_templates
                    WHERE bfm_equipment_no = %s AND template_name = %s AND pm_type = %s
                ''', (bfm_no, template_name, pm_type))

                if cursor.fetchone():
                    if not messagebox.askyesno("Template Exists",
                        f"A template named '{template_name}' already exists for {bfm_no} ({pm_type}).\n\nOverwrite it?"):
                        return

                    # Update existing - MUST filter by pm_type to update correct template
                    cursor.execute('''
                        UPDATE pm_templates
                        SET checklist_items = %s,
                            special_instructions = %s, safety_notes = %s,
                            estimated_hours = %s, updated_date = CURRENT_TIMESTAMP
                        WHERE bfm_equipment_no = %s AND template_name = %s AND pm_type = %s
                    ''', (
                        json.dumps(checklist_items),
                        special_instructions_text.get('1.0', 'end-1c'),
                        safety_notes_text.get('1.0', 'end-1c'),
                        est_hours,
                        bfm_no,
                        template_name,
                        pm_type
                    ))
                else:
                    # Insert new
                    cursor.execute('''
                        INSERT INTO pm_templates
                        (bfm_equipment_no, template_name, pm_type, checklist_items,
                        special_instructions, safety_notes, estimated_hours)
                        VALUES (%s, %s, %s, %s, %s, %s, %s)
                    ''', (
                        bfm_no,
                        template_name,
                        pm_type,
                        json.dumps(checklist_items),
                        special_instructions_text.get('1.0', 'end-1c'),
                        safety_notes_text.get('1.0', 'end-1c'),
                        est_hours
                    ))

                self.conn.commit()
                messagebox.showinfo("Success", f"Custom PM template saved for {bfm_no}")
                dialog.destroy()

                # Reload templates if we're on the PM Templates tab
                if hasattr(self, 'templates_tree'):
                    self.load_pm_templates()

            except Exception as e:
                print(f"Error saving custom template: {e}")
                messagebox.showerror("Error", f"Failed to save template: {str(e)}")

        button_frame = ttk.Frame(dialog)
        button_frame.pack(side='bottom', fill='x', padx=10, pady=10)

        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side='right', padx=5)
        ttk.Button(button_frame, text="Save Custom Template",
                  command=save_custom_template, style='Accent.TButton').pack(side='right', padx=5)

    def delete_pm_template(self):
        """Delete selected PM template"""
        selected = self.templates_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a template to delete")
            return

        item = self.templates_tree.item(selected[0])
        bfm_no = str(item['values'][0])
        template_name = item['values'][1]
        pm_type = item['values'][2]

        result = messagebox.askyesno("Confirm Delete",
                                f"Delete PM template '{template_name}' for {bfm_no}?\n"
                                f"PM Type: {pm_type}\n\n"
                                f"This action cannot be undone.")

        if result:
            try:
                cursor = self.conn.cursor()
                # MUST filter by pm_type to delete correct template
                cursor.execute('''
                    DELETE FROM pm_templates
                    WHERE bfm_equipment_no = %s AND template_name = %s AND pm_type = %s
                ''', (bfm_no, template_name, pm_type))
            
                self.conn.commit()
                messagebox.showinfo("Success", "Template deleted successfully!")
                self.load_pm_templates()
            
            except Exception as e:
                messagebox.showerror("Error", f"Failed to delete template: {str(e)}")

    def export_custom_template_pdf(self):
        """Export custom template as PDF form"""
        selected = self.templates_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a template to export")
            return

        item = self.templates_tree.item(selected[0])
        bfm_no = str(item['values'][0]).strip()
        template_name = str(item['values'][1]).strip()
        pm_type = item['values'][2]

        cursor = self.conn.cursor()

        # Check if this is a default template
        is_default = template_name.startswith("Default - ")

        if is_default:
            # Load default template data
            cursor.execute('''
                SELECT sap_material_no, description, tool_id_drawing_no, location
                FROM equipment
                WHERE bfm_equipment_no = %s
            ''', (bfm_no,))
            equipment_data = cursor.fetchone()

            if not equipment_data:
                messagebox.showerror("Error", "Equipment not found")
                return

            # Load default checklist items
            cursor.execute('''
                SELECT description
                FROM default_pm_checklist
                WHERE is_active = TRUE
                ORDER BY step_number
            ''')
            checklist_rows = cursor.fetchall()
            checklist_items = [row[0] for row in checklist_rows]

            # Construct template_data tuple to match expected format
            template_data = (
                None,  # template_id
                bfm_no,  # bfm_equipment_no
                template_name,  # template_name
                pm_type,  # pm_type
                json.dumps(checklist_items),  # checklist_items (JSON)
                None,  # special_instructions
                None,  # safety_notes
                2.0,  # estimated_hours
                None,  # created_date
                None,  # updated_date
                equipment_data[0],  # sap_material_no
                equipment_data[1],  # description
                equipment_data[2],  # tool_id_drawing_no
                equipment_data[3]   # location
            )
        else:
            # Get template and equipment data - MUST filter by pm_type
            cursor.execute('''
                SELECT pt.*, e.sap_material_no, e.description, e.tool_id_drawing_no, e.location
                FROM pm_templates pt
                LEFT JOIN equipment e ON pt.bfm_equipment_no = e.bfm_equipment_no
                WHERE pt.bfm_equipment_no = %s AND pt.template_name = %s AND pt.pm_type = %s
            ''', (bfm_no, template_name, pm_type))

            template_data = cursor.fetchone()
            if not template_data:
                messagebox.showerror("Error", f"Template not found for BFM: {bfm_no}, Name: {template_name}, PM Type: {pm_type}\n\nPlease check that the template exists in the database.")
                return

        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"PM_Template_{bfm_no}_{template_name.replace(' ', '_')}_{timestamp}.pdf"

            # Create custom PDF using the template data
            self.create_custom_pm_template_pdf(filename, template_data)

            messagebox.showinfo("Success", f"PM template exported to: {filename}")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to export template: {str(e)}")

    def create_custom_pm_template_pdf(self, filename, template_data):
        """Create PDF with custom PM template"""
        try:
            from reportlab.lib.pagesizes import letter
            from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib.units import inch
            from reportlab.lib import colors
        
            doc = SimpleDocTemplate(filename, pagesize=letter,
                                rightMargin=36, leftMargin=36,
                                topMargin=36, bottomMargin=36)
        
            styles = getSampleStyleSheet()
            story = []
        
            # Extract template data
            (template_id, bfm_no, template_name, pm_type, checklist_json,
            special_instructions, safety_notes, estimated_hours, created_date, updated_date,
            sap_no, description, tool_id, location) = template_data
        
            # Custom styles
            cell_style = ParagraphStyle(
                'CellStyle',
                parent=styles['Normal'],
                fontSize=8,
                leading=10,
                wordWrap='LTR'
            )
        
            header_cell_style = ParagraphStyle(
                'HeaderCellStyle',
                parent=styles['Normal'],
                fontSize=9,
                fontName='Helvetica-Bold',
                leading=11,
                wordWrap='LTR'
            )
        
            company_style = ParagraphStyle(
                'CompanyStyle',
                parent=styles['Heading1'],
                fontSize=14,
                fontName='Helvetica-Bold',
                alignment=1,
                textColor=colors.darkblue
            )
        
            # Header
            story.append(Paragraph("AIT - BUILDING THE FUTURE OF AEROSPACE", company_style))
            story.append(Spacer(1, 15))
        
            # Equipment information table
            equipment_data = [
                [
                    Paragraph('(SAP) Material Number:', header_cell_style), 
                    Paragraph(str(sap_no or ''), cell_style), 
                    Paragraph('Tool ID / Drawing Number:', header_cell_style), 
                    Paragraph(str(tool_id or ''), cell_style)
                ],
                [
                    Paragraph('(BFM) Equipment Number:', header_cell_style), 
                    Paragraph(str(bfm_no), cell_style), 
                    Paragraph('Description of Equipment:', header_cell_style), 
                    Paragraph(str(description or ''), cell_style)
                ],
                [
                    Paragraph('Custom Template:', header_cell_style), 
                    Paragraph(str(template_name), cell_style), 
                    Paragraph('Location of Equipment:', header_cell_style), 
                    Paragraph(str(location or ''), cell_style)
                ],
                [
                    Paragraph('Maintenance Technician:', header_cell_style), 
                    Paragraph('', cell_style), 
                    Paragraph('PM Cycle:', header_cell_style), 
                    Paragraph(str(pm_type), cell_style)
                ],
                [
                    Paragraph('Estimated Hours:', header_cell_style), 
                    Paragraph(f'{estimated_hours:.1f}h', cell_style), 
                    Paragraph('Date of Current PM:', header_cell_style), 
                    Paragraph('', cell_style)
                ]
            ]
        
            if safety_notes:
                equipment_data.append([
                    Paragraph(f'SAFETY: {safety_notes}', cell_style), 
                    '', '', ''
                ])
        
            equipment_data.append([
                Paragraph(f'Printed: {datetime.now().strftime("%m/%d/%Y")}', cell_style), 
                '', '', ''
            ])
        
            equipment_table = Table(equipment_data, colWidths=[1.8*inch, 1.7*inch, 1.8*inch, 1.7*inch])
            equipment_table.setStyle(TableStyle([
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ('LEFTPADDING', (0, 0), (-1, -1), 3),
                ('RIGHTPADDING', (0, 0), (-1, -1), 3),
                ('TOPPADDING', (0, 0), (-1, -1), 3),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
                ('SPAN', (0, -2), (-1, -2)),  # Safety spans all columns
                ('SPAN', (0, -1), (-1, -1)),  # Printed date spans all columns
            ]))
        
            story.append(equipment_table)
            story.append(Spacer(1, 15))
        
            # Custom checklist table
            checklist_data = [
                [
                    Paragraph('', header_cell_style), 
                    Paragraph('CUSTOM PM CHECKLIST:', header_cell_style), 
                    Paragraph('', header_cell_style), 
                    Paragraph('Completed', header_cell_style), 
                    Paragraph('Labor Time', header_cell_style)
                ]
            ]
        
            # Add custom checklist items
            try:
                checklist_items = json.loads(checklist_json) if checklist_json else []
            except:
                checklist_items = []
        
            if not checklist_items:
                checklist_items = ["No custom checklist defined - using default steps"]
        
            for idx, item in enumerate(checklist_items, 1):
                checklist_data.append([
                    Paragraph(str(idx), cell_style), 
                    Paragraph(item, cell_style), 
                    Paragraph('', cell_style), 
                    Paragraph('Yes', cell_style), 
                    Paragraph('hours    minutes', cell_style)
                ])
        
            checklist_table = Table(checklist_data, colWidths=[0.3*inch, 4.2*inch, 0.4*inch, 0.7*inch, 1.4*inch])
            checklist_table.setStyle(TableStyle([
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey),
                ('LEFTPADDING', (0, 0), (-1, -1), 2),
                ('RIGHTPADDING', (0, 0), (-1, -1), 2),
                ('TOPPADDING', (0, 0), (-1, -1), 2),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
            ]))
        
            story.append(checklist_table)
            story.append(Spacer(1, 15))
        
            # Special instructions section
            if special_instructions and special_instructions.strip():
                instructions_data = [
                    [Paragraph('SPECIAL INSTRUCTIONS:', header_cell_style)],
                    [Paragraph(special_instructions, cell_style)]
                ]
            
                instructions_table = Table(instructions_data, colWidths=[7*inch])
                instructions_table.setStyle(TableStyle([
                    ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                    ('FONTSIZE', (0, 0), (-1, -1), 8),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black),
                    ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                    ('BACKGROUND', (0, 0), (0, 0), colors.lightgrey),
                    ('LEFTPADDING', (0, 0), (-1, -1), 3),
                    ('RIGHTPADDING', (0, 0), (-1, -1), 3),
                    ('TOPPADDING', (0, 0), (-1, -1), 3),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
                ]))
            
                story.append(instructions_table)
                story.append(Spacer(1, 15))
        
            # Completion section
            completion_data = [
                [
                    Paragraph('Notes from Technician:', header_cell_style), 
                    Paragraph('', cell_style), 
                    Paragraph('Next Annual PM Date:', header_cell_style)
                ],
                [
                    Paragraph('', cell_style), 
                    Paragraph('', cell_style), 
                    Paragraph('', cell_style)
                ],
                [
                    Paragraph('All Data Entered Into System:', header_cell_style), 
                    Paragraph('', cell_style), 
                    Paragraph('Total Time', header_cell_style)
                ],
                [
                    Paragraph('Document Name', header_cell_style), 
                    Paragraph('Revision', header_cell_style), 
                    Paragraph('', cell_style)
                ],
                [
                    Paragraph(f'Custom_PM_Template_{template_name}', cell_style), 
                    Paragraph('A1', cell_style), 
                    Paragraph('', cell_style)
                ]
            ]
        
            completion_table = Table(completion_data, colWidths=[2.8*inch, 2.2*inch, 2*inch])
            completion_table.setStyle(TableStyle([
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ('LEFTPADDING', (0, 0), (-1, -1), 3),
                ('RIGHTPADDING', (0, 0), (-1, -1), 3),
                ('TOPPADDING', (0, 0), (-1, -1), 3),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
            ]))
        
            story.append(completion_table)
        
            # Build PDF
            doc.build(story)
        
        except Exception as e:
            print(f"Error creating custom PM template PDF: {e}")
            raise

    # Additional methods to integrate with existing PM completion system

    def get_pm_template_for_equipment(self, bfm_no, pm_type):
        """Get custom PM template for specific equipment and PM type"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT checklist_items, special_instructions, safety_notes, estimated_hours
                FROM pm_templates 
                WHERE bfm_equipment_no = %s AND pm_type = %s
                ORDER BY updated_date DESC LIMIT 1
            ''', (bfm_no, pm_type))
        
            result = cursor.fetchone()
            if result:
                checklist_json, special_instructions, safety_notes, estimated_hours = result
                try:
                    checklist_items = json.loads(checklist_json) if checklist_json else []
                    return {
                        'checklist_items': checklist_items,
                        'special_instructions': special_instructions,
                        'safety_notes': safety_notes,
                        'estimated_hours': estimated_hours
                    }
                except:
                    return None
            return None
        
        except Exception as e:
            print(f"Error getting PM template: {e}")
            return None

    def update_pm_completion_form_with_template(self):
        """Update PM completion form when equipment is selected

        ENHANCED: Auto-populate PM type AND PM Due Date from weekly_pm_schedules
        This prevents errors where wrong PM type is selected (e.g., Monthly logged as Annual)
        """
        bfm_no = self.completion_bfm_var.get().strip()
        pm_type = self.pm_type_var.get()

        if bfm_no:
            # CRITICAL FIX: Auto-populate PM type from schedule if not already selected
            # This prevents Monthly PMs from being logged as Annual PMs
            if not pm_type:
                try:
                    cursor = self.conn.cursor()
                    # Find the most recent scheduled PM for this equipment
                    cursor.execute('''
                        SELECT pm_type, scheduled_date, assigned_technician
                        FROM weekly_pm_schedules
                        WHERE bfm_equipment_no = %s AND status = 'Scheduled'
                        ORDER BY week_start_date DESC, scheduled_date DESC
                        LIMIT 1
                    ''', (bfm_no,))

                    schedule_result = cursor.fetchone()
                    if schedule_result:
                        scheduled_pm_type = schedule_result[0]
                        scheduled_date = schedule_result[1]
                        assigned_tech = schedule_result[2]

                        # Auto-fill PM type from schedule
                        self.pm_type_var.set(scheduled_pm_type)
                        self.pm_due_date_var.set(scheduled_date)

                        # Also pre-fill technician if available
                        if assigned_tech:
                            self.completion_tech_var.set(assigned_tech)

                        self.update_status(f"Auto-filled from schedule: {scheduled_pm_type} PM due {scheduled_date}")
                        pm_type = scheduled_pm_type
                except Exception as e:
                    print(f"Warning: Could not retrieve scheduled PM: {e}")

        if bfm_no and pm_type:
            # Auto-populate PM Due Date with scheduled_date from weekly_pm_schedules
            try:
                cursor = self.conn.cursor()
                cursor.execute('''
                    SELECT scheduled_date, week_start_date
                    FROM weekly_pm_schedules
                    WHERE bfm_equipment_no = %s AND pm_type = %s
                    ORDER BY week_start_date DESC
                    LIMIT 1
                ''', (bfm_no, pm_type))

                schedule_result = cursor.fetchone()
                if schedule_result and schedule_result[0]:
                    scheduled_date = schedule_result[0]
                    # Auto-populate PM Due Date field with the scheduled date
                    self.pm_due_date_var.set(scheduled_date)
                    self.update_status(f"PM Due Date auto-populated with scheduled date: {scheduled_date}")
            except Exception as e:
                print(f"Warning: Could not retrieve scheduled date: {e}")

            template = self.get_pm_template_for_equipment(bfm_no, pm_type)
            if template:
                # Update estimated hours
                self.labor_hours_var.set(str(int(template['estimated_hours'])))
                self.labor_minutes_var.set(str(int((template['estimated_hours'] % 1) * 60)))

                # Show template info
                self.update_status(f"Custom template found for {bfm_no} - {pm_type} PM")
            else:
                self.update_status(f"No custom template found for {bfm_no} - {pm_type} PM, using default")

    def create_equipment_pm_lookup_with_templates(self):
        """Enhanced equipment lookup that shows custom templates"""
        dialog = tk.Toplevel(self.root)
        dialog.title("Equipment PM Schedule & Templates")
        dialog.geometry("900x700")
        dialog.transient(self.root)
        dialog.grab_set()
    
        # Equipment search
        search_frame = ttk.LabelFrame(dialog, text="Equipment Search", padding=15)
        search_frame.pack(fill='x', padx=10, pady=5)
    
        ttk.Label(search_frame, text="BFM Equipment Number:", font=('Arial', 10, 'bold')).grid(row=0, column=0, sticky='w', pady=5)
    
        bfm_var = tk.StringVar()
        bfm_entry = ttk.Entry(search_frame, textvariable=bfm_var, width=20, font=('Arial', 11))
        bfm_entry.grid(row=0, column=1, padx=10, pady=5)
    
        search_btn = ttk.Button(search_frame, text="Look Up Equipment", 
                            command=lambda: self.lookup_equipment_with_templates(bfm_var.get().strip(), results_frame))
        search_btn.grid(row=0, column=2, padx=10, pady=5)
    
        # Results frame
        results_frame = ttk.LabelFrame(dialog, text="Equipment Information & Templates", padding=10)
        results_frame.pack(fill='both', expand=True, padx=10, pady=5)
    
        bfm_entry.focus_set()
        bfm_entry.bind('<Return>', lambda e: search_btn.invoke())

    def lookup_equipment_with_templates(self, bfm_no, parent_frame):
        """Lookup equipment with custom template information"""
        if not bfm_no:
            messagebox.showwarning("Warning", "Please enter a BFM Equipment Number")
            return
    
        try:
            cursor = self.conn.cursor()
        
            # Clear previous results
            for widget in parent_frame.winfo_children():
                widget.destroy()
        
            # Get equipment info
            cursor.execute('''
                SELECT sap_material_no, description, location, status
                FROM equipment 
                WHERE bfm_equipment_no = %s
            ''', (bfm_no,))
        
            equipment_data = cursor.fetchone()
            if not equipment_data:
                error_label = ttk.Label(parent_frame, 
                                    text=f"Equipment '{bfm_no}' not found in database",
                                    font=('Arial', 12, 'bold'), foreground='red')
                error_label.pack(pady=20)
                return
        
            # Equipment header
            header_text = f"Equipment: {bfm_no}\n"
            header_text += f"Description: {equipment_data[1] or 'N/A'}\n"
            header_text += f"Location: {equipment_data[2] or 'N/A'}\n"
            header_text += f"Status: {equipment_data[3] or 'Active'}"
        
            header_label = ttk.Label(parent_frame, text=header_text, font=('Arial', 10))
            header_label.pack(pady=10)
        
            # Get custom templates
            cursor.execute('''
                SELECT template_name, pm_type, checklist_items, estimated_hours, updated_date
                FROM pm_templates 
                WHERE bfm_equipment_no = %s
                ORDER BY pm_type, template_name
            ''', (bfm_no,))
        
            templates = cursor.fetchall()
        
            if templates:
                templates_frame = ttk.LabelFrame(parent_frame, text="Custom PM Templates", padding=10)
                templates_frame.pack(fill='x', pady=10)
            
                for template in templates:
                    name, pm_type, checklist_json, est_hours, updated = template
                    try:
                        checklist_items = json.loads(checklist_json) if checklist_json else []
                        step_count = len(checklist_items)
                    except:
                        step_count = 0
                
                    template_text = f"- {name} ({pm_type} PM) - {step_count} steps, {est_hours:.1f}h estimated"
                    ttk.Label(templates_frame, text=template_text, font=('Arial', 9)).pack(anchor='w')
            else:
                no_templates_label = ttk.Label(parent_frame, 
                                            text="No custom PM templates found for this equipment",
                                            font=('Arial', 10), foreground='orange')
                no_templates_label.pack(pady=10)
        
            # Regular PM schedule info (existing functionality)
            self.lookup_equipment_pm_schedule(bfm_no, parent_frame)
        
        except Exception as e:
            error_label = ttk.Label(parent_frame, 
                                text=f"Error looking up equipment: {str(e)}", 
                                font=('Arial', 10), foreground='red')
            error_label.pack(pady=20) 
    

    def _ensure_connection(self):
        """
        Validate and refresh self.conn if needed to handle NEON auto-suspend
        This method checks if the connection is still alive and gets a fresh one if not.
        """
        try:
            if hasattr(self, 'conn') and self.conn and not self.conn.closed:
                # Test if connection is still valid
                cursor = self.conn.cursor()
                cursor.execute("SELECT 1")
                cursor.fetchone()
                cursor.close()
                self.conn.commit()
                return  # Connection is good
        except (psycopg2.OperationalError, psycopg2.InterfaceError) as e:
            print(f"Connection validation failed: {e}. Refreshing connection...")
        except Exception as e:
            print(f"Unexpected error validating connection: {e}")

        # Connection is bad or doesn't exist, get a fresh one
        try:
            if hasattr(self, 'conn') and self.conn:
                try:
                    # Return old connection to pool instead of closing directly
                    db_pool.return_connection(self.conn)
                except:
                    pass

            self.conn = db_pool.get_connection()
            self.conn.autocommit = False
            print("Connection refreshed successfully")
        except Exception as e:
            print(f"ERROR: Failed to refresh connection: {e}")
            raise

    def init_users_table_before_login(self):
        """Initialize users table and create default users BEFORE login dialog"""
        conn = None
        try:
            conn = db_pool.get_connection()
            cursor = conn.cursor()

            # PERFORMANCE FIX: Check if users table already exists with correct schema
            cursor.execute("""
                SELECT EXISTS (
                    SELECT FROM information_schema.tables
                    WHERE table_schema = 'public'
                    AND table_name = 'users'
                )
            """)
            users_table_exists = cursor.fetchone()[0]

            if users_table_exists:
                # Table exists, just ensure default user exists and skip the rest
                self.create_default_parts_coordinator(cursor)
                conn.commit()
                cursor.close()
                db_pool.return_connection(conn)
                return

            # Create users table if it doesn't exist
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id SERIAL PRIMARY KEY,
                    username TEXT UNIQUE NOT NULL,
                    password_hash TEXT NOT NULL,
                    full_name TEXT NOT NULL,
                    role TEXT NOT NULL CHECK (role IN ('Manager', 'Technician', 'Parts Coordinator')),
                    email TEXT,
                    is_active BOOLEAN DEFAULT TRUE,
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    last_login TIMESTAMP,
                    created_by TEXT,
                    notes TEXT
                )
            ''')

            # Update CHECK constraint for existing databases
            try:
                cursor.execute('''
                    ALTER TABLE users
                    DROP CONSTRAINT IF EXISTS users_role_check
                ''')
                cursor.execute('''
                    ALTER TABLE users
                    ADD CONSTRAINT users_role_check
                    CHECK (role IN ('Manager', 'Technician', 'Parts Coordinator'))
                ''')
                print("CHECK: Users table constraint updated to support Parts Coordinator role")
            except Exception as e:
                print(f"Note: Users table constraint update skipped: {e}")

            # Create default parts coordinator user
            self.create_default_parts_coordinator(cursor)

            conn.commit()
            cursor.close()
            db_pool.return_connection(conn)
            print("CHECK: Users table initialized successfully")

        except Exception as e:
            if conn:
                conn.rollback()
                db_pool.return_connection(conn)
            raise e

    def create_default_parts_coordinator(self, cursor):
        """Create the default parts coordinator user if it doesn't exist"""
        try:
            # Check if apenson user already exists
            cursor.execute("SELECT id FROM users WHERE username = %s", ('apenson',))
            existing_user = cursor.fetchone()

            if not existing_user:
                # Create the parts coordinator user
                password_hash = UserManager.hash_password('apenson')
                cursor.execute('''
                    INSERT INTO users (username, password_hash, full_name, role, email, is_active, created_by, notes)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                ''', (
                    'apenson',
                    password_hash,
                    'Ashica Penson',
                    'Parts Coordinator',
                    'apenson@ait.com',
                    True,
                    'System',
                    'Default parts coordinator account - manages PM Completion and MRO Stock tabs'
                ))
                print("CHECK: Default parts coordinator user (apenson) created successfully!")
            else:
                print("CHECK: Parts coordinator user (apenson) already exists")
        except Exception as e:
            print(f"Note: Could not create default parts coordinator user: {e}")
            # Don't fail initialization if user creation fails

    def create_performance_indexes(self, cursor):
        """Create functional indexes for case-insensitive searches - PERFORMANCE OPTIMIZATION"""
        try:
            print("=" * 60)
            print("PERFORMANCE: Creating functional indexes for optimized searches...")
            print("=" * 60)

            # === Equipment Table Functional Indexes ===
            # These support the LOWER() searches in filter_equipment_list

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_equipment_sap_lower
                ON equipment(LOWER(sap_material_no))
            ''')
            print(" Created index: idx_equipment_sap_lower")

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_equipment_bfm_lower
                ON equipment(LOWER(bfm_equipment_no))
            ''')
            print(" Created index: idx_equipment_bfm_lower")

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_equipment_description_lower
                ON equipment(LOWER(description))
            ''')
            print(" Created index: idx_equipment_description_lower")

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_equipment_location_lower
                ON equipment(LOWER(location))
            ''')
            print(" Created index: idx_equipment_location_lower")

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_equipment_master_lin_lower
                ON equipment(LOWER(master_lin))
            ''')
            print(" Created index: idx_equipment_master_lin_lower")

            # === Equipment Table Standard Indexes ===
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_equipment_location
                ON equipment(location)
            ''')
            print(" Created index: idx_equipment_location")

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_equipment_status
                ON equipment(status)
            ''')
            print(" Created index: idx_equipment_status")

            # Composite index for PM cycle filters
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_equipment_pm_cycles
                ON equipment(monthly_pm, six_month_pm, annual_pm)
            ''')
            print(" Created index: idx_equipment_pm_cycles")

            # === Corrective Maintenance Table Indexes ===
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_cm_status
                ON corrective_maintenance(status)
            ''')
            print(" Created index: idx_cm_status")

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_cm_created_date
                ON corrective_maintenance(created_date)
            ''')
            print(" Created index: idx_cm_created_date")

            # Check if completion_date column exists before creating index
            cursor.execute("""
                SELECT column_name
                FROM information_schema.columns
                WHERE table_name='corrective_maintenance'
                AND column_name='completion_date'
            """)
            if cursor.fetchone():
                cursor.execute('''
                    CREATE INDEX IF NOT EXISTS idx_cm_completion_date
                    ON corrective_maintenance(completion_date)
                ''')
                print(" Created index: idx_cm_completion_date")

            # === Weekly PM Schedules Table Indexes ===
            # PERFORMANCE OPTIMIZATION: Support technician schedule queries (fix N+1 pattern)
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_weekly_pm_technician_week
                ON weekly_pm_schedules(assigned_technician, week_start_date)
            ''')
            print(" Created index: idx_weekly_pm_technician_week")

            # PERFORMANCE OPTIMIZATION: Support week selector dropdown
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_weekly_pm_week_start_desc
                ON weekly_pm_schedules(week_start_date DESC)
            ''')
            print(" Created index: idx_weekly_pm_week_start_desc")

            # === Cannot Find Assets Table Indexes ===
            # PERFORMANCE OPTIMIZATION: Support equipment filtering with exclusions
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_cannot_find_status_bfm
                ON cannot_find_assets(status, bfm_equipment_no)
            ''')
            print(" Created index: idx_cannot_find_status_bfm")

            # === Deactivated Assets Table Indexes ===
            # PERFORMANCE OPTIMIZATION: Support equipment filtering with exclusions
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_deactivated_status_bfm
                ON deactivated_assets(status, bfm_equipment_no)
            ''')
            print(" Created index: idx_deactivated_status_bfm")

            # === PM Completions Table Indexes ===
            # PERFORMANCE OPTIMIZATION: Support load_recent_completions with DESC order
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_pm_completions_date_desc
                ON pm_completions(completion_date DESC, id DESC)
            ''')
            print(" Created index: idx_pm_completions_date_desc")

            print("=" * 60)
            print(" All performance indexes created successfully!")
            print("=" * 60)

        except Exception as e:
            print(f"Warning: Could not create some performance indexes: {e}")
            # Don't fail initialization if index creation fails

    def init_database(self):
        """Initialize comprehensive CMMS database with Neon PostgreSQL and connection pooling"""
        try:
            # Connection pool is already initialized before login
            # Get a connection from the pool for initial setup
            self.conn = db_pool.get_connection()
            self.conn.autocommit = False  # Manual commit control
            cursor = self.conn.cursor()

            print("=" * 60)
            print("CHECK: Connected to Neon PostgreSQL successfully!")
            print("CHECK: Connection pool initialized for multi-user support")
            print("=" * 60)

            # PERFORMANCE FIX: Check if database is already initialized
            # This significantly speeds up startup by skipping table creation if already done
            cursor.execute("""
                SELECT EXISTS (
                    SELECT FROM information_schema.tables
                    WHERE table_schema = 'public'
                    AND table_name = 'equipment'
                )
            """)
            equipment_table_exists = cursor.fetchone()[0]

            if equipment_table_exists:
                # Verify the table has key columns we expect (weekly_pm column indicates latest schema)
                cursor.execute("""
                    SELECT column_name
                    FROM information_schema.columns
                    WHERE table_schema = 'public'
                    AND table_name = 'equipment'
                    AND column_name = 'weekly_pm'
                """)
                has_weekly_pm = cursor.fetchone() is not None

                if has_weekly_pm:
                    print(" Database already initialized with latest schema - skipping table creation")
                    # Create performance indexes (will skip if already exist)
                    self.create_performance_indexes(cursor)
                    self.conn.commit()
                    return
                else:
                    print(" Database exists but needs schema migration - running updates...")
            else:
                print(" First-time database initialization - creating tables...")

            # Equipment/Assets table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS equipment (
                    id SERIAL PRIMARY KEY,
                    sap_material_no TEXT,
                    bfm_equipment_no TEXT UNIQUE,
                    description TEXT,
                    tool_id_drawing_no TEXT,
                    location TEXT,
                    master_lin TEXT,
                    monthly_pm BOOLEAN DEFAULT FALSE,
                    six_month_pm BOOLEAN DEFAULT FALSE,
                    annual_pm BOOLEAN DEFAULT FALSE,
                    last_monthly_pm TEXT,
                    last_six_month_pm TEXT,
                    last_annual_pm TEXT,
                    next_monthly_pm TEXT,
                    next_six_month_pm TEXT,
                    next_annual_pm TEXT,
                    status TEXT DEFAULT 'Active',
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
        
            # PM Completions table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS pm_completions (
                    id SERIAL PRIMARY KEY,
                    bfm_equipment_no TEXT,
                    pm_type TEXT,
                    technician_name TEXT,
                    completion_date TEXT,
                    location TEXT,
                    labor_hours REAL,
                    labor_minutes REAL,
                    pm_due_date TEXT,
                    special_equipment TEXT,
                    notes TEXT,
                    next_annual_pm_date TEXT,
                    document_name TEXT DEFAULT 'Preventive_Maintenance_Form',
                    document_revision TEXT DEFAULT 'A2',
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (bfm_equipment_no) REFERENCES equipment (bfm_equipment_no)
                )
            ''')
        
            # Weekly PM Schedules
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS weekly_pm_schedules (
                    id SERIAL PRIMARY KEY,
                    bfm_equipment_no TEXT,
                    pm_type TEXT,
                    assigned_technician TEXT,
                    scheduled_date TEXT,
                    week_start_date TEXT,
                    week_end_date TEXT,
                    status TEXT DEFAULT 'Scheduled',
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (bfm_equipment_no) REFERENCES equipment (bfm_equipment_no)
                )
            ''')

            # SCHEMA MIGRATION: Add missing columns if they don't exist
            # This ensures existing databases are updated to the new schema
            try:
                cursor.execute('''
                    ALTER TABLE weekly_pm_schedules
                    ADD COLUMN IF NOT EXISTS pm_type TEXT
                ''')
                cursor.execute('''
                    ALTER TABLE weekly_pm_schedules
                    ADD COLUMN IF NOT EXISTS scheduled_date TEXT
                ''')
                cursor.execute('''
                    ALTER TABLE weekly_pm_schedules
                    ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'Scheduled'
                ''')
                # Migrate old schedule_type data to pm_type if needed
                cursor.execute('''
                    UPDATE weekly_pm_schedules
                    SET pm_type = schedule_type
                    WHERE pm_type IS NULL AND schedule_type IS NOT NULL
                ''')
            except Exception as e:
                print(f"Note: Schema migration skipped or already applied: {e}")
                # Continue even if columns already exist

            # SCHEMA MIGRATION: Add photo columns to equipment table
            try:
                cursor.execute('''
                    ALTER TABLE equipment
                    ADD COLUMN IF NOT EXISTS picture_1_data BYTEA
                ''')
                cursor.execute('''
                    ALTER TABLE equipment
                    ADD COLUMN IF NOT EXISTS picture_2_data BYTEA
                ''')
                print("INFO: Equipment photo columns added successfully")
            except Exception as e:
                print(f"Note: Equipment photo column migration skipped: {e}")

            # SCHEMA MIGRATION: Add weekly PM columns to equipment table
            try:
                cursor.execute('''
                    ALTER TABLE equipment
                    ADD COLUMN IF NOT EXISTS weekly_pm BOOLEAN DEFAULT FALSE
                ''')
                cursor.execute('''
                    ALTER TABLE equipment
                    ADD COLUMN IF NOT EXISTS last_weekly_pm TEXT
                ''')
                cursor.execute('''
                    ALTER TABLE equipment
                    ADD COLUMN IF NOT EXISTS next_weekly_pm TEXT
                ''')
                print("INFO: Weekly PM columns added successfully")
            except Exception as e:
                print(f"Note: Weekly PM column migration skipped: {e}")

            # Corrective Maintenance table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS corrective_maintenance (
                    id SERIAL PRIMARY KEY,
                    cm_number TEXT UNIQUE,
                    bfm_equipment_no TEXT,
                    description TEXT,
                    location TEXT,
                    reported_by TEXT,
                    reported_date TEXT,
                    priority TEXT,
                    status TEXT DEFAULT 'Open',
                    assigned_technician TEXT,
                    labor_hours REAL,
                    notes TEXT,
                    closed_date TEXT,
                    closed_by TEXT,
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (bfm_equipment_no) REFERENCES equipment (bfm_equipment_no)
                )
            ''')
        
            # CM Parts Requests table (for requesting parts during CM creation)
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS cm_parts_requests (
                    id SERIAL PRIMARY KEY,
                    cm_number TEXT NOT NULL,
                    bfm_equipment_no TEXT,
                    part_number TEXT NOT NULL,
                    model_number TEXT,
                    website TEXT,
                    requested_by TEXT,
                    requested_date TEXT,
                    notes TEXT,
                    email_sent BOOLEAN DEFAULT FALSE,
                    email_sent_at TIMESTAMP,
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (cm_number) REFERENCES corrective_maintenance (cm_number)
                )
            ''')

            # Equipment Missing Parts table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS equipment_missing_parts (
                    id SERIAL PRIMARY KEY,
                    emp_number TEXT UNIQUE,
                    bfm_equipment_no TEXT,
                    description TEXT,
                    location TEXT,
                    reported_by TEXT,
                    reported_date TEXT,
                    priority TEXT,
                    status TEXT DEFAULT 'Open',
                    assigned_technician TEXT,
                    missing_parts_description TEXT,
                    notes TEXT,
                    closed_date TEXT,
                    closed_by TEXT,
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # Drop foreign key constraint if it exists (for existing databases)
            try:
                cursor.execute('''
                    ALTER TABLE equipment_missing_parts
                    DROP CONSTRAINT IF EXISTS equipment_missing_parts_bfm_equipment_no_fkey
                ''')
                print("INFO: Removed foreign key constraint from equipment_missing_parts table")
            except Exception as e:
                print(f"Note: Foreign key constraint removal skipped: {e}")

            # Create indexes for equipment_missing_parts table for better performance
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_emp_status ON equipment_missing_parts(status)
            ''')
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_emp_technician ON equipment_missing_parts(assigned_technician)
            ''')
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_emp_priority ON equipment_missing_parts(priority)
            ''')
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_emp_reported_date ON equipment_missing_parts(reported_date)
            ''')

            # Ensure FK uses ON DELETE CASCADE so linked part requests are removed with the CM
            try:
                cursor.execute('''
                    ALTER TABLE cm_parts_requests
                    DROP CONSTRAINT IF EXISTS cm_parts_requests_cm_number_fkey
                ''')
                cursor.execute('''
                    ALTER TABLE cm_parts_requests
                    ADD CONSTRAINT cm_parts_requests_cm_number_fkey
                    FOREIGN KEY (cm_number)
                    REFERENCES corrective_maintenance (cm_number)
                    ON DELETE CASCADE
                ''')
            except Exception as e:
                print(f"Note: Unable to update cm_parts_requests FK to ON DELETE CASCADE: {e}")
        
            # Work Orders table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS work_orders (
                    id SERIAL PRIMARY KEY,
                    wo_number TEXT UNIQUE,
                    bfm_equipment_no TEXT,
                    wo_type TEXT,
                    description TEXT,
                    location TEXT,
                    requested_by TEXT,
                    requested_date TEXT,
                    priority TEXT,
                    status TEXT DEFAULT 'Open',
                    assigned_technician TEXT,
                    estimated_hours REAL,
                    actual_hours REAL,
                    completed_date TEXT,
                    notes TEXT,
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (bfm_equipment_no) REFERENCES equipment (bfm_equipment_no)
                )
            ''')
        
            # Parts/Inventory table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS parts_inventory (
                    id SERIAL PRIMARY KEY,
                    part_number TEXT UNIQUE,
                    description TEXT,
                    quantity INTEGER DEFAULT 0,
                    min_quantity INTEGER,
                    location TEXT,
                    unit_cost REAL,
                    last_ordered TEXT,
                    supplier TEXT,
                    notes TEXT,
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
        
            # MRO Stock table (if you use it)
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS mro_stock (
                    id SERIAL PRIMARY KEY,
                    part_number TEXT UNIQUE,
                    description TEXT,
                    quantity INTEGER DEFAULT 0,
                    location TEXT,
                    category TEXT,
                    notes TEXT,
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
        
            # Cannot Find Assets table - COMPLETE VERSION
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS cannot_find_assets (
                    id SERIAL PRIMARY KEY,
                    bfm_equipment_no TEXT UNIQUE,
                    description TEXT,
                    location TEXT,
                    last_known_location TEXT,
                    reported_by TEXT,
                    reported_date TEXT,
                    technician_name TEXT,
                    assigned_technician TEXT,
                    status TEXT DEFAULT 'Missing',
                    search_status TEXT,
                    priority TEXT,
                    found_date TEXT,
                    found_by TEXT,
                    notes TEXT,
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (bfm_equipment_no) REFERENCES equipment (bfm_equipment_no)
                )
            ''')
        
            # Run to Failure Assets table - COMPLETE WITH LABOR TRACKING
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS run_to_failure_assets (
                    id SERIAL PRIMARY KEY,
                    bfm_equipment_no TEXT UNIQUE,
                    description TEXT,
                    location TEXT,
                    justification TEXT,
                    approved_by TEXT,
                    approval_date TIMESTAMP,
                    technician_name TEXT,
                    assigned_technician TEXT,
                    status TEXT DEFAULT 'Active',
                    review_date TIMESTAMP,
                    next_review_date TIMESTAMP,
                    last_inspection_date TIMESTAMP,
                    completion_date TIMESTAMP,
                    failure_date TIMESTAMP,
                    last_failure_date TIMESTAMP,
                    installed_date TIMESTAMP,
                    retired_date TIMESTAMP,
                    labor_hours REAL,
                    labor_minutes REAL,
                    total_labor_hours REAL,
                    labor_cost REAL,
                    notes TEXT,
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (bfm_equipment_no) REFERENCES equipment (bfm_equipment_no)
                )
            ''')

            # Deactivated Assets table - For tracking deactivated equipment
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS deactivated_assets (
                    id SERIAL PRIMARY KEY,
                    bfm_equipment_no TEXT UNIQUE,
                    description TEXT,
                    location TEXT,
                    deactivated_by TEXT,
                    deactivated_date TEXT,
                    technician_name TEXT,
                    reason TEXT,
                    status TEXT DEFAULT 'Deactivated',
                    notes TEXT,
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (bfm_equipment_no) REFERENCES equipment (bfm_equipment_no)
                )
            ''')

            # ===== MULTI-USER SUPPORT TABLES =====
            # Users table for authentication
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id SERIAL PRIMARY KEY,
                    username TEXT UNIQUE NOT NULL,
                    password_hash TEXT NOT NULL,
                    full_name TEXT NOT NULL,
                    role TEXT NOT NULL CHECK (role IN ('Manager', 'Technician', 'Parts Coordinator')),
                    email TEXT,
                    is_active BOOLEAN DEFAULT TRUE,
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    last_login TIMESTAMP,
                    created_by TEXT,
                    notes TEXT
                )
            ''')

            # SCHEMA MIGRATION: Update users table CHECK constraint for existing databases
            # Drop old constraint and add new one that includes 'Parts Coordinator'
            try:
                cursor.execute('''
                    ALTER TABLE users
                    DROP CONSTRAINT IF EXISTS users_role_check
                ''')
                cursor.execute('''
                    ALTER TABLE users
                    ADD CONSTRAINT users_role_check
                    CHECK (role IN ('Manager', 'Technician', 'Parts Coordinator'))
                ''')
                print("CHECK: Users table constraint updated to support Parts Coordinator role")
            except Exception as e:
                print(f"Note: Users table constraint update skipped or already applied: {e}")

            # User sessions table for tracking active sessions
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_sessions (
                    id SERIAL PRIMARY KEY,
                    user_id INTEGER NOT NULL,
                    username TEXT NOT NULL,
                    login_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    logout_time TIMESTAMP,
                    last_activity TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    is_active BOOLEAN DEFAULT TRUE,
                    session_data TEXT,
                    FOREIGN KEY (user_id) REFERENCES users (id)
                )
            ''')

            # Audit log table for tracking all changes
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS audit_log (
                    id SERIAL PRIMARY KEY,
                    user_name TEXT NOT NULL,
                    action TEXT NOT NULL,
                    table_name TEXT NOT NULL,
                    record_id TEXT,
                    old_values TEXT,
                    new_values TEXT,
                    notes TEXT,
                    action_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # PERFORMANCE OPTIMIZATION: Create comprehensive indexes for all tables
            # These indexes dramatically improve query performance across the system
            print("CHECK: Creating comprehensive performance indexes...")

            # === Weekly PM Schedules Indexes ===
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_weekly_pm_schedules_uncompleted
                ON weekly_pm_schedules(bfm_equipment_no, pm_type, week_start_date)
                WHERE status = 'Scheduled'
            ''')

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_weekly_pm_schedules_week_status
                ON weekly_pm_schedules(week_start_date, status)
            ''')

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_weekly_pm_schedules_equipment
                ON weekly_pm_schedules(bfm_equipment_no)
            ''')

            # === Equipment Table Indexes ===
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_equipment_location
                ON equipment(location)
            ''')

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_equipment_status
                ON equipment(status)
            ''')

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_equipment_master_lin
                ON equipment(master_lin)
            ''')

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_equipment_active_location
                ON equipment(status, location)
                WHERE status = 'Active'
            ''')

            # === Corrective Maintenance Indexes ===
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_cm_status
                ON corrective_maintenance(status)
            ''')

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_cm_assigned_technician
                ON corrective_maintenance(assigned_technician)
            ''')

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_cm_priority
                ON corrective_maintenance(priority)
            ''')

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_cm_reported_date
                ON corrective_maintenance(reported_date)
            ''')

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_cm_open_by_technician
                ON corrective_maintenance(assigned_technician, status, priority)
                WHERE status != 'Closed'
            ''')

            # === PM Completions Indexes ===
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_pm_completions_equipment
                ON pm_completions(bfm_equipment_no)
            ''')

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_pm_completions_date
                ON pm_completions(completion_date)
            ''')

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_pm_completions_technician
                ON pm_completions(technician_name)
            ''')

            # === Audit Log Indexes ===
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_audit_log_timestamp
                ON audit_log(action_timestamp)
            ''')

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_audit_log_user_table
                ON audit_log(user_name, table_name, action_timestamp)
            ''')

            print("CHECK: Performance indexes created successfully!")

            # Create additional functional indexes for case-insensitive searches
            self.create_performance_indexes(cursor)

            self.conn.commit()
            cursor.close()
            print("CHECK: Database tables created successfully!")
            print("CHECK: Multi-user support tables initialized")
            print("=" * 60 + "\n")

        except Exception as e:
            print(f"CHECK: ERROR connecting to database: {e}")
            if self.conn:
                self.conn.rollback()
            raise
    
    
    def create_gui(self):
        """Create the main GUI interface based on user role"""
        # Create style
        style = ttk.Style()
        style.theme_use('clam')

        # Create menu bar (available to all users)
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        # Account menu
        account_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Account", menu=account_menu)
        account_menu.add_command(label="Change Password", command=self.open_change_password)
        account_menu.add_separator()
        account_menu.add_command(label="Logout", command=self.logout)

        # Toolbar frame at the top (for Manager actions)
        if self.current_user_role == 'Manager':
            toolbar_frame = ttk.Frame(self.root, relief='raised', borderwidth=1)
            toolbar_frame.pack(side='top', fill='x', padx=5, pady=5)

            # Left side - Title
            ttk.Label(toolbar_frame, text="Manager Tools:",
                     font=('Arial', 10, 'bold')).pack(side='left', padx=10)

            # Right side - Action buttons
            ttk.Button(toolbar_frame, text=" Manage Users",
                      command=self.open_user_management).pack(side='left', padx=5)

            ttk.Button(toolbar_frame, text=" Database Backup",
                      command=self.open_backup_manager).pack(side='left', padx=5)

            ttk.Button(toolbar_frame, text="Switch to Technician View",
                      command=self.switch_to_technician_view).pack(side='left', padx=5)

            # Separator
            ttk.Separator(self.root, orient='horizontal').pack(fill='x', padx=5)

        # Main container with scrollbar for the notebook
        main_container = ttk.Frame(self.root)
        main_container.pack(fill='both', expand=True, padx=10, pady=10)

        # Create canvas and scrollbar
        self.main_canvas = tk.Canvas(main_container, highlightthickness=0)
        scrollbar = ttk.Scrollbar(main_container, orient="vertical", command=self.main_canvas.yview)

        # Create frame inside canvas to hold the notebook
        self.scrollable_frame = ttk.Frame(self.main_canvas)

        # Configure scrolling - update scroll region when content changes
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.main_canvas.configure(scrollregion=self.main_canvas.bbox("all"))
        )

        # Create window in canvas for the scrollable frame
        self.canvas_window = self.main_canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.main_canvas.configure(yscrollcommand=scrollbar.set)

        # Make the scrollable frame fill the canvas width
        def _configure_canvas(event):
            # Set the width of the canvas window to match the canvas width
            canvas_width = event.width
            self.main_canvas.itemconfig(self.canvas_window, width=canvas_width)

        self.main_canvas.bind("<Configure>", _configure_canvas)

        # Pack scrollbar and canvas
        scrollbar.pack(side="right", fill="y")
        self.main_canvas.pack(side="left", fill="both", expand=True)

        # Bind mouse wheel scrolling
        def _on_mousewheel(event):
            self.main_canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        self.main_canvas.bind_all("<MouseWheel>", _on_mousewheel)

        # Main notebook for tabs (now inside scrollable frame)
        self.notebook = ttk.Notebook(self.scrollable_frame)
        self.notebook.pack(fill='both', expand=True)

        # Create tabs based on role
        if self.current_user_role == 'Manager':
            # Manager gets all tabs
            self.create_all_manager_tabs()
        elif self.current_user_role == 'Parts Coordinator':
            # Parts Coordinator gets PM Completion and MRO Stock tabs only
            self.create_parts_coordinator_tabs()
        else:
            # Technicians only get CM tab
            self.create_technician_tabs()

        # Status bar with user info
        status_frame = ttk.Frame(self.root)
        status_frame.pack(side='bottom', fill='x')

        self.status_bar = ttk.Label(status_frame, text=f"AIT CMMS Ready - Logged in as: {self.user_name} ({self.current_user_role})",
                                    relief='sunken')
        self.status_bar.pack(side='left', fill='x', expand=True)

    def create_all_manager_tabs(self):
        """Create all tabs for manager access"""
        self.create_equipment_tab()
        self.create_pm_scheduling_tab()
        self.create_pm_completion_tab()
        self.create_cm_management_tab()
        #self.create_analytics_dashboard_tab()
        self.create_cannot_find_tab()
        self.create_deactivated_tab()
        self.create_custom_pm_templates_tab()
        self.mro_manager.create_mro_tab(self.notebook)
        self.manuals_manager.create_manuals_tab(self.notebook)

    def create_technician_tabs(self):
        """Create limited tabs for technician access"""
        # Only create CM Management tab for technicians
        self.create_cm_management_tab()

        # Add read-only MRO Stock tab for technicians
        self.mro_manager.create_mro_tab(self.notebook, readonly=True)

        # Add a simple info tab explaining their access
        self.create_technician_info_tab()

    def create_technician_info_tab(self):
        """Create an info tab for technicians"""
        info_frame = ttk.Frame(self.notebook)
        self.notebook.add(info_frame, text="System Info")
    
        # Welcome message
        welcome_frame = ttk.LabelFrame(info_frame, text="Welcome to AIT CMMS", padding=20)
        welcome_frame.pack(fill='both', expand=True, padx=20, pady=20)
    
        welcome_text = f"""
    Welcome, {self.user_name}!

    You are logged in as a Technician with access to:
    - Complete Corrective Maintenance (CM) System
    - View ALL team CMs (everyone's entries)
    - Create new CMs
    - Edit existing CMs
    - Complete CMs
    - View CM history and status
    - MRO Stock (Read-Only) - View parts inventory

    Team Collaboration:
    - You can see CMs created by all technicians
    - View work assigned to other team members
    - Complete CMs assigned to you or help with others
    - Full visibility of maintenance activities

    New Features:
    - MRO Stock tab: View parts inventory, check stock levels, export reports
    - Check parts availability before creating work orders
    - View low stock alerts and usage reports

    For additional system access or questions, please contact your manager.

    System Information:
    - User: {self.user_name}
    - Role: {self.current_user_role}
    - Login Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

    Quick Tips:
    - Use the CM tab to view all corrective maintenance
    - Create new CMs when you discover issues
    - Enter accurate dates when creating CMs
    - Provide detailed descriptions for better tracking
    - Update CM status when work is completed
    - Check MRO Stock for parts availability
    - Coordinate with team members through CM system
    """
    
        info_label = ttk.Label(welcome_frame, text=welcome_text, 
                            font=('Arial', 11), justify='left')
        info_label.pack(anchor='w')
    
        # Quick access buttons
        buttons_frame = ttk.Frame(welcome_frame)
        buttons_frame.pack(fill='x', pady=20)
    
        ttk.Button(buttons_frame, text="Create New CM",
                command=self.create_cm_dialog).pack(side='left', padx=10)
        ttk.Button(buttons_frame, text="View My Assigned CMs",
                command=self.show_my_cms).pack(side='left', padx=10)

    def create_parts_coordinator_tabs(self):
        """Create limited tabs for parts coordinator access - PM Completion, MRO Stock, and Manuals"""
        # Parts coordinator gets PM Completion, MRO Stock, and Manuals tabs
        self.create_pm_completion_tab()
        self.mro_manager.create_mro_tab(self.notebook)
        self.manuals_manager.create_manuals_tab(self.notebook)

        # Add an info tab explaining their access
        self.create_parts_coordinator_info_tab()

    def create_parts_coordinator_info_tab(self):
        """Create an info tab for parts coordinator"""
        info_frame = ttk.Frame(self.notebook)
        self.notebook.add(info_frame, text="System Info")

        # Welcome message
        welcome_frame = ttk.LabelFrame(info_frame, text="Welcome to AIT CMMS", padding=20)
        welcome_frame.pack(fill='both', expand=True, padx=20, pady=20)

        welcome_text = f"""
    Welcome, {self.user_name}!

    You are logged in as a Parts Coordinator with access to:
    - PM Completion Management
       View and edit PM completion records
       Track PM work performed by technicians
       Manage labor hours and completion dates
       Review PM history and statistics

    - MRO Stock Management
       View and manage parts inventory
       Update stock quantities
       Track part usage and costs
       Monitor stock levels and reorder points
       Add new parts to inventory

    Your Role:
    - Manage all PM completion entries and data
    - Oversee MRO stock inventory and parts tracking
    - All changes you make are automatically saved to the database
    - Your work ensures accurate maintenance records and inventory control

    For additional system access or questions, please contact your manager.

    System Information:
    - User: {self.user_name}
    - Role: {self.current_user_role}
    - Login Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

    Quick Tips:
    - Use PM Completion tab to review and manage maintenance records
    - Use MRO Stock tab to manage parts inventory
    - All changes are saved immediately to the database
    - You can change your password using the menu at the top
    """

        info_label = ttk.Label(welcome_frame, text=welcome_text,
                            font=('Arial', 11), justify='left')
        info_label.pack(anchor='w')

    def show_my_cms(self):
        """Show CMs assigned to current technician"""
        if self.current_user_role != 'Technician':
            return
        
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT cm_number, bfm_equipment_no, description, priority, status, created_date
                FROM corrective_maintenance 
                WHERE assigned_technician = %s
                ORDER BY created_date DESC
            ''', (self.user_name,))
        
            my_cms = cursor.fetchall()
        
            # Create dialog to show results
            dialog = tk.Toplevel(self.root)
            dialog.title(f"My CMs - {self.user_name}")
            dialog.geometry("800x400")
            dialog.transient(self.root)
            dialog.grab_set()
        
            if my_cms:
                # Create tree to display CMs
                tree = ttk.Treeview(dialog, columns=('CM#', 'Equipment', 'Description', 'Priority', 'Status', 'Date'), 
                                show='headings')
            
                for col in ('CM#', 'Equipment', 'Description', 'Priority', 'Status', 'Date'):
                    tree.heading(col, text=col)
                    tree.column(col, width=120)
            
                for cm in my_cms:
                    cm_number, bfm_no, description, priority, status, created_date = cm
                    display_desc = (description[:30] + '...') if len(description) > 30 else description
                    tree.insert('', 'end', values=(cm_number, bfm_no, display_desc, priority, status, created_date))
            
                tree.pack(fill='both', expand=True, padx=10, pady=10)
            else:
                ttk.Label(dialog, text=f"No CMs assigned to {self.user_name}", 
                        font=('Arial', 12)).pack(pady=50)
        
            ttk.Button(dialog, text="Close", command=dialog.destroy).pack(pady=10)
        
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load your CMs: {str(e)}")

    def open_user_management(self):
        """Open user management dialog (Manager only)"""
        if self.current_user_role != 'Manager':
            messagebox.showerror("Access Denied", "Only managers can access user management.")
            return

        try:
            dialog = UserManagementDialog(self.root, self.user_name)
            dialog.show()

            # Reload technicians list after dialog closes (to pick up any new users)
            self.load_technicians_from_database()
            print("Technicians list refreshed after user management")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to open user management: {e}")

    def open_backup_manager(self):
        """Open database backup manager (Manager only)"""
        if self.current_user_role != 'Manager':
            messagebox.showerror("Access Denied", "Only managers can access the backup manager.")
            return

        try:
            backup_ui = BackupUI(self.root, self.DB_CONFIG, self.user_name)
            backup_ui.open_backup_window()

        except Exception as e:
            messagebox.showerror("Error", f"Failed to open backup manager: {e}")
            print(f"Backup manager error: {e}")

    def open_change_password(self):
        """Open password change dialog (available to all users)"""
        try:
            # Get the username from the user_name attribute
            # user_name contains the full name, but we need the username
            # We'll need to query the database to get the username
            with db_pool.get_cursor(commit=False) as cursor:
                cursor.execute(
                    """
                    SELECT username FROM users
                    WHERE id = %s
                    """,
                    (self.user_id,)
                )
                result = cursor.fetchone()
                if result:
                    username = result['username'] if isinstance(result, dict) else result[0]
                    show_password_change_dialog(self.root, self.user_name, username)
                else:
                    messagebox.showerror("Error", "Could not retrieve user information")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to open password change dialog: {e}")
            print(f"Password change dialog error: {e}")

    def logout(self):
        """Logout current user and show login dialog"""
        result = messagebox.askyesno("Logout",
                                     f"Logout {self.user_name}?\n\n"
                                     "This will close the application.\n"
                                     "You'll need to login again to continue.")
        if result:
            try:
                # End the current session
                if self.session_id:
                    with db_pool.get_cursor(commit=True) as cursor:
                        UserManager.end_session(cursor, self.session_id)
                        print(f"Session {self.session_id} ended for user {self.user_name}")
            except Exception as e:
                print(f"Error ending session: {e}")
            finally:
                # Close the application
                self.root.destroy()

    def switch_to_technician_view(self):
        """Switch to technician view for testing (Manager only)"""
        if self.current_user_role != 'Manager':
            return
        
        result = messagebox.askyesno("Switch View", 
                                    "Switch to Technician view?\n\n"
                                    "This will hide all manager functions and only show CM access.\n"
                                    "You'll need to restart the application to get back to Manager view.")
    
        if result:
            # Temporarily switch role
            self.current_user_role = 'Technician'
            self.user_name = 'Test Technician'
        
            # Recreate GUI
            for widget in self.notebook.winfo_children():
                widget.destroy()
        
            self.create_technician_tabs()
            self.status_bar.config(text=f"AIT CMMS - Logged in as: {self.user_name} ({self.current_user_role})")

    
   
    
    def standardize_all_database_dates(self):
        """Standardize all dates in the database to YYYY-MM-DD format"""
        
        # Confirmation dialog
        result = messagebox.askyesno(
            "Confirm Date Standardization",
            "This will standardize ALL dates in the database to YYYY-MM-DD format.\n\n"
            "Tables affected:\n"
            "- Equipment (PM dates)\n"
            "- PM Completions\n"
            "- Weekly Schedules\n"
            "- Corrective Maintenance\n"
            "- Cannot Find Assets\n"
            "- Run to Failure Assets\n\n"
            "This action cannot be undone. Continue?",
            icon='warning'
        )
        
        if not result:
            return
        
        try:
            # Create progress dialog
            progress_dialog = tk.Toplevel(self.root)
            progress_dialog.title("Standardizing Dates...")
            progress_dialog.geometry("400x150")
            progress_dialog.transient(self.root)
            progress_dialog.grab_set()
            
            ttk.Label(progress_dialog, text="Standardizing dates in database...", 
                     font=('Arial', 12)).pack(pady=20)
            
            progress_var = tk.StringVar(value="Initializing...")
            progress_label = ttk.Label(progress_dialog, textvariable=progress_var)
            progress_label.pack(pady=10)
            
            progress_bar = ttk.Progressbar(progress_dialog, mode='indeterminate')
            progress_bar.pack(pady=10, padx=20, fill='x')
            progress_bar.start()
            
            # Update GUI
            self.root.update()
            
            # Perform standardization
            progress_var.set("Processing database...")
            self.root.update()
            
            standardizer = DateStandardizer(self.conn)
            total_updated, errors = standardizer.standardize_all_dates()
            
            progress_bar.stop()
            progress_dialog.destroy()
            
            # Show results
            if errors:
                error_msg = f"Date standardization completed with {len(errors)} errors:\n\n"
                error_msg += "\n".join(errors[:10])  # Show first 10 errors
                if len(errors) > 10:
                    error_msg += f"\n... and {len(errors) - 10} more errors"
                
                messagebox.showwarning("Standardization Complete (With Errors)", 
                                     f"Updated {total_updated} records.\n\n{error_msg}")
            else:
                messagebox.showinfo("Success", 
                                  f"Date standardization completed successfully!\n\n"
                                  f"Updated {total_updated} date records to YYYY-MM-DD format.\n\n"
                                  f"All dates are now standardized.")
            
            # Refresh displays
            self.refresh_equipment_list()
            self.load_recent_completions()
            if hasattr(self, 'load_cannot_find_assets'):
                self.load_cannot_find_assets()
            if hasattr(self, 'load_run_to_failure_assets'):
                self.load_run_to_failure_assets()
            
            self.update_status(f"Date standardization complete: {total_updated} records updated")
            
        except Exception as e:
            if 'progress_dialog' in locals():
                progress_dialog.destroy()
            messagebox.showerror("Error", f"Failed to standardize dates: {str(e)}")
    
    def add_date_standardization_button(self):
        """Add date standardization button to equipment tab"""
        # Find the controls frame in equipment tab
        for widget in self.equipment_frame.winfo_children():
            if isinstance(widget, ttk.LabelFrame) and "Equipment Controls" in widget['text']:
                ttk.Button(widget, text="Standardize All Dates (YYYY-MM-DD)", 
                          command=self.standardize_all_database_dates,
                          width=30).pack(side='left', padx=5)
                break
    
    

    def create_equipment_tab(self):
        """Equipment management and data import tab"""
        self.equipment_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.equipment_frame, text="Equipment Management")
        
        # Controls frame
        controls_frame = ttk.LabelFrame(self.equipment_frame, text="Equipment Controls", padding=10)
        controls_frame.pack(fill='x', padx=10, pady=5)
        
        # Add statistics frame after controls_frame
        stats_frame = ttk.LabelFrame(self.equipment_frame, text="Equipment Statistics", padding=10)
        stats_frame.pack(fill='x', padx=10, pady=5)

        # Statistics labels
        self.stats_total_label = ttk.Label(stats_frame, text="Total Assets: 0", font=('Arial', 10, 'bold'))
        self.stats_total_label.pack(side='left', padx=20)

        self.stats_cf_label = ttk.Label(stats_frame, text="Cannot Find: 0", font=('Arial', 10, 'bold'), foreground='red')
        self.stats_cf_label.pack(side='left', padx=20)

        self.stats_deact_label = ttk.Label(stats_frame, text="Deactivated: 0", font=('Arial', 10, 'bold'), foreground='orange')
        self.stats_deact_label.pack(side='left', padx=20)

        self.stats_active_label = ttk.Label(stats_frame, text="Active Assets: 0", font=('Arial', 10, 'bold'), foreground='green')
        self.stats_active_label.pack(side='left', padx=20)

        # PM count statistics for active assets
        self.stats_weekly_pm_label = ttk.Label(stats_frame, text="Weekly PMs: 0", font=('Arial', 10, 'bold'), foreground='blue')
        self.stats_weekly_pm_label.pack(side='left', padx=20)

        self.stats_monthly_pm_label = ttk.Label(stats_frame, text="Monthly PMs: 0", font=('Arial', 10, 'bold'), foreground='blue')
        self.stats_monthly_pm_label.pack(side='left', padx=20)

        self.stats_six_month_pm_label = ttk.Label(stats_frame, text="6-Month PMs: 0", font=('Arial', 10, 'bold'), foreground='blue')
        self.stats_six_month_pm_label.pack(side='left', padx=20)

        self.stats_annual_pm_label = ttk.Label(stats_frame, text="Annual PMs: 0", font=('Arial', 10, 'bold'), foreground='blue')
        self.stats_annual_pm_label.pack(side='left', padx=20)

        # Refresh stats button
        ttk.Button(stats_frame, text="Refresh Stats",
                command=self.update_equipment_statistics).pack(side='right', padx=5)
        
        
        ttk.Button(controls_frame, text="Import Equipment CSV", 
                  command=self.import_equipment_csv).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Add Equipment",
                  command=self.add_equipment_dialog).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Edit Equipment",
                  command=self.edit_equipment_dialog).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Delete Equipment",
                  command=self.delete_equipment_dialog).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Refresh List",
                  command=self.refresh_equipment_list).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Export Equipment", 
                  command=self.export_equipment_list).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Bulk Edit PM Cycles", 
                  command=self.bulk_edit_pm_cycles).pack(side='left', padx=5)
        
        
        # Search frame
        search_frame = ttk.Frame(self.equipment_frame)
        search_frame.pack(fill='x', padx=10, pady=5)

        ttk.Label(search_frame, text="Search Equipment:").pack(side='left', padx=5)
        self.equipment_search_var = tk.StringVar()
        self.equipment_search_entry = ttk.Entry(search_frame, textvariable=self.equipment_search_var, width=30)
        self.equipment_search_entry.pack(side='left', padx=5)
        # Bind KeyRelease event to trigger filtering as user types
        self.equipment_search_entry.bind('<KeyRelease>', self.filter_equipment_list)

        # Status filter
        ttk.Label(search_frame, text="Status:").pack(side='left', padx=(20, 5))
        self.equipment_status_var = tk.StringVar(value="All Assets")
        self.equipment_status_combo = ttk.Combobox(search_frame, textvariable=self.equipment_status_var,
                                                    values=["All Assets", "ACTIVE", "INACTIVE"],
                                                    width=12, state='readonly')
        self.equipment_status_combo.pack(side='left', padx=5)
        self.equipment_status_combo.bind('<<ComboboxSelected>>', self.filter_equipment_list)

        # Location filter
        ttk.Label(search_frame, text="Filter by Location:").pack(side='left', padx=(20, 5))
        self.equipment_location_var = tk.StringVar(value="All Locations")
        self.equipment_location_combo = ttk.Combobox(search_frame, textvariable=self.equipment_location_var, width=25, state='readonly')
        self.equipment_location_combo.pack(side='left', padx=5)
        self.equipment_location_combo.bind('<<ComboboxSelected>>', self.filter_equipment_list)

        # PM Cycle filters
        ttk.Label(search_frame, text="PM Cycles:").pack(side='left', padx=(20, 5))
        self.monthly_pm_filter_var = tk.BooleanVar(value=False)
        self.six_month_pm_filter_var = tk.BooleanVar(value=False)
        self.annual_pm_filter_var = tk.BooleanVar(value=False)

        ttk.Checkbutton(search_frame, text="Monthly", variable=self.monthly_pm_filter_var,
                       command=self.filter_equipment_list).pack(side='left', padx=2)
        ttk.Checkbutton(search_frame, text="6-Month", variable=self.six_month_pm_filter_var,
                       command=self.filter_equipment_list).pack(side='left', padx=2)
        ttk.Checkbutton(search_frame, text="Annual", variable=self.annual_pm_filter_var,
                       command=self.filter_equipment_list).pack(side='left', padx=2)

        # Clear filters button
        ttk.Button(search_frame, text="Clear Filters",
                  command=self.clear_equipment_filters).pack(side='left', padx=5)
        
        # Equipment list
        list_frame = ttk.Frame(self.equipment_frame)
        list_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        # Treeview with scrollbars
        self.equipment_tree = ttk.Treeview(list_frame,
                                         columns=('SAP', 'BFM', 'Description', 'Location', 'LIN', 'Monthly', 'Six Month', 'Annual', 'Status'),
                                         show='headings')
        self.equipment_tree.configure(selectmode='extended')  # Enable multi-select
        # Configure columns
        columns_config = {
            'SAP': ('SAP Material No.', 120),
            'BFM': ('BFM Equipment No.', 130),
            'Description': ('Description', 300),
            'Location': ('Location', 100),
            'LIN': ('Master LIN', 80),
            'Monthly': ('Monthly PM', 80),
            'Six Month': ('6-Month PM', 80),
            'Annual': ('Annual PM', 80),
            'Status': ('Status', 80)
        }
        
        for col, (heading, width) in columns_config.items():
            self.equipment_tree.heading(col, text=heading)
            self.equipment_tree.column(col, width=width)
        
        # Scrollbars
        v_scrollbar = ttk.Scrollbar(list_frame, orient='vertical', command=self.equipment_tree.yview)
        h_scrollbar = ttk.Scrollbar(list_frame, orient='horizontal', command=self.equipment_tree.xview)
        self.equipment_tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
        
        # Pack treeview and scrollbars
        self.equipment_tree.grid(row=0, column=0, sticky='nsew')
        v_scrollbar.grid(row=0, column=1, sticky='ns')
        h_scrollbar.grid(row=1, column=0, sticky='ew')
        
        list_frame.grid_rowconfigure(0, weight=1)
        list_frame.grid_columnconfigure(0, weight=1)

        # Pagination controls for Equipment list
        equip_pagination_frame = ttk.Frame(self.equipment_frame)
        equip_pagination_frame.pack(fill='x', padx=10, pady=5)

        self.equip_record_label = ttk.Label(equip_pagination_frame, text="Loading...",
                                            font=('Arial', 9))
        self.equip_record_label.pack(side='left', padx=5)

        self.equip_load_more_btn = ttk.Button(equip_pagination_frame, text=" Load More Records",
                                              command=self.load_more_equipment_records)
        self.equip_load_more_btn.pack(side='left', padx=5)

        # Initialize pagination state
        self.equip_offset = 0
        self.equip_page_size = 200
        self.equip_total_count = 0
        self.equip_loaded_count = 0

        # Bind double-click event to equipment list
        self.equipment_tree.bind('<Double-1>', self.on_equipment_double_click)

        # Initialize equipment data on tab creation
        self.refresh_equipment_list()


    
    
    
    
    
    
    def populate_week_selector(self):
        """Populate dropdown with weeks that have schedules - OPTIMIZED: Limit to last 52 weeks"""
        try:
            cursor = self.conn.cursor()
            # PERFORMANCE OPTIMIZATION: Limit to last 52 weeks (1 year) to prevent memory bloat
            cursor.execute('''
                SELECT DISTINCT week_start_date
                FROM weekly_pm_schedules
                ORDER BY week_start_date DESC
                LIMIT 52
            ''')
            available_weeks = [row[0] for row in cursor.fetchall()]
        
            # Always include current week as an option
            current_week = self.current_week_start.strftime('%Y-%m-%d')
            if current_week not in available_weeks:
                available_weeks.append(current_week)
                available_weeks.sort(reverse=True)
            
            # Update combobox values
            self.week_combo['values'] = available_weeks
        
            # Set to most recent week with data, or current week if no data
            if available_weeks:
                self.week_start_var.set(available_weeks[0])
            
        except Exception as e:
            print(f"Error populating week selector: {e}")

    def load_latest_weekly_schedule(self):
        """Load the most recent weekly schedule on startup"""
        try:
            cursor = self.conn.cursor()
        
            # Find the most recent week with scheduled PMs
            cursor.execute('''
                SELECT week_start_date 
                FROM weekly_pm_schedules 
                ORDER BY week_start_date DESC 
                LIMIT 1
            ''')
        
            latest_week = cursor.fetchone()
        
            if latest_week:
                self.week_start_var.set(latest_week[0])
                self.refresh_technician_schedules()
                self.update_status(f"Loaded latest weekly schedule: {latest_week[0]}")
            else:
                self.update_status("No weekly schedules found")
            
        except Exception as e:
            print(f"Error loading latest weekly schedule: {e}")
    
    
    
    def update_equipment_statistics(self):
        """Update equipment statistics display - OPTIMIZED: Single query instead of 7"""
        try:
            cursor = self.conn.cursor()

            # PERFORMANCE OPTIMIZATION: Combine 7 separate queries into 1 query
            # Uses LEFT JOINs and CASE statements to calculate all statistics in one go
            cursor.execute('''
                SELECT
                    COUNT(DISTINCT e.bfm_equipment_no) as total_assets,
                    COUNT(DISTINCT CASE WHEN c.bfm_equipment_no IS NOT NULL THEN e.bfm_equipment_no END) as cannot_find_count,
                    COUNT(DISTINCT CASE WHEN d.bfm_equipment_no IS NOT NULL THEN e.bfm_equipment_no END) as deactivated_count,
                    COUNT(DISTINCT CASE
                        WHEN e.monthly_pm = TRUE
                        AND c.bfm_equipment_no IS NULL
                        AND d.bfm_equipment_no IS NULL
                        THEN e.bfm_equipment_no
                    END) as monthly_equipment_count,
                    COUNT(DISTINCT CASE
                        WHEN e.six_month_pm = TRUE
                        AND c.bfm_equipment_no IS NULL
                        AND d.bfm_equipment_no IS NULL
                        THEN e.bfm_equipment_no
                    END) as six_month_equipment_count,
                    COUNT(DISTINCT CASE
                        WHEN e.annual_pm = TRUE
                        AND c.bfm_equipment_no IS NULL
                        AND d.bfm_equipment_no IS NULL
                        THEN e.bfm_equipment_no
                    END) as annual_equipment_count,
                    COUNT(DISTINCT CASE
                        WHEN e.weekly_pm = TRUE
                        AND c.bfm_equipment_no IS NULL
                        AND d.bfm_equipment_no IS NULL
                        THEN e.bfm_equipment_no
                    END) as weekly_equipment_count
                FROM equipment e
                LEFT JOIN cannot_find_assets c ON e.bfm_equipment_no = c.bfm_equipment_no AND c.status = 'Missing'
                LEFT JOIN deactivated_assets d ON e.bfm_equipment_no = d.bfm_equipment_no AND d.status = 'Deactivated'
            ''')

            result = cursor.fetchone()
            total_assets = result[0] or 0
            cannot_find_count = result[1] or 0
            deactivated_count = result[2] or 0
            monthly_equipment_count = result[3] or 0
            six_month_equipment_count = result[4] or 0
            annual_equipment_count = result[5] or 0
            weekly_equipment_count = result[6] or 0

            # Active assets = Total - Cannot Find - Deactivated
            active_assets = total_assets - cannot_find_count - deactivated_count

            # Calculate ANNUAL PM WORKLOAD (total PMs per year)
            monthly_pm_count = monthly_equipment_count * 12  # 12 monthly PMs per year per asset
            six_month_pm_count = six_month_equipment_count * 2  # 2 six-month PMs per year per asset
            annual_pm_count = annual_equipment_count * 1  # 1 annual PM per year per asset
            weekly_pm_count = weekly_equipment_count * 52  # 52 weekly PMs per year per asset

            # Update labels - show annual PM workload
            self.stats_total_label.config(text=f"Total Assets: {total_assets}")
            self.stats_active_label.config(text=f"Active Assets: {active_assets}")
            self.stats_cf_label.config(text=f"Cannot Find: {cannot_find_count}")
            self.stats_deact_label.config(text=f"Deactivated: {deactivated_count}")
            self.stats_weekly_pm_label.config(text=f"Weekly PMs: {weekly_pm_count}/year ({weekly_equipment_count} assets)")
            self.stats_monthly_pm_label.config(text=f"Monthly PMs: {monthly_pm_count}/year ({monthly_equipment_count} assets)")
            self.stats_six_month_pm_label.config(text=f"6-Month PMs: {six_month_pm_count}/year ({six_month_equipment_count} assets)")
            self.stats_annual_pm_label.config(text=f"Annual PMs: {annual_pm_count}/year ({annual_equipment_count} assets)")

            # Update status bar
            self.update_status(f"Equipment stats updated - Total: {total_assets}, Active: {active_assets}, CF: {cannot_find_count}, Deactivated: {deactivated_count}, Weekly PMs: {weekly_pm_count}/yr ({weekly_equipment_count} assets), Monthly PMs: {monthly_pm_count}/yr ({monthly_equipment_count} assets), 6-Month: {six_month_pm_count}/yr ({six_month_equipment_count} assets), Annual: {annual_pm_count}/yr ({annual_equipment_count} assets)")

        except Exception as e:
            print(f"Error updating equipment statistics: {e}")
            messagebox.showerror("Error", f"Failed to update equipment statistics: {str(e)}")
    
    def create_pm_scheduling_tab(self):
        """PM Scheduling and assignment tab"""
        self.pm_schedule_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.pm_schedule_frame, text="PM Scheduling")
        
        # Controls
        controls_frame = ttk.LabelFrame(self.pm_schedule_frame, text="PM Scheduling Controls", padding=10)
        controls_frame.pack(fill='x', padx=10, pady=5)
        
        
       
        # Week selection with dropdown of available weeks
        ttk.Label(controls_frame, text="Week Starting:").grid(row=0, column=0, sticky='w', padx=5)
        self.week_start_var = tk.StringVar(value=self.current_week_start.strftime('%Y-%m-%d'))

        # Create combobox instead of entry
        self.week_combo = ttk.Combobox(controls_frame, textvariable=self.week_start_var, width=12)
        self.week_combo.grid(row=0, column=1, padx=5)

        # Bind selection change to refresh display
        self.week_combo.bind('<<ComboboxSelected>>', lambda e: self.refresh_technician_schedules())

        # Populate with available weeks
        self.populate_week_selector()

        # Weekly PM target input
        ttk.Label(controls_frame, text="Weekly PM Target:").grid(row=1, column=0, sticky='w', padx=5, pady=5)
        self.weekly_pm_target_var = tk.IntVar(value=self.weekly_pm_target)
        weekly_target_spinbox = ttk.Spinbox(controls_frame, from_=1, to=500,
                                           textvariable=self.weekly_pm_target_var, width=10)
        weekly_target_spinbox.grid(row=1, column=1, sticky='w', padx=5, pady=5)

        ttk.Button(controls_frame, text="Generate Weekly Schedule",
                  command=self.generate_weekly_assignments).grid(row=0, column=2, padx=5)
        ttk.Button(controls_frame, text="Print PM Forms",
                  command=self.print_weekly_pm_forms).grid(row=0, column=3, padx=5)
        ttk.Button(controls_frame, text="Export Schedule",
                  command=self.export_weekly_schedule).grid(row=0, column=4, padx=5)
        ttk.Button(controls_frame, text="Mark as Cannot Find",
                  command=self.mark_pm_cannot_find).grid(row=0, column=5, padx=5)

        # Technician Exclusion Controls
        exclusion_frame = ttk.LabelFrame(self.pm_schedule_frame, text="Exclude Technicians from This Week's Schedule", padding=10)
        exclusion_frame.pack(fill='x', padx=10, pady=5)

        ttk.Label(exclusion_frame, text="Select technicians to exclude (e.g., vacation, out sick):").pack(anchor='w', pady=5)

        # Create a frame for the listbox and scrollbar
        listbox_frame = ttk.Frame(exclusion_frame)
        listbox_frame.pack(fill='both', expand=False, pady=5)

        # Create listbox with multiple selection
        self.excluded_technicians_listbox = tk.Listbox(listbox_frame, selectmode='multiple', height=6, exportselection=False)
        self.excluded_technicians_listbox.pack(side='left', fill='both', expand=True)

        # Add scrollbar
        scrollbar = ttk.Scrollbar(listbox_frame, orient='vertical', command=self.excluded_technicians_listbox.yview)
        scrollbar.pack(side='right', fill='y')
        self.excluded_technicians_listbox.config(yscrollcommand=scrollbar.set)

        # Populate the listbox with technicians
        self.populate_technician_exclusion_list()

        # Add helper buttons
        button_frame = ttk.Frame(exclusion_frame)
        button_frame.pack(fill='x', pady=5)
        ttk.Button(button_frame, text="Clear All Exclusions", command=self.clear_all_exclusions).pack(side='left', padx=5)

        # Schedule display
        schedule_frame = ttk.LabelFrame(self.pm_schedule_frame, text="Weekly PM Schedule", padding=10)
        schedule_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        # Technician tabs
        self.technician_notebook = ttk.Notebook(schedule_frame)
        self.technician_notebook.pack(fill='both', expand=True)
        
        # Create tabs for each technician
        self.technician_trees = {}
        for tech in self.technicians:
            tech_frame = ttk.Frame(self.technician_notebook)
            self.technician_notebook.add(tech_frame, text=tech)

            # Technician's schedule tree
            tech_tree = ttk.Treeview(tech_frame,
                                   columns=('BFM', 'Description', 'PM Type', 'Due Date', 'Status'),
                                   show='headings')

            tech_tree.heading('BFM', text='BFM Equipment No.')
            tech_tree.heading('Description', text='Description')
            tech_tree.heading('PM Type', text='PM Type')
            tech_tree.heading('Due Date', text='Due Date')
            tech_tree.heading('Status', text='Status')

            for col in ('BFM', 'Description', 'PM Type', 'Due Date', 'Status'):
                tech_tree.column(col, width=150)

            tech_tree.pack(fill='both', expand=True, padx=5, pady=5)
            self.technician_trees[tech] = tech_tree

        # After creating all the technician trees, load the latest schedule
        self.load_latest_weekly_schedule()
     
    
    def create_pm_completion_tab(self):
        """PM Completion entry tab"""
        self.pm_completion_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.pm_completion_frame, text="PM Completion")
        
        # Completion form
        form_frame = ttk.LabelFrame(self.pm_completion_frame, text="PM Completion Entry", padding=15)
        form_frame.pack(fill='x', padx=10, pady=5)
        
        # Form fields (matching your PM form layout)
        row = 0
        
        # Equipment selection
        ttk.Label(form_frame, text="BFM Equipment Number:").grid(row=row, column=0, sticky='w', pady=5)
        self.completion_bfm_var = tk.StringVar()
        bfm_combo = ttk.Combobox(form_frame, textvariable=self.completion_bfm_var, width=20)
        bfm_combo.grid(row=row, column=1, sticky='w', padx=5, pady=5)
        bfm_combo.bind('<KeyRelease>', self.update_equipment_suggestions)
        self.bfm_combo = bfm_combo
        row += 1
        
        # PM Type
        ttk.Label(form_frame, text="PM Type (auto-filled from schedule):").grid(row=row, column=0, sticky='w', pady=5)
        self.pm_type_var = tk.StringVar()
        pm_type_combo = ttk.Combobox(form_frame, textvariable=self.pm_type_var,
                                   values=['Weekly', 'Monthly', 'Six Month', 'Annual'], width=20)
        # Bind PM type and equipment changes to template lookup
        pm_type_combo.bind('<<ComboboxSelected>>', lambda e: self.update_pm_completion_form_with_template())
        self.bfm_combo.bind('<KeyRelease>', lambda e: self.update_pm_completion_form_with_template())
        pm_type_combo.grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1
        
        # Technician
        ttk.Label(form_frame, text="Maintenance Technician:").grid(row=row, column=0, sticky='w', pady=5)
        self.completion_tech_var = tk.StringVar()
        tech_combo = ttk.Combobox(form_frame, textvariable=self.completion_tech_var, 
                                values=self.technicians, width=20)
        tech_combo.grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1
        
        # Labor time
        ttk.Label(form_frame, text="Labor Time:").grid(row=row, column=0, sticky='w', pady=5)
        time_frame = ttk.Frame(form_frame)
        time_frame.grid(row=row, column=1, sticky='w', padx=5, pady=5)
        
        self.labor_hours_var = tk.StringVar(value="0")
        ttk.Entry(time_frame, textvariable=self.labor_hours_var, width=5).pack(side='left')
        ttk.Label(time_frame, text="hours").pack(side='left', padx=5)
        
        self.labor_minutes_var = tk.StringVar(value="0")
        ttk.Entry(time_frame, textvariable=self.labor_minutes_var, width=5).pack(side='left')
        ttk.Label(time_frame, text="minutes").pack(side='left', padx=5)
        row += 1
        
        # PM Due Date (OPTION B: auto-populated from scheduled_date)
        ttk.Label(form_frame, text="PM Due Date (auto-filled from schedule):").grid(row=row, column=0, sticky='w', pady=5)
        self.pm_due_date_var = tk.StringVar()
        ttk.Entry(form_frame, textvariable=self.pm_due_date_var, width=20).grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1
        
        # Special Equipment
        ttk.Label(form_frame, text="Special Equipment Used:").grid(row=row, column=0, sticky='w', pady=5)
        self.special_equipment_var = tk.StringVar()
        ttk.Entry(form_frame, textvariable=self.special_equipment_var, width=40).grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1
        
        # Notes
        ttk.Label(form_frame, text="Notes from Technician:").grid(row=row, column=0, sticky='nw', pady=5)
        self.notes_text = tk.Text(form_frame, width=50, height=4)
        self.notes_text.grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1
        
        # Next Annual PM Date
        ttk.Label(form_frame, text="Next Annual PM Date:").grid(row=row, column=0, sticky='w', pady=5)
        self.next_annual_pm_var = tk.StringVar()
        ttk.Entry(form_frame, textvariable=self.next_annual_pm_var, width=20).grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1
        
        # Submit and refresh buttons
        buttons_frame = ttk.Frame(form_frame)
        buttons_frame.grid(row=row, column=0, columnspan=2, pady=15)

        ttk.Button(buttons_frame, text="Monthly Summary Report",
           command=self.show_monthly_summary).pack(side='left', padx=5)

        ttk.Button(buttons_frame, text="Submit PM Completion",
                command=self.submit_pm_completion).pack(side='left', padx=5)
        ttk.Button(buttons_frame, text="Refresh List",
                command=self.load_recent_completions).pack(side='left', padx=5)

        ttk.Button(buttons_frame, text="Edit Completed PM",
                command=self.edit_completed_pm).pack(side='left', padx=5)

        ttk.Button(buttons_frame, text="Check Equipment Schedule",
                command=self.create_pm_schedule_lookup_dialog).pack(side='left', padx=5)

        ttk.Button(buttons_frame, text="Create CM from PM",
                command=self.create_cm_from_pm_dialog).pack(side='left', padx=5)
        
        # Recent completions
        recent_frame = ttk.LabelFrame(self.pm_completion_frame, text="Recent PM Completions", padding=10)
        recent_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.recent_completions_tree = ttk.Treeview(recent_frame,
                                                  columns=('Date', 'BFM', 'PM Type', 'Technician', 'Hours'),
                                                  show='headings')
        
        for col in ('Date', 'BFM', 'PM Type', 'Technician', 'Hours'):
            self.recent_completions_tree.heading(col, text=col)
            self.recent_completions_tree.column(col, width=120)
        
        self.recent_completions_tree.pack(fill='both', expand=True)
        self.recent_completions_tree.bind('<Double-1>', self.on_completion_double_click)
        self.recent_completions_tree.bind('<<TreeviewSelect>>', self.on_completion_select)
        
        # Load recent completions
        self.load_recent_completions()
        
        
    def show_equipment_pm_history_dialog(self):
        """Dialog to look up PM history for any equipment"""
        dialog = tk.Toplevel(self.root)
        dialog.title("Equipment PM History Lookup")
        dialog.geometry("400x200")
        dialog.transient(self.root)
        dialog.grab_set()
    
        ttk.Label(dialog, text="Enter BFM Equipment Number:", font=('Arial', 12)).pack(pady=20)
    
        bfm_var = tk.StringVar()
        entry = ttk.Entry(dialog, textvariable=bfm_var, width=20, font=('Arial', 12))
        entry.pack(pady=10)
    
        def lookup_history():
            bfm_no = bfm_var.get().strip()
            if bfm_no:
                dialog.destroy()
                self.show_recent_completions_for_equipment(bfm_no)
            else:
                messagebox.showwarning("Warning", "Please enter a BFM Equipment Number")
    
        button_frame = ttk.Frame(dialog)
        button_frame.pack(pady=20)
    
        ttk.Button(button_frame, text="Show History", command=lookup_history).pack(side='left', padx=10)
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side='left', padx=10)
    
        entry.focus_set()
        entry.bind('<Return>', lambda e: lookup_history())
        
        
    def create_pm_schedule_lookup_dialog(self):
        """Create dialog to lookup PM schedule for specific equipment"""
        dialog = tk.Toplevel(self.root)
        dialog.title("Equipment PM Schedule Lookup")
        dialog.geometry("800x600")
        dialog.transient(self.root)
        dialog.grab_set()
    
        # Search section
        search_frame = ttk.LabelFrame(dialog, text="Equipment Search", padding=15)
        search_frame.pack(fill='x', padx=10, pady=5)
    
        # Equipment search
        ttk.Label(search_frame, text="BFM Equipment Number:", font=('Arial', 10, 'bold')).grid(row=0, column=0, sticky='w', pady=5)
    
        bfm_var = tk.StringVar()
        bfm_entry = ttk.Entry(search_frame, textvariable=bfm_var, width=20, font=('Arial', 11))
        bfm_entry.grid(row=0, column=1, padx=10, pady=5)
    
        # Search button
        search_btn = ttk.Button(search_frame, text="Look Up Schedule", 
                            command=lambda: self.lookup_equipment_pm_schedule(bfm_var.get().strip(), results_frame))
        search_btn.grid(row=0, column=2, padx=10, pady=5)
    
        # Auto-complete functionality
        bfm_entry.bind('<KeyRelease>', lambda e: self.update_equipment_autocomplete(bfm_var, bfm_entry))
    
        # Results display frame
        results_frame = ttk.LabelFrame(dialog, text="PM Schedule Results", padding=10)
        results_frame.pack(fill='both', expand=True, padx=10, pady=5)
    
        # Instructions
        instructions = ttk.Label(results_frame, 
                            text="Enter a BFM Equipment Number above and click 'Look Up Schedule'\nto see current PM status and next scheduled dates.",
                            font=('Arial', 10), foreground='gray')
        instructions.pack(pady=50)
    
        # Focus on entry field
        bfm_entry.focus_set()
        bfm_entry.bind('<Return>', lambda e: search_btn.invoke())

    def update_equipment_autocomplete(self, bfm_var, entry_widget):
        """Provide autocomplete suggestions for equipment numbers"""
        search_term = bfm_var.get()
        if len(search_term) >= 2:
            try:
                cursor = self.conn.cursor()
                cursor.execute('''
                    SELECT bfm_equipment_no FROM equipment 
                    WHERE LOWER(bfm_equipment_no) LIKE LOWER(%s)
                    ORDER BY bfm_equipment_no LIMIT 10
                ''', (f'%{search_term}%',))
            
                suggestions = [row[0] for row in cursor.fetchall()]
            
                # Simple autocomplete - you could enhance this with a dropdown
                if len(suggestions) == 1 and suggestions[0].lower().startswith(search_term.lower()):
                    current_pos = entry_widget.index(tk.INSERT)
                    entry_widget.delete(0, tk.END)
                    entry_widget.insert(0, suggestions[0])
                    entry_widget.icursor(current_pos)
                    entry_widget.select_range(current_pos, tk.END)
                
            except Exception as e:
                print(f"Autocomplete error: {e}")

    def lookup_equipment_pm_schedule(self, bfm_no, parent_frame):
        """Lookup and display PM schedule for specific equipment"""
        if not bfm_no:
            messagebox.showwarning("Warning", "Please enter a BFM Equipment Number")
            return
    
        try:
            cursor = self.conn.cursor()
        
            # Clear previous results
            for widget in parent_frame.winfo_children():
                widget.destroy()
        
            # Get equipment information
            cursor.execute('''
                SELECT sap_material_no, description, location, master_lin, status,
                    monthly_pm, six_month_pm, annual_pm,
                    last_monthly_pm, last_six_month_pm, last_annual_pm,
                    next_monthly_pm, next_six_month_pm, next_annual_pm,
                    updated_date
                FROM equipment 
                WHERE bfm_equipment_no = %s
            ''', (bfm_no,))
        
            equipment_data = cursor.fetchone()
        
            if not equipment_data:
                # Equipment not found
                error_label = ttk.Label(parent_frame, 
                                    text=f"Equipment '{bfm_no}' not found in database",
                                    font=('Arial', 12, 'bold'), foreground='red')
                error_label.pack(pady=20)
                return
        
            # Unpack equipment data
            (sap_no, description, location, master_lin, status,
            monthly_pm, six_month_pm, annual_pm,
            last_monthly, last_six_month, last_annual,
            next_monthly, next_six_month, next_annual,
            updated_date) = equipment_data
        
            # Create scrollable frame for results
            canvas = tk.Canvas(parent_frame)
            scrollbar = ttk.Scrollbar(parent_frame, orient="vertical", command=canvas.yview)
            scrollable_frame = ttk.Frame(canvas)
        
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
        
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
        
            # Equipment header information
            header_frame = ttk.LabelFrame(scrollable_frame, text="Equipment Information", padding=15)
            header_frame.pack(fill='x', padx=5, pady=5)
        
            # Equipment details in a grid
            ttk.Label(header_frame, text="BFM Equipment No:", font=('Arial', 10, 'bold')).grid(row=0, column=0, sticky='w', padx=5, pady=2)
            ttk.Label(header_frame, text=bfm_no, font=('Arial', 10)).grid(row=0, column=1, sticky='w', padx=15, pady=2)
        
            ttk.Label(header_frame, text="SAP Material No:", font=('Arial', 10, 'bold')).grid(row=0, column=2, sticky='w', padx=5, pady=2)
            ttk.Label(header_frame, text=sap_no or 'N/A', font=('Arial', 10)).grid(row=0, column=3, sticky='w', padx=15, pady=2)
        
            ttk.Label(header_frame, text="Description:", font=('Arial', 10, 'bold')).grid(row=1, column=0, sticky='w', padx=5, pady=2)
            desc_text = (description[:50] + '...') if description and len(description) > 50 else (description or 'N/A')
            ttk.Label(header_frame, text=desc_text, font=('Arial', 10)).grid(row=1, column=1, columnspan=3, sticky='w', padx=15, pady=2)
        
            ttk.Label(header_frame, text="Location:", font=('Arial', 10, 'bold')).grid(row=2, column=0, sticky='w', padx=5, pady=2)
            ttk.Label(header_frame, text=location or 'N/A', font=('Arial', 10)).grid(row=2, column=1, sticky='w', padx=15, pady=2)
        
            ttk.Label(header_frame, text="Status:", font=('Arial', 10, 'bold')).grid(row=2, column=2, sticky='w', padx=5, pady=2)
            status_color = 'green' if status == 'Active' else 'red' if status == 'Missing' else 'orange'
            status_label = ttk.Label(header_frame, text=status or 'Active', font=('Arial', 10, 'bold'), foreground=status_color)
            status_label.grid(row=2, column=3, sticky='w', padx=15, pady=2)
        
            # PM Schedule Status
            schedule_frame = ttk.LabelFrame(scrollable_frame, text="PM Schedule Status", padding=15)
            schedule_frame.pack(fill='x', padx=5, pady=5)
        
            # Create PM schedule table
            pm_data = [
                ['PM Type', 'Required', 'Last Completed', 'Next Due', 'Status', 'Days Until Due']
            ]
        
            current_date = datetime.now()
        
            # Monthly PM
            if monthly_pm:
                last_date_str = last_monthly or 'Never'
                next_date_str = next_monthly or 'Not Scheduled'
            
                status_text, days_until = self.calculate_pm_status(last_monthly, next_monthly, 30, current_date)
                pm_data.append(['Monthly', 'Yes', last_date_str, next_date_str, status_text, str(days_until) if days_until is not None else 'N/A'])
            else:
                pm_data.append(['Monthly', 'No', 'N/A', 'N/A', 'Disabled', 'N/A'])
        
            # Six Month PM
            if six_month_pm:
                last_date_str = last_six_month or 'Never'
                next_date_str = next_six_month or 'Not Scheduled'
            
                status_text, days_until = self.calculate_pm_status(last_six_month, next_six_month, 180, current_date)
                pm_data.append(['Six Month', 'Yes', last_date_str, next_date_str, status_text, str(days_until) if days_until is not None else 'N/A'])
            else:
                pm_data.append(['Six Month', 'No', 'N/A', 'N/A', 'Disabled', 'N/A'])
        
            # Annual PM
            if annual_pm:
                last_date_str = last_annual or 'Never'
                next_date_str = next_annual or 'Not Scheduled'
            
                status_text, days_until = self.calculate_pm_status(last_annual, next_annual, 365, current_date)
                pm_data.append(['Annual', 'Yes', last_date_str, next_date_str, status_text, str(days_until) if days_until is not None else 'N/A'])
            else:
                pm_data.append(['Annual', 'No', 'N/A', 'N/A', 'Disabled', 'N/A'])
        
            # Create table display
            for i, row_data in enumerate(pm_data):
                row_frame = ttk.Frame(schedule_frame)
                row_frame.pack(fill='x', pady=1)
            
                for j, cell_data in enumerate(row_data):
                    if i == 0:  # Header row
                        label = ttk.Label(row_frame, text=cell_data, font=('Arial', 10, 'bold'), 
                                        relief='raised', padding=5, width=15)
                    else:  # Data rows
                        # Color code the status column
                        if j == 4:  # Status column
                            if 'Overdue' in cell_data:
                                color = 'red'
                            elif 'Due Soon' in cell_data:
                                color = 'orange'  
                            elif 'Current' in cell_data:
                                color = 'green'
                            else:
                                color = 'gray'
                            label = ttk.Label(row_frame, text=cell_data, font=('Arial', 10, 'bold'), 
                                            foreground=color, padding=3, width=15)
                        else:
                            label = ttk.Label(row_frame, text=cell_data, font=('Arial', 10), 
                                            padding=3, width=15)
                    
                    label.pack(side='left', padx=2)
        
            # Recent PM History
            history_frame = ttk.LabelFrame(scrollable_frame, text="Recent PM History (Last 10)", padding=15)
            history_frame.pack(fill='x', padx=5, pady=5)
        
            cursor.execute('''
                SELECT pm_type, technician_name, completion_date, 
                    (labor_hours + labor_minutes/60.0) as total_hours,
                    SUBSTR(notes, 1, 50) as notes_preview
                FROM pm_completions 
                WHERE bfm_equipment_no = %s
                ORDER BY completion_date DESC LIMIT 10
            ''', (bfm_no,))
        
            recent_completions = cursor.fetchall()
        
            if recent_completions:
                # History table
                history_data = [['Date', 'PM Type', 'Technician', 'Hours', 'Notes']]
            
                for completion in recent_completions:
                    pm_type, technician, comp_date, hours, notes_preview = completion
                    hours_str = f"{hours:.1f}h" if hours else '0h'
                    notes_str = (notes_preview + '...') if notes_preview and len(notes_preview) >= 50 else (notes_preview or '')
                    history_data.append([comp_date, pm_type, technician, hours_str, notes_str])
            
                for i, row_data in enumerate(history_data):
                    row_frame = ttk.Frame(history_frame)
                    row_frame.pack(fill='x', pady=1)
                
                    for j, cell_data in enumerate(row_data):
                        if i == 0:  # Header row
                            width = [10, 10, 15, 8, 25][j]  # Different widths for each column
                            label = ttk.Label(row_frame, text=cell_data, font=('Arial', 10, 'bold'), 
                                        relief='raised', padding=5, width=width)
                        else:
                            width = [10, 10, 15, 8, 25][j]
                            label = ttk.Label(row_frame, text=cell_data, font=('Arial', 9), 
                                            padding=3, width=width)
                    
                        label.pack(side='left', padx=2)
            else:
                no_history_label = ttk.Label(history_frame, text="No PM completions found for this equipment", 
                                        font=('Arial', 10), foreground='gray')
                no_history_label.pack(pady=10)
        
            # Upcoming schedule (if any)
            upcoming_frame = ttk.LabelFrame(scrollable_frame, text="Upcoming Weekly Schedules", padding=15)
            upcoming_frame.pack(fill='x', padx=5, pady=5)
        
            cursor.execute('''
                SELECT pm_type, assigned_technician, scheduled_date, week_start_date, status
                FROM weekly_pm_schedules
                WHERE bfm_equipment_no = %s AND scheduled_date::date >= CURRENT_DATE
                ORDER BY scheduled_date ASC LIMIT 5
            ''', (bfm_no,))
        
            upcoming_schedules = cursor.fetchall()
        
            if upcoming_schedules:
                upcoming_data = [['PM Type', 'Assigned To', 'Scheduled Date', 'Week Start', 'Status']]
            
                for schedule in upcoming_schedules:
                    pm_type, technician, sched_date, week_start, sched_status = schedule
                    upcoming_data.append([pm_type, technician, sched_date, week_start, sched_status])
            
                for i, row_data in enumerate(upcoming_data):
                    row_frame = ttk.Frame(upcoming_frame)
                    row_frame.pack(fill='x', pady=1)
                
                    for j, cell_data in enumerate(row_data):
                        if i == 0:  # Header row
                            label = ttk.Label(row_frame, text=cell_data, font=('Arial', 10, 'bold'), 
                                            relief='raised', padding=5, width=12)
                        else:
                            label = ttk.Label(row_frame, text=cell_data, font=('Arial', 10), 
                                            padding=3, width=12)
                    
                        label.pack(side='left', padx=2)
            else:
                no_upcoming_label = ttk.Label(upcoming_frame, text="No upcoming scheduled PMs found", 
                                            font=('Arial', 10), foreground='gray')
                no_upcoming_label.pack(pady=10)
        
            # Pack the canvas and scrollbar
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
        
            # Update scroll region
            scrollable_frame.update_idletasks()
            canvas.configure(scrollregion=canvas.bbox("all"))
        
        except Exception as e:
            error_label = ttk.Label(parent_frame, 
                                text=f"Error looking up equipment: {str(e)}", 
                                font=('Arial', 10), foreground='red')
            error_label.pack(pady=20)
            print(f"PM Schedule lookup error: {e}")

    def calculate_pm_status(self, last_pm_date, next_pm_date, frequency_days, current_date):
        """Calculate PM status and days until due"""
        try:
            if not last_pm_date and not next_pm_date:
                return "Never Done", None
        
            # Use next_pm_date if available, otherwise calculate from last_pm_date
            if next_pm_date:
                next_due = datetime.strptime(next_pm_date, '%Y-%m-%d')
            elif last_pm_date:
                last_date = datetime.strptime(last_pm_date, '%Y-%m-%d')
                next_due = last_date + timedelta(days=frequency_days)
            else:
                return "Not Scheduled", None
        
            days_until = (next_due - current_date).days
        
            if days_until < 0:
                return f"Overdue ({abs(days_until)} days)", days_until
            elif days_until <= 7:
                return f"Due Soon ({days_until} days)", days_until
            elif days_until <= 30:
                return f"Due in {days_until} days", days_until
            else:
                return f"Current ({days_until} days)", days_until
            
        except ValueError:
            return "Date Error", None
        except Exception as e:
            return "Error", None
           
    

    def export_monthly_data(self, month_var, year_var):
        """Export monthly completion data to CSV"""
        try:
            # Parse month and year
            month_text = month_var.get()
            month_num = month_text.split(' - ')[0] if month_text else f"{datetime.now().month:02d}"
            year = year_var.get() or str(datetime.now().year)
            month_name = calendar.month_name[int(month_num)]
        
            # Get file path
            filename = filedialog.asksaveasfilename(
            title="Export Monthly PM Completions",
            defaultextension=".csv",
            initialname=f"PM_Completions_{month_name}_{year}.csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
            )
        
            if filename:
                # Calculate date range
                start_date = f"{year}-{month_num}-01"
                year_int = int(year)
                month_int = int(month_num)
                if month_int == 12:
                    next_month = 1
                    next_year = year_int + 1
                else:
                    next_month = month_int + 1
                    next_year = year_int
                end_date = (datetime(next_year, next_month, 1) - timedelta(days=1)).strftime('%Y-%m-%d')
            
                cursor = self.conn.cursor()
            
                # Get all completion data
                cursor.execute('''
                    SELECT 
                        pc.completion_date,
                        pc.bfm_equipment_no,
                        e.sap_material_no,
                        e.description,
                        e.location,
                        pc.pm_type,
                        pc.technician_name,
                        pc.labor_hours,
                        pc.labor_minutes,
                        (pc.labor_hours + pc.labor_minutes/60.0) as total_hours,
                        pc.special_equipment,
                        pc.notes,
                        pc.pm_due_date,
                        pc.next_annual_pm_date
                    FROM pm_completions pc
                    LEFT JOIN equipment e ON pc.bfm_equipment_no = e.bfm_equipment_no
                    WHERE pc.completion_date BETWEEN %s AND %s
                    UNION ALL
                    SELECT 
                        cf.reported_date,
                        cf.bfm_equipment_no,
                        '' as sap_material_no,
                        cf.description,
                        cf.location,
                        'CANNOT FIND' as pm_type,
                        cf.technician_name,
                        0 as labor_hours,
                        0 as labor_minutes,
                        0 as total_hours,
                        '' as special_equipment,
                        cf.notes,
                        '' as pm_due_date,
                        '' as next_annual_pm_date
                    FROM cannot_find_assets cf
                    WHERE cf.reported_date BETWEEN %s AND %s
                    ORDER BY completion_date DESC
                ''', (start_date, end_date, start_date, end_date))
            
                data = cursor.fetchall()
            
                # Create DataFrame
                columns = [
                    'Completion Date', 'BFM Equipment No', 'SAP Material No', 
                    'Equipment Description', 'Location', 'PM Type', 'Technician', 
                    'Labor Hours', 'Labor Minutes', 'Total Hours', 'Special Equipment', 
                    'Notes', 'PM Due Date', 'Next Annual PM Date'
                ]
            
                df = pd.DataFrame(data, columns=columns)
                df.to_csv(filename, index=False)
            
                messagebox.showinfo("Success", f"Monthly data exported to: {filename}")
            
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export monthly data: {str(e)}")   
    
    def on_completion_double_click(self, event):
        """Handle double-click on recent PM completions to generate PDF"""
        selection = self.recent_completions_tree.selection()
        if not selection:
            return
    
        # Get the selected item's values
        item = self.recent_completions_tree.item(selection[0])
        values = item['values']
    
        if len(values) >= 5:
            completion_date = values[0]
            bfm_no = values[1] 
            pm_type = values[2]
            technician = values[3]
        
            # Get full completion details from database
            self.generate_pm_completion_pdf(completion_date, bfm_no, pm_type, technician)

    def on_completion_select(self, event):
        """Handle single-click on recent PM completions to populate form fields"""
        selection = self.recent_completions_tree.selection()
        if not selection:
            return

        # Get the selected item's values
        item = self.recent_completions_tree.item(selection[0])
        values = item['values']

        if len(values) >= 5:
            completion_date = values[0]
            bfm_no = values[1]
            pm_type = values[2]
            technician = values[3]

            # Populate the form fields with the selected completion data
            self.completion_bfm_var.set(bfm_no)
            self.pm_type_var.set(pm_type)
            self.completion_tech_var.set(technician)

            # Update status bar to confirm selection
            if hasattr(self, 'update_status'):
                self.update_status(f"Selected equipment {bfm_no} from recent completions")

    def edit_completed_pm(self):
        """Edit a selected completed PM/OM from the recent completions list"""
        selection = self.recent_completions_tree.selection()
        if not selection:
            messagebox.showwarning("Warning", "Please select a completed PM to edit")
            return

        # Get the selected item's values
        item = self.recent_completions_tree.item(selection[0])
        values = item['values']

        if len(values) < 5:
            messagebox.showerror("Error", "Invalid selection")
            return

        completion_date = values[0]
        bfm_no = values[1]
        pm_type = values[2]
        technician = values[3]

        try:
            cursor = self.conn.cursor()

            # Get full completion details from database
            cursor.execute('''
                SELECT pc.*, e.sap_material_no, e.description, e.location
                FROM pm_completions pc
                LEFT JOIN equipment e ON pc.bfm_equipment_no = e.bfm_equipment_no
                WHERE pc.completion_date = %s AND pc.bfm_equipment_no = %s
                AND pc.pm_type = %s AND pc.technician_name = %s
            ''', (str(completion_date), str(bfm_no), str(pm_type), str(technician)))

            completion_data = cursor.fetchone()

            if not completion_data:
                messagebox.showerror("Error", "Could not find completion details")
                return

            # Extract data fields
            completion_id = completion_data[0]
            bfm_no = completion_data[1]
            pm_type = completion_data[2]
            technician_name = completion_data[3]
            completion_date = completion_data[4]
            labor_hours = completion_data[5] or 0.0
            labor_minutes = completion_data[6] or 0.0
            pm_due_date = completion_data[7] or ''
            special_equipment = completion_data[8] or ''
            notes = completion_data[9] or ''
            next_annual_pm_date = completion_data[10] or ''
            description = completion_data[15] if len(completion_data) > 15 else ''
            location = completion_data[16] if len(completion_data) > 16 else ''

            # Create edit dialog
            edit_dialog = tk.Toplevel(self.root)
            edit_dialog.title(f"Edit Completed PM - {bfm_no}")
            edit_dialog.geometry("600x700")
            edit_dialog.transient(self.root)
            edit_dialog.grab_set()

            # Create main frame with scrollbar
            main_frame = ttk.Frame(edit_dialog, padding=15)
            main_frame.pack(fill='both', expand=True)

            # Equipment info (read-only display)
            info_frame = ttk.LabelFrame(main_frame, text="Equipment Information", padding=10)
            info_frame.pack(fill='x', pady=5)

            ttk.Label(info_frame, text=f"BFM: {bfm_no}", font=('Arial', 10, 'bold')).pack(anchor='w')
            ttk.Label(info_frame, text=f"Description: {description}").pack(anchor='w')
            ttk.Label(info_frame, text=f"Location: {location}").pack(anchor='w')

            # Editable fields frame
            fields_frame = ttk.LabelFrame(main_frame, text="Edit PM Details", padding=10)
            fields_frame.pack(fill='both', expand=True, pady=10)

            row = 0

            # PM Type
            ttk.Label(fields_frame, text="PM Type:").grid(row=row, column=0, sticky='w', pady=5)
            pm_type_var = tk.StringVar(value=pm_type)
            pm_type_combo = ttk.Combobox(fields_frame, textvariable=pm_type_var,
                                       values=['Weekly', 'Monthly', 'Six Month', 'Annual'],
                                       width=20, state='readonly')
            pm_type_combo.grid(row=row, column=1, sticky='w', padx=5, pady=5)
            row += 1

            # Technician
            ttk.Label(fields_frame, text="Technician:").grid(row=row, column=0, sticky='w', pady=5)
            tech_var = tk.StringVar(value=technician_name)
            tech_combo = ttk.Combobox(fields_frame, textvariable=tech_var,
                                    values=self.technicians, width=20)
            tech_combo.grid(row=row, column=1, sticky='w', padx=5, pady=5)
            row += 1

            # Completion Date
            ttk.Label(fields_frame, text="Completion Date (YYYY-MM-DD):").grid(row=row, column=0, sticky='w', pady=5)
            completion_date_var = tk.StringVar(value=str(completion_date))
            ttk.Entry(fields_frame, textvariable=completion_date_var, width=20).grid(row=row, column=1, sticky='w', padx=5, pady=5)
            row += 1

            # Labor Hours
            ttk.Label(fields_frame, text="Labor Hours:").grid(row=row, column=0, sticky='w', pady=5)
            hours_var = tk.StringVar(value=str(int(labor_hours)))
            ttk.Entry(fields_frame, textvariable=hours_var, width=10).grid(row=row, column=1, sticky='w', padx=5, pady=5)
            row += 1

            # Labor Minutes
            ttk.Label(fields_frame, text="Labor Minutes:").grid(row=row, column=0, sticky='w', pady=5)
            minutes_var = tk.StringVar(value=str(int(labor_minutes)))
            ttk.Entry(fields_frame, textvariable=minutes_var, width=10).grid(row=row, column=1, sticky='w', padx=5, pady=5)
            row += 1

            # PM Due Date
            ttk.Label(fields_frame, text="PM Due Date (YYYY-MM-DD):").grid(row=row, column=0, sticky='w', pady=5)
            pm_due_var = tk.StringVar(value=str(pm_due_date))
            ttk.Entry(fields_frame, textvariable=pm_due_var, width=20).grid(row=row, column=1, sticky='w', padx=5, pady=5)
            row += 1

            # Special Equipment
            ttk.Label(fields_frame, text="Special Equipment:").grid(row=row, column=0, sticky='w', pady=5)
            special_eq_var = tk.StringVar(value=special_equipment)
            ttk.Entry(fields_frame, textvariable=special_eq_var, width=40).grid(row=row, column=1, sticky='w', padx=5, pady=5)
            row += 1

            # Notes
            ttk.Label(fields_frame, text="Notes:").grid(row=row, column=0, sticky='nw', pady=5)
            notes_text = tk.Text(fields_frame, width=40, height=6)
            notes_text.insert('1.0', notes)
            notes_text.grid(row=row, column=1, sticky='w', padx=5, pady=5)
            row += 1

            # Next Annual PM Date
            ttk.Label(fields_frame, text="Next Annual PM Date (YYYY-MM-DD):").grid(row=row, column=0, sticky='w', pady=5)
            next_annual_var = tk.StringVar(value=str(next_annual_pm_date))
            ttk.Entry(fields_frame, textvariable=next_annual_var, width=20).grid(row=row, column=1, sticky='w', padx=5, pady=5)
            row += 1

            def save_changes():
                """Save the edited PM completion"""
                try:
                    # Validate required fields
                    if not pm_type_var.get() or not tech_var.get() or not completion_date_var.get():
                        messagebox.showerror("Error", "Please fill in all required fields")
                        return

                    # Get values
                    new_pm_type = pm_type_var.get()
                    new_technician = tech_var.get()
                    new_completion_date = completion_date_var.get().strip()
                    new_labor_hours = float(hours_var.get() or 0)
                    new_labor_minutes = float(minutes_var.get() or 0)
                    new_pm_due_date = pm_due_var.get().strip()
                    new_special_equipment = special_eq_var.get().strip()
                    new_notes = notes_text.get('1.0', 'end-1c')
                    new_next_annual_pm = next_annual_var.get().strip()

                    # Update the database
                    update_cursor = self.conn.cursor()
                    update_cursor.execute('''
                        UPDATE pm_completions
                        SET pm_type = %s,
                            technician_name = %s,
                            completion_date = %s,
                            labor_hours = %s,
                            labor_minutes = %s,
                            pm_due_date = %s,
                            special_equipment = %s,
                            notes = %s,
                            next_annual_pm_date = %s,
                            updated_date = CURRENT_TIMESTAMP
                        WHERE id = %s
                    ''', (new_pm_type, new_technician, new_completion_date,
                         new_labor_hours, new_labor_minutes, new_pm_due_date,
                         new_special_equipment, new_notes, new_next_annual_pm,
                         completion_id))

                    self.conn.commit()

                    messagebox.showinfo("Success", "PM completion updated successfully!")
                    edit_dialog.destroy()

                    # Refresh the recent completions list
                    self.load_recent_completions()

                    if hasattr(self, 'update_status'):
                        self.update_status(f"Updated PM completion for {bfm_no}")

                except Exception as e:
                    self.conn.rollback()
                    messagebox.showerror("Error", f"Failed to update PM completion: {str(e)}")

            # Buttons frame
            buttons_frame = ttk.Frame(main_frame)
            buttons_frame.pack(fill='x', pady=10)

            ttk.Button(buttons_frame, text="Save Changes", command=save_changes).pack(side='left', padx=5)
            ttk.Button(buttons_frame, text="Cancel", command=edit_dialog.destroy).pack(side='left', padx=5)

        except Exception as e:
            messagebox.showerror("Error", f"Failed to load PM details: {str(e)}")

    def generate_pm_completion_pdf(self, completion_date, bfm_no, pm_type, technician):
        """Generate and export PM completion PDF document"""
        try:
            cursor = self.conn.cursor()

            # Ensure all values are strings to avoid type mismatch errors
            completion_date_str = str(completion_date) if completion_date is not None else ''
            bfm_no_str = str(bfm_no) if bfm_no is not None else ''
            pm_type_str = str(pm_type) if pm_type is not None else ''
            technician_str = str(technician) if technician is not None else ''

            # Get full completion details
            cursor.execute('''
                SELECT pc.*, e.sap_material_no, e.description, e.location
                FROM pm_completions pc
                LEFT JOIN equipment e ON pc.bfm_equipment_no = e.bfm_equipment_no
                WHERE pc.completion_date = %s AND pc.bfm_equipment_no = %s
                AND pc.pm_type = %s AND pc.technician_name = %s
            ''', (completion_date_str, bfm_no_str, pm_type_str, technician_str))
        
            completion_data = cursor.fetchone()
        
            if not completion_data:
                messagebox.showerror("Error", "Could not find completion details")
                return
            
            # Add just the title parameter
            filename = filedialog.asksaveasfilename(
                title="Save PM Completion Document"
            )
        
            if filename:
                self.create_pm_completion_pdf(completion_data, filename)
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to generate PDF: {str(e)}")

    def create_pm_completion_pdf(self, completion_data, filename):
        """Create the actual PDF document"""
        try:
            # Based on the debug output, map the columns correctly:
            # (538, '20243111', 'Annual', 'Ronald Houghs', '2025-9-19', 0.0, 30.0, '2025-9-19', '', '', '2026-09-10', 'Preventive_Maintenance_Form', 'A2', '2025-09-22 11:31:50', '96007107', 'DRILL TEMPLATE FOR STRINGER SPLICE FR30', 'LCS001 TOP')
        
            completion_id = completion_data[0]        # 538
            bfm_no = completion_data[1]               # '20243111'
            pm_type = completion_data[2]              # 'Annual'
            technician_name = completion_data[3]      # 'Ronald Houghs'
            completion_date = completion_data[4]      # '2025-9-19'
            labor_hours = completion_data[5]          # 0.0
            labor_minutes = completion_data[6]        # 30.0
            pm_due_date = completion_data[7]          # '2025-9-19'
            special_equipment = completion_data[8]    # ''
            notes = completion_data[9]                # ''
            next_annual_pm_date = completion_data[10] # '2026-09-10'
            # Skip column 11 and 12 (appears to be form type and status)
            updated_date = completion_data[13]        # '2025-09-22 11:31:50'
            sap_material_no = completion_data[14]     # '96007107'
            description = completion_data[15]         # 'DRILL TEMPLATE FOR STRINGER SPLICE FR30'
            location = completion_data[16]            # 'LCS001 TOP'
        
            # Create PDF document
            doc = SimpleDocTemplate(filename, pagesize=letter)
            styles = getSampleStyleSheet()
            story = []
        
            # Custom styles
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=18,
                spaceAfter=30,
                alignment=1,  # Center alignment
                textColor=colors.darkblue
            )
        
            header_style = ParagraphStyle(
                'CustomHeader',
                parent=styles['Heading2'],
                fontSize=14,
                spaceAfter=12,
                textColor=colors.darkblue
            )
        
            # Add company logo if available
            script_dir = os.path.dirname(os.path.abspath(__file__))
            logo_path = os.path.join(script_dir, "img", "ait_logo.png")

            if os.path.exists(logo_path):
                logo = Image(logo_path, width=2*inch, height=1*inch)
                story.append(logo)
                story.append(Spacer(1, 12))
            else:
                print(f"Logo not found at: {logo_path}")
                # Fallback to text header
                story.append(Paragraph("AIT - BUILDING THE FUTURE OF AEROSPACE", title_style))
                story.append(Spacer(1, 12))
            
        
            # Title
            story.append(Paragraph("PM COMPLETION CERTIFICATE", title_style))
            story.append(Spacer(1, 20))
        
            # Equipment Information Section
            story.append(Paragraph("EQUIPMENT INFORMATION", header_style))
            
            equipment_info = f"""
            <b>BFM Equipment Number:</b> {bfm_no}<br/>
            <b>SAP Material Number:</b> {sap_material_no or 'N/A'}<br/>
            <b>Equipment Description:</b> {description or 'N/A'}<br/>
            <b>Location:</b> {location or 'N/A'}<br/>
            """
            story.append(Paragraph(equipment_info, styles['Normal']))
            story.append(Spacer(1, 20))
        
            # PM Details Section
            story.append(Paragraph("MAINTENANCE DETAILS", header_style))
            
            pm_details = f"""
            <b>PM Type:</b> {pm_type}<br/>
            <b>Completion Date:</b> {completion_date}<br/>
            <b>Technician:</b> {technician_name}<br/>
            <b>Labor Time:</b> {int(labor_hours)}h {int(labor_minutes)}m<br/>
            <b>Special Equipment Used:</b> {special_equipment or 'None'}<br/>
            <b>Next Annual PM Due:</b> {next_annual_pm_date or 'Not scheduled'}<br/>
            """
            story.append(Paragraph(pm_details, styles['Normal']))
            story.append(Spacer(1, 20))
            
            # Technician Notes Section
            story.append(Paragraph("TECHNICIAN VALIDATION", header_style))
            
            validation_text = f"""
            <b>Equipment Status Validation:</b><br/>
            The undersigned technician certifies that the preventive maintenance has been completed 
            and no equipment problems were identified during the maintenance procedure.
            <br/><br/>
            <b>Technician Notes:</b><br/>
            {notes or 'No issues reported. Equipment operating within normal parameters.'}
            """
            story.append(Paragraph(validation_text, styles['Normal']))
            story.append(Spacer(1, 30))
        
            # Footer
            story.append(Spacer(1, 30))
            footer_text = f"""
            <i>Document generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}<br/>
            AIT Complete CMMS - Computerized Maintenance Management System</i>
            """
            story.append(Paragraph(footer_text, styles['Normal']))
        
            # Build the PDF
            doc.build(story)
        
            messagebox.showinfo("Success", f"PM Completion document saved to:\n{filename}")
        
            # Ask if user wants to open the PDF
            if messagebox.askyesno("Open Document", "Would you like to open the PDF document now?"):
                os.startfile(filename)  # Windows
            
        except Exception as e:
            messagebox.showerror("PDF Creation Error", f"Failed to create PDF: {str(e)}")
            print(f"Full error: {e}")
    
    def create_cannot_find_tab(self):
        """Cannot Find Assets tab with search functionality"""
        self.cannot_find_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.cannot_find_frame, text="Cannot Find Assets")

        # Controls
        controls_frame = ttk.LabelFrame(self.cannot_find_frame, text="Cannot Find Controls", padding=10)
        controls_frame.pack(fill='x', padx=10, pady=5)

        # Add Asset button
        ttk.Button(controls_frame, text="Add Asset", 
                command=self.add_cannot_find_asset_dialog,
                style='Accent.TButton').pack(side='left', padx=5)
    
        ttk.Button(controls_frame, text="Refresh List", 
                command=self.load_cannot_find_assets).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Export to PDF", 
                command=self.export_cannot_find_pdf).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Mark as Found", 
                command=self.mark_asset_found).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Delete Asset", 
            command=self.delete_cannot_find_asset).pack(side='left', padx=5)        
        ttk.Button(controls_frame, text="Edit Asset", 
            command=self.edit_cannot_find_asset).pack(side='left', padx=5)
    
        # Search frame - NEW!
        search_frame = ttk.Frame(controls_frame)
        search_frame.pack(side='right', padx=5)
        
        ttk.Label(search_frame, text="Search:").pack(side='left', padx=(10, 5))
        self.cannot_find_search_var = tk.StringVar()
        self.cannot_find_search_var.trace('w', lambda *args: self.filter_cannot_find_assets())
        
        search_entry = ttk.Entry(search_frame, textvariable=self.cannot_find_search_var, width=25)
        search_entry.pack(side='left', padx=5)
        
        # Clear search button
        ttk.Button(search_frame, text="X", width=3,
                command=lambda: self.cannot_find_search_var.set('')).pack(side='left', padx=2)

        # Cannot Find list
        list_frame = ttk.LabelFrame(self.cannot_find_frame, text="Missing Assets", padding=10)
        list_frame.pack(fill='both', expand=True, padx=10, pady=5)

        self.cannot_find_tree = ttk.Treeview(list_frame,
                                        columns=('BFM', 'Description', 'Location', 'Technician', 'Report Date', 'Status'),
                                        show='headings')

        columns_config = {
            'BFM': ('BFM Equipment No.', 130),
            'Description': ('Description', 250),
            'Location': ('Location', 120),
            'Technician': ('Reported By', 120),
            'Report Date': ('Report Date', 100),
            'Status': ('Status', 80)
        }

        for col, (heading, width) in columns_config.items():
            self.cannot_find_tree.heading(col, text=heading)
            self.cannot_find_tree.column(col, width=width)

        # Scrollbars
        cf_v_scrollbar = ttk.Scrollbar(list_frame, orient='vertical', command=self.cannot_find_tree.yview)
        cf_h_scrollbar = ttk.Scrollbar(list_frame, orient='horizontal', command=self.cannot_find_tree.xview)
        self.cannot_find_tree.configure(yscrollcommand=cf_v_scrollbar.set, xscrollcommand=cf_h_scrollbar.set)

        # Pack treeview and scrollbars
        self.cannot_find_tree.grid(row=0, column=0, sticky='nsew')
        cf_v_scrollbar.grid(row=0, column=1, sticky='ns')
        cf_h_scrollbar.grid(row=1, column=0, sticky='ew')

        list_frame.grid_rowconfigure(0, weight=1)
        list_frame.grid_columnconfigure(0, weight=1)

        # Load initial data
        self.load_cannot_find_assets()
    
    
    
    def delete_cannot_find_asset(self):
        """Remove asset from Cannot Find list and move to Deactivated list"""
        # Get selected item
        selected_item = self.cannot_find_tree.selection()

        if not selected_item:
            messagebox.showwarning("No Selection", "Please select an asset to delete.")
            return

        # Get the selected item data
        item = selected_item[0]
        asset_data = self.cannot_find_tree.item(item)['values']
        bfm_number = str(asset_data[0])  # BFM is the first column - convert to string for SQL query
        description = asset_data[1] if len(asset_data) > 1 else ''

        # Confirm moving to deactivated
        result = messagebox.askyesno(
            "Move to Deactivated List",
            f"Remove asset {bfm_number} from Cannot Find list and move to Deactivated?\n\n"
            f"Description: {description}\n\n"
            "The asset will be removed from Cannot Find and added to Deactivated.\n"
            "It will NOT be included in PM cycles."
        )

        if result:
            try:
                cursor = self.conn.cursor()

                # Get full asset data from cannot_find_assets before deleting
                cursor.execute('''
                    SELECT bfm_equipment_no, description, location, technician_name, reported_date, notes
                    FROM cannot_find_assets
                    WHERE bfm_equipment_no = %s
                ''', (bfm_number,))

                asset_info = cursor.fetchone()
                if asset_info:
                    cf_bfm, cf_desc, cf_location, cf_tech, cf_date, cf_notes = asset_info
                else:
                    cf_bfm = bfm_number
                    cf_desc = description
                    cf_location = ''
                    cf_tech = ''
                    cf_date = ''
                    cf_notes = ''

                # Delete from cannot_find_assets table
                cursor.execute('DELETE FROM cannot_find_assets WHERE bfm_equipment_no = %s', (bfm_number,))

                # Get current date
                from datetime import datetime
                current_date = datetime.now().strftime("%Y-%m-%d")

                # Add to deactivated_assets table
                cursor.execute('''
                    INSERT INTO deactivated_assets
                    (bfm_equipment_no, description, location, deactivated_by, deactivated_date, reason, status, notes)
                    VALUES (%s, %s, %s, %s, %s, %s, 'Deactivated', %s)
                    ON CONFLICT (bfm_equipment_no)
                    DO UPDATE SET
                        description = EXCLUDED.description,
                        location = EXCLUDED.location,
                        deactivated_by = EXCLUDED.deactivated_by,
                        deactivated_date = EXCLUDED.deactivated_date,
                        reason = EXCLUDED.reason,
                        status = EXCLUDED.status,
                        notes = EXCLUDED.notes
                ''', (
                    cf_bfm,
                    cf_desc,
                    cf_location,
                    cf_tech if cf_tech else 'System',
                    current_date,
                    f'Removed from Cannot Find list (originally reported: {cf_date})',
                    cf_notes if cf_notes else 'Moved from Cannot Find list'
                ))

                # Update the equipment table status to Deactivated
                cursor.execute('''
                    UPDATE equipment
                    SET status = 'Deactivated'
                    WHERE bfm_equipment_no = %s
                ''', (bfm_number,))

                # Commit the changes
                self.conn.commit()

                # Remove from treeview display
                self.cannot_find_tree.delete(item)

                # Update statistics if method exists
                if hasattr(self, 'update_equipment_statistics'):
                    self.update_equipment_statistics()

                # Refresh deactivated tab if it exists
                if hasattr(self, 'load_deactivated_assets'):
                    self.load_deactivated_assets()

                messagebox.showinfo("Success", f"Asset {bfm_number} has been moved from Cannot Find to Deactivated list.")

            except Exception as e:
                self.conn.rollback()  # Rollback changes if there's an error
                messagebox.showerror("Error", f"Failed to move asset: {str(e)}")
                print(f"Delete error details: {e}")


    def delete_from_database(self, bfm_number):
        """Delete asset record from database"""
        # Example using SQLite
        try:
            cursor = self.connection.cursor()
            cursor.execute("DELETE FROM cannot_find_assets WHERE bfm_number = %s", (bfm_number,))
            self.connection.commit()
        except Exception as e:
            raise Exception(f"Database error: {str(e)}")



    def edit_cannot_find_asset(self):
        """Edit selected asset from cannot find list"""
        # Get selected item
        selected_item = self.cannot_find_tree.selection()
    
        if not selected_item:
            messagebox.showwarning("No Selection", "Please select an asset to edit.")
            return
    
        # Get the selected item data
        item = selected_item[0]
        asset_data = self.cannot_find_tree.item(item)['values']
        
        # Open edit window
        self.open_edit_window(item, asset_data)


    def open_edit_window(self, tree_item, asset_data):
        """Open edit window for selected asset"""
        # Create edit window
        edit_window = tk.Toplevel(self.root)
        edit_window.title("Edit Asset")
        edit_window.geometry("500x400")
        edit_window.resizable(True, True)
    
        # Make window modal
        edit_window.transient(self.root)
        edit_window.grab_set()
    
        # Center the window
        edit_window.update_idletasks()
        x = (edit_window.winfo_screenwidth() // 2) - (500 // 2)
        y = (edit_window.winfo_screenheight() // 2) - (400 // 2)
        edit_window.geometry(f"500x400+{x}+{y}")
    
        # Create main frame with padding
        main_frame = ttk.Frame(edit_window, padding=20)
        main_frame.pack(fill='both', expand=True)
    
        # Title
        title_label = ttk.Label(main_frame, text="Edit Asset Information", 
                            font=('TkDefaultFont', 12, 'bold'))
        title_label.pack(pady=(0, 20))
    
        # Create form frame
        form_frame = ttk.Frame(main_frame)
        form_frame.pack(fill='both', expand=True)
    
        # Field labels and entry variables
        fields = [
            ('BFM Equipment No.', asset_data[0] if len(asset_data) > 0 else ''),
            ('Description', asset_data[1] if len(asset_data) > 1 else ''),
            ('Location', asset_data[2] if len(asset_data) > 2 else ''),
            ('Technician', asset_data[3] if len(asset_data) > 3 else ''),
            ('Report Date', asset_data[4] if len(asset_data) > 4 else ''),
            ('Status', asset_data[5] if len(asset_data) > 5 else '')
        ]
    
        # Store entry widgets for later access
        entries = {}
    
        # Create form fields
        for i, (label_text, value) in enumerate(fields):
            # Label
            label = ttk.Label(form_frame, text=label_text + ":")
            label.grid(row=i, column=0, sticky='w', padx=(0, 10), pady=5)
        
            # Entry widget
            if label_text == 'Status':
                # Use combobox for status
                entry = ttk.Combobox(form_frame, values=['Missing', 'Found', 'Damaged', 'Disposed'])
                entry.set(value)
            elif label_text == 'Description':
                # Use text widget for description (multiline)
                entry = tk.Text(form_frame, height=3, width=40)
                entry.insert('1.0', value)
            else:
                entry = ttk.Entry(form_frame, width=40)
                entry.insert(0, value)
        
            entry.grid(row=i, column=1, sticky='ew', pady=5)
            entries[label_text] = entry
    
        # Configure grid weights
        form_frame.grid_columnconfigure(1, weight=1)
    
        # Button frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill='x', pady=(20, 0))
    
        # Buttons
        def save_changes():
            """Save the edited data"""
            try:
                # Get updated values
                updated_data = []
                for field_name, _ in fields:
                    entry_widget = entries[field_name]
                    if isinstance(entry_widget, tk.Text):
                        value = entry_widget.get('1.0', 'end-1c')  # Get text content
                    else:
                        value = entry_widget.get()
                    updated_data.append(value)

                # Validate required fields
                if not updated_data[0].strip():  # BFM number is required
                    messagebox.showerror("Validation Error", "BFM Equipment No. is required.")
                    return

                # Update database
                self.update_asset_in_database(updated_data)

                # Reload the cannot find assets list to show updated data from database
                self.load_cannot_find_assets()

                # Show success message
                messagebox.showinfo("Success", "Asset information updated successfully in database.")

                # Close edit window
                edit_window.destroy()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to update asset: {str(e)}")
    
        def cancel_edit():
            """Cancel editing and close window"""
            edit_window.destroy()
    
        # Save and Cancel buttons
        ttk.Button(button_frame, text="Save Changes", 
                command=save_changes).pack(side='right', padx=(5, 0))
        ttk.Button(button_frame, text="Cancel", 
                command=cancel_edit).pack(side='right')
    
        # Focus on first entry
        if fields:
            first_entry = entries[fields[0][0]]
            if not isinstance(first_entry, tk.Text):
                first_entry.focus()
                first_entry.select_range(0, tk.END)
            else:
                first_entry.focus()

    def update_asset_in_database(self, asset_data):
        """Update asset record in database"""
        try:
            cursor = self.conn.cursor()
            cursor.execute("""
                UPDATE cannot_find_assets
                SET description = %s, location = %s, technician_name = %s,
                    reported_date = %s, status = %s, updated_date = CURRENT_TIMESTAMP
                WHERE bfm_equipment_no = %s
            """, (asset_data[1], asset_data[2], asset_data[3],
                asset_data[4], asset_data[5], asset_data[0]))
            self.conn.commit()
        except Exception as e:
            self.conn.rollback()
            raise Exception(f"Database error: {str(e)}")





    
        
    def create_deactivated_tab(self):
        """Deactivated Assets tab"""
        self.deactivated_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.deactivated_frame, text="Deactivated")

        # Controls
        controls_frame = ttk.LabelFrame(self.deactivated_frame, text="Deactivated Asset Controls", padding=10)
        controls_frame.pack(fill='x', padx=10, pady=5)

        ttk.Button(controls_frame, text="Import CSV",
                command=self.import_deactivated_csv).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Refresh List",
                command=self.load_deactivated_assets).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Export to PDF",
                command=self.export_deactivated_pdf).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Reactivate Asset",
                command=self.reactivate_deactivated_asset).pack(side='left', padx=5)

        # Search frame
        search_frame = ttk.Frame(self.deactivated_frame)
        search_frame.pack(fill='x', padx=10, pady=5)

        ttk.Label(search_frame, text="Search (BFM/SAP/Description):").pack(side='left', padx=5)
        self.deactivated_search_var = tk.StringVar()
        self.deactivated_search_entry = ttk.Entry(search_frame, textvariable=self.deactivated_search_var, width=40)
        self.deactivated_search_entry.pack(side='left', padx=5)
        # Bind KeyRelease event to trigger filtering as user types
        self.deactivated_search_entry.bind('<KeyRelease>', self.filter_deactivated_list)

        # Deactivated assets list
        list_frame = ttk.LabelFrame(self.deactivated_frame, text="Deactivated Assets", padding=10)
        list_frame.pack(fill='both', expand=True, padx=10, pady=5)

        self.deactivated_tree = ttk.Treeview(list_frame,
                                            columns=('BFM', 'Description', 'Location', 'Deactivated By', 'Deactivated Date', 'Reason'),
                                            show='headings',
                                            selectmode='extended')

        columns_config = {
            'BFM': ('BFM Equipment No.', 130),
            'Description': ('Description', 250),
            'Location': ('Location', 120),
            'Deactivated By': ('Deactivated By', 120),
            'Deactivated Date': ('Deactivated Date', 120),
            'Reason': ('Reason', 200)
        }

        for col, (heading, width) in columns_config.items():
            self.deactivated_tree.heading(col, text=heading)
            self.deactivated_tree.column(col, width=width)

        # Scrollbars
        deact_v_scrollbar = ttk.Scrollbar(list_frame, orient='vertical', command=self.deactivated_tree.yview)
        deact_h_scrollbar = ttk.Scrollbar(list_frame, orient='horizontal', command=self.deactivated_tree.xview)
        self.deactivated_tree.configure(yscrollcommand=deact_v_scrollbar.set, xscrollcommand=deact_h_scrollbar.set)

        # Pack treeview and scrollbars
        self.deactivated_tree.grid(row=0, column=0, sticky='nsew')
        deact_v_scrollbar.grid(row=0, column=1, sticky='ns')
        deact_h_scrollbar.grid(row=1, column=0, sticky='ew')

        list_frame.grid_rowconfigure(0, weight=1)
        list_frame.grid_columnconfigure(0, weight=1)

        # Load initial data
        self.load_deactivated_assets()


    
    def create_cm_management_tab(self):
        """Enhanced Corrective Maintenance management tab with SharePoint integration and filter"""
        self.cm_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.cm_frame, text="Corrective Maintenance")

        # CM controls - Enhanced with SharePoint button
        controls_frame = ttk.LabelFrame(self.cm_frame, text="CM Controls", padding=10)
        controls_frame.pack(fill='x', padx=10, pady=5)

        # First row of controls
        controls_row1 = ttk.Frame(controls_frame)
        controls_row1.pack(fill='x', pady=(0, 5))
    
        ttk.Button(controls_row1, text="Create New CM", 
                command=self.create_cm_dialog).pack(side='left', padx=5)
        ttk.Button(controls_row1, text="Edit CM", 
                command=self.edit_cm_dialog).pack(side='left', padx=5)
        ttk.Button(controls_row1, text="Complete CM", 
                command=self.complete_cm_dialog).pack(side='left', padx=5)
        ttk.Button(controls_row1, text="Refresh CM List", 
                command=self.load_corrective_maintenance_with_filter).pack(side='left', padx=5)

        # Filter controls
        filter_frame = ttk.Frame(controls_frame)
        filter_frame.pack(fill='x')

        ttk.Label(filter_frame, text="Filter by Status:").pack(side='left', padx=(0, 5))

        # Create filter dropdown
        self.cm_filter_var = tk.StringVar(value="All")
        self.cm_filter_dropdown = ttk.Combobox(filter_frame, textvariable=self.cm_filter_var,
                                            values=["All", "Open", "Closed"],
                                            state="readonly", width=15)
        self.cm_filter_dropdown.pack(side='left', padx=5)
        self.cm_filter_dropdown.bind('<<ComboboxSelected>>', self.filter_cm_list)

        # Month and Year filter
        ttk.Label(filter_frame, text="Month:").pack(side='left', padx=(20, 5))
        self.cm_month_var = tk.StringVar(value="All")
        months = ["All", "January", "February", "March", "April", "May", "June",
                 "July", "August", "September", "October", "November", "December"]
        self.cm_month_dropdown = ttk.Combobox(filter_frame, textvariable=self.cm_month_var,
                                             values=months, state="readonly", width=12)
        self.cm_month_dropdown.pack(side='left', padx=5)
        self.cm_month_dropdown.bind('<<ComboboxSelected>>', self.filter_cm_list)

        ttk.Label(filter_frame, text="Year:").pack(side='left', padx=(5, 5))
        current_year = datetime.now().year
        years = ["All"] + [str(year) for year in range(current_year - 5, current_year + 2)]
        self.cm_year_var = tk.StringVar(value="All")
        self.cm_year_dropdown = ttk.Combobox(filter_frame, textvariable=self.cm_year_var,
                                            values=years, state="readonly", width=10)
        self.cm_year_dropdown.pack(side='left', padx=5)
        self.cm_year_dropdown.bind('<<ComboboxSelected>>', self.filter_cm_list)

        # Clear filter button
        ttk.Button(filter_frame, text="Clear Filter",
                command=self.clear_cm_filter).pack(side='left', padx=5)

        # Export Report button
        ttk.Button(filter_frame, text="Export Report",
                command=self.export_cm_report).pack(side='left', padx=5)

        # Second row of controls for Equipment Missing Parts
        controls_row2 = ttk.Frame(controls_frame)
        controls_row2.pack(fill='x', pady=(5, 0))

        ttk.Label(controls_row2, text="Equipment Missing Parts:").pack(side='left', padx=(0, 5))
        ttk.Button(controls_row2, text="Report Missing Parts",
                command=self.create_missing_parts_dialog).pack(side='left', padx=5)
        ttk.Button(controls_row2, text="Edit Missing Parts Entry",
                command=self.edit_missing_parts_dialog).pack(side='left', padx=5)
        ttk.Button(controls_row2, text="Close Missing Parts Entry",
                command=self.close_missing_parts_dialog).pack(side='left', padx=5)

        # CM list with enhanced columns for SharePoint data
        cm_list_frame = ttk.LabelFrame(self.cm_frame, text="Corrective Maintenance List", padding=10)
        cm_list_frame.pack(fill='both', expand=False, padx=10, pady=5)

        # Enhanced treeview with additional columns (fixed height to ensure missing parts list is visible)
        self.cm_tree = ttk.Treeview(cm_list_frame,
                                columns=('CM Number', 'BFM', 'Description', 'Priority', 'Assigned', 'Status', 'Created', 'Source'),
                                show='headings', height=8)

        cm_columns = {
            'CM Number': 120,
            'BFM': 120,
            'Description': 250,
            'Priority': 80,
            'Assigned': 120,
            'Status': 80,
            'Created': 100,
            'Source': 80  # New column to show if from SharePoint
        }

        for col, width in cm_columns.items():
            self.cm_tree.heading(col, text=col)
            self.cm_tree.column(col, width=width)

        # Scrollbars
        cm_v_scrollbar = ttk.Scrollbar(cm_list_frame, orient='vertical', command=self.cm_tree.yview)
        cm_h_scrollbar = ttk.Scrollbar(cm_list_frame, orient='horizontal', command=self.cm_tree.xview)
        self.cm_tree.configure(yscrollcommand=cm_v_scrollbar.set, xscrollcommand=cm_h_scrollbar.set)

        # Pack treeview and scrollbars
        self.cm_tree.grid(row=0, column=0, sticky='nsew')
        cm_v_scrollbar.grid(row=0, column=1, sticky='ns')
        cm_h_scrollbar.grid(row=1, column=0, sticky='ew')

        cm_list_frame.grid_rowconfigure(0, weight=1)
        cm_list_frame.grid_columnconfigure(0, weight=1)

        # Pagination controls for CM list
        self.cm_pagination_frame = ttk.Frame(self.cm_frame)
        self.cm_pagination_frame.pack(fill='x', padx=10, pady=5)

        self.cm_record_label = ttk.Label(self.cm_pagination_frame, text="Loading...",
                                         font=('Arial', 9))
        self.cm_record_label.pack(side='left', padx=5)

        self.cm_load_more_btn = ttk.Button(self.cm_pagination_frame, text=" Load More Records",
                                           command=self.load_more_cm_records)
        self.cm_load_more_btn.pack(side='left', padx=5)

        # Initialize pagination state
        self.cm_offset = 0
        self.cm_page_size = 200
        self.cm_total_count = 0
        self.cm_loaded_count = 0

        # Load CM data with SQL-based filtering and pagination
        self.load_corrective_maintenance_with_filter()

        # Add a separator for visual clarity
        separator = ttk.Separator(self.cm_frame, orient='horizontal')
        separator.pack(fill='x', padx=10, pady=10)

        # Equipment Missing Parts list section - SEPARATE AND PROMINENT
        emp_list_frame = ttk.LabelFrame(self.cm_frame, text=" EQUIPMENT WITH MISSING PARTS - SEPARATE LIST ", padding=10)
        emp_list_frame.pack(fill='both', expand=True, padx=10, pady=5)

        # Refresh button for missing parts
        emp_controls_frame = ttk.Frame(emp_list_frame)
        emp_controls_frame.pack(fill='x', pady=(0, 5))

        ttk.Button(emp_controls_frame, text=" Refresh Missing Parts List",
                command=self.load_missing_parts_list).pack(side='left', padx=5)

        # Add info label
        info_label = ttk.Label(emp_controls_frame,
                              text="This is a SEPARATE list from CM items above - entries you create will appear here",
                              foreground='blue', font=('Arial', 9, 'italic'))
        info_label.pack(side='left', padx=10)

        # Create a container frame for the treeview and scrollbars (using grid)
        emp_tree_container = ttk.Frame(emp_list_frame)
        emp_tree_container.pack(fill='both', expand=True)

        # Treeview for missing parts entries - Increased height for better visibility
        self.emp_tree = ttk.Treeview(emp_tree_container,
                                columns=('EMP Number', 'BFM', 'Description', 'Priority', 'Assigned', 'Status', 'Reported Date', 'Missing Parts'),
                                show='headings', height=10)

        emp_columns = {
            'EMP Number': 120,
            'BFM': 120,
            'Description': 200,
            'Priority': 80,
            'Assigned': 120,
            'Status': 80,
            'Reported Date': 100,
            'Missing Parts': 300
        }

        for col, width in emp_columns.items():
            self.emp_tree.heading(col, text=col)
            self.emp_tree.column(col, width=width)

        # Scrollbars for missing parts list
        emp_v_scrollbar = ttk.Scrollbar(emp_tree_container, orient='vertical', command=self.emp_tree.yview)
        emp_h_scrollbar = ttk.Scrollbar(emp_tree_container, orient='horizontal', command=self.emp_tree.xview)
        self.emp_tree.configure(yscrollcommand=emp_v_scrollbar.set, xscrollcommand=emp_h_scrollbar.set)

        # Grid treeview and scrollbars inside the container
        self.emp_tree.grid(row=0, column=0, sticky='nsew')
        emp_v_scrollbar.grid(row=0, column=1, sticky='ns')
        emp_h_scrollbar.grid(row=1, column=0, sticky='ew')

        emp_tree_container.grid_rowconfigure(0, weight=1)
        emp_tree_container.grid_columnconfigure(0, weight=1)

        # Load Equipment Missing Parts data
        self.load_missing_parts_list()

    def load_corrective_maintenance_with_filter(self):
        """OPTIMIZED: Load CM data with filters applied at database level"""
        # Simply call filter_cm_list which now does SQL-based filtering
        self.filter_cm_list()
    
    def filter_cm_list(self, event=None, reset=True):
        """OPTIMIZED: Filter CM list with pagination - SQL WHERE clauses + LIMIT/OFFSET"""
        try:
            # Check if cm_tree exists yet (might be called during tab creation)
            if not hasattr(self, 'cm_tree'):
                print("DEBUG: cm_tree not created yet, skipping filter")
                return

            # Initialize pagination state if not already done
            if not hasattr(self, 'cm_offset'):
                self.cm_offset = 0
                self.cm_page_size = 200
                self.cm_total_count = 0
                self.cm_loaded_count = 0

            # Get filter values
            selected_status = self.cm_filter_var.get() if hasattr(self, 'cm_filter_var') else "All"
            selected_month = self.cm_month_var.get() if hasattr(self, 'cm_month_var') else "All"
            selected_year = self.cm_year_var.get() if hasattr(self, 'cm_year_var') else "All"

            # Reset pagination when filters change
            if reset:
                self.cm_offset = 0
                self.cm_loaded_count = 0
                # Clear current tree
                for item in self.cm_tree.get_children():
                    self.cm_tree.delete(item)

            cursor = self.conn.cursor()

            # Check if completion_date column exists
            cursor.execute("""
                SELECT column_name
                FROM information_schema.columns
                WHERE table_name='corrective_maintenance'
                AND column_name='completion_date'
            """)
            has_completion_date = cursor.fetchone() is not None

            # Build query with filters applied at database level
            query = f'''
                SELECT cm_number, bfm_equipment_no, description, priority,
                    assigned_technician, status, created_date, notes
                FROM corrective_maintenance
                WHERE 1=1
            '''
            params = []

            # Status filter - use SQL WHERE instead of Python filtering
            if selected_status != "All":
                if selected_status == "Closed":
                    # Include both 'Closed' and 'Completed'
                    query += " AND status IN ('Closed', 'Completed')"
                else:
                    query += " AND status = %s"
                    params.append(selected_status)

            # Month name to number mapping
            month_names = {
                "January": 1, "February": 2, "March": 3, "April": 4,
                "May": 5, "June": 6, "July": 7, "August": 8,
                "September": 9, "October": 10, "November": 11, "December": 12
            }

            # Date filtering - simplified to avoid type casting issues
            if selected_month != "All" or selected_year != "All":
                # Build date filter conditions separately for closed and open CMs
                date_conditions = []

                if has_completion_date:
                    # For closed/completed CMs: check completion_date first, fall back to closed_date
                    closed_condition = "(status IN ('Closed', 'Completed') AND ("
                    month_year_checks = []

                    if selected_month != "All":
                        month_num = month_names.get(selected_month)
                        if month_num:
                            month_year_checks.append(f"(EXTRACT(MONTH FROM COALESCE(completion_date, closed_date)::timestamp) = {month_num})")

                    if selected_year != "All":
                        month_year_checks.append(f"(EXTRACT(YEAR FROM COALESCE(completion_date, closed_date)::timestamp) = {int(selected_year)})")

                    if month_year_checks:
                        closed_condition += " AND ".join(month_year_checks) + "))"
                        date_conditions.append(closed_condition)
                else:
                    # No completion_date column, use closed_date for closed CMs
                    closed_condition = "(status IN ('Closed', 'Completed') AND ("
                    month_year_checks = []

                    if selected_month != "All":
                        month_num = month_names.get(selected_month)
                        if month_num:
                            month_year_checks.append(f"(EXTRACT(MONTH FROM closed_date::timestamp) = {month_num})")

                    if selected_year != "All":
                        month_year_checks.append(f"(EXTRACT(YEAR FROM closed_date::timestamp) = {int(selected_year)})")

                    if month_year_checks:
                        closed_condition += " AND ".join(month_year_checks) + "))"
                        date_conditions.append(closed_condition)

                # For open CMs: use created_date
                open_condition = "(status NOT IN ('Closed', 'Completed') AND ("
                month_year_checks = []

                if selected_month != "All":
                    month_num = month_names.get(selected_month)
                    if month_num:
                        month_year_checks.append(f"(EXTRACT(MONTH FROM created_date::timestamp) = {month_num})")

                if selected_year != "All":
                    month_year_checks.append(f"(EXTRACT(YEAR FROM created_date::timestamp) = {int(selected_year)})")

                if month_year_checks:
                    open_condition += " AND ".join(month_year_checks) + "))"
                    date_conditions.append(open_condition)

                if date_conditions:
                    query += " AND (" + " OR ".join(date_conditions) + ")"

            # Get total count for pagination (only on reset/filter change)
            if reset or self.cm_total_count == 0:
                # Extract WHERE clause for count query
                where_clause = query.split('WHERE 1=1', 1)[1] if 'WHERE 1=1' in query else ''
                count_query = f"SELECT COUNT(*) FROM corrective_maintenance WHERE 1=1{where_clause}"
                cursor.execute(count_query, params)
                self.cm_total_count = cursor.fetchone()[0]

            # Add pagination
            query += f" ORDER BY created_date DESC LIMIT {self.cm_page_size} OFFSET {self.cm_offset}"

            # Execute optimized query
            cursor.execute(query, params)

            # Display results (append to existing if loading more)
            records_added = 0
            for idx, cm in enumerate(cursor.fetchall()):
                cm_number, bfm_no, description, priority, assigned, status, created, notes = cm
                # Truncate description for display
                display_desc = (description[:47] + '...') if description and len(description) > 50 else description

                self.cm_tree.insert('', 'end', values=(
                    cm_number, bfm_no, display_desc, priority, assigned, status, created, notes
                ))
                records_added += 1

                # Yield to event loop every 50 items to keep UI responsive
                if idx % 50 == 0:
                    self.root.update_idletasks()

            # Update pagination state
            self.cm_loaded_count += records_added
            self.cm_offset += records_added

            # Update pagination UI
            if hasattr(self, 'cm_record_label'):
                self.cm_record_label.config(
                    text=f"Showing {self.cm_loaded_count} of {self.cm_total_count} records"
                )

            if hasattr(self, 'cm_load_more_btn'):
                if self.cm_loaded_count >= self.cm_total_count:
                    self.cm_load_more_btn.config(state='disabled', text="All Records Loaded")
                else:
                    remaining = self.cm_total_count - self.cm_loaded_count
                    self.cm_load_more_btn.config(
                        state='normal',
                        text=f" Load More ({remaining} remaining)"
                    )

        except Exception as e:
            print(f"Error filtering corrective maintenance: {e}")
            import traceback
            traceback.print_exc()
            messagebox.showerror("Error", f"Failed to filter CM data: {str(e)}")
        
    def load_more_cm_records(self):
        """Load next batch of CM records"""
        self.filter_cm_list(reset=False)

    def clear_cm_filter(self):
        """Clear all filters and show all items"""
        self.cm_filter_var.set("All")
        self.cm_month_var.set("All")
        self.cm_year_var.set("All")
        self.filter_cm_list()

    def export_cm_report(self):
        """Export CM report with all required fields, applying current filters"""
        try:
            # Get current filter values
            selected_status = self.cm_filter_var.get()
            selected_month = self.cm_month_var.get()
            selected_year = self.cm_year_var.get()

            # Build filter description for filename
            filter_desc = ""
            if selected_status != "All":
                filter_desc += f"_{selected_status}"
            if selected_month != "All":
                filter_desc += f"_{selected_month}"
            if selected_year != "All":
                filter_desc += f"_{selected_year}"

            # Generate filename with timestamp
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            default_filename = f"CM_Report{filter_desc}_{timestamp}.pdf"

            # Ask user for save location
            file_path = filedialog.asksaveasfilename(
                title="Export CM Report",
                defaultextension=".pdf",
                initialfile=default_filename,
                filetypes=[("PDF files", "*.pdf"), ("CSV files", "*.csv"), ("Excel files", "*.xlsx"), ("All files", "*.*")]
            )

            if not file_path:
                return  # User cancelled

            # Query database for all CM fields
            # Try to use completion_date if it exists, otherwise fall back to closed_date
            cursor = self.conn.cursor()

            # First, check if completion_date column exists
            cursor.execute("""
                SELECT column_name
                FROM information_schema.columns
                WHERE table_name='corrective_maintenance'
                AND column_name='completion_date'
            """)
            has_completion_date = cursor.fetchone() is not None

            # Build query based on available columns
            if has_completion_date:
                date_field = "COALESCE(completion_date, closed_date)"
            else:
                date_field = "closed_date"

            cursor.execute(f'''
                SELECT
                    cm_number,
                    description,
                    status,
                    created_date,
                    {date_field} as completion_date
                FROM corrective_maintenance
                ORDER BY created_date DESC
            ''')

            cm_data = cursor.fetchall()

            # Month name to number mapping for filtering
            month_names = {
                "January": 1, "February": 2, "March": 3, "April": 4,
                "May": 5, "June": 6, "July": 7, "August": 8,
                "September": 9, "October": 10, "November": 11, "December": 12
            }

            # Filter data based on current selections
            filtered_data = []
            for row in cm_data:
                cm_number, desc, status, created, completion = row

                # Check status filter - include both 'Closed' and 'Completed' to match Monthly PM Summary
                if selected_status != "All":
                    if selected_status == "Closed":
                        # "Closed" filter should match both 'Closed' and 'Completed' statuses
                        if status not in ['Closed', 'Completed']:
                            continue
                    elif status != selected_status:
                        continue

                # Check month/year filter
                if selected_month != "All" or selected_year != "All":
                    # Determine which date to use for filtering
                    if selected_status == "Closed" or status in ['Closed', 'Completed']:
                        # For closed CMs, use completion/closed date
                        filter_date = completion
                    else:
                        # For open CMs, use created date
                        filter_date = created

                    if filter_date:
                        try:
                            # Parse the filter date
                            parsed_date = None
                            date_str = str(filter_date)
                            for fmt in ['%Y-%m-%d', '%Y-%m-%d %H:%M:%S', '%m/%d/%Y', '%m/%d/%y']:
                                try:
                                    parsed_date = datetime.strptime(date_str.split('.')[0], fmt)
                                    break
                                except ValueError:
                                    continue

                            if parsed_date:
                                # Check month
                                if selected_month != "All":
                                    month_num = month_names.get(selected_month)
                                    if parsed_date.month != month_num:
                                        continue

                                # Check year
                                if selected_year != "All":
                                    if parsed_date.year != int(selected_year):
                                        continue
                            else:
                                # Couldn't parse date, skip if filtering
                                continue
                        except (ValueError, AttributeError):
                            continue
                    else:
                        # No date available, skip if filtering
                        continue

                # Add to filtered data - include date opened and date closed
                filtered_data.append((cm_number, desc, status, created, completion))

            if not filtered_data:
                messagebox.showwarning("No Data", "No CM records match the current filters.")
                return

            # Create DataFrame with proper column names
            columns = [
                'CM Number',
                'Description',
                'Status',
                'Date Opened',
                'Date Closed'
            ]

            df = pd.DataFrame(filtered_data, columns=columns)

            # Export based on file extension
            if file_path.endswith('.pdf'):
                # Generate PDF report
                self._generate_cm_pdf_report(file_path, filtered_data, columns, selected_status, selected_month, selected_year)
            elif file_path.endswith('.xlsx'):
                df.to_excel(file_path, index=False, engine='openpyxl')
            else:
                df.to_csv(file_path, index=False)

            messagebox.showinfo("Success", f"CM report exported successfully to:\n{file_path}\n\nTotal records: {len(filtered_data)}")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to export CM report: {str(e)}")
            traceback.print_exc()

    def _generate_cm_pdf_report(self, file_path, cm_data, columns, status_filter, month_filter, year_filter):
        """Generate a professional PDF report for CM data with word wrapping"""
        from reportlab.lib.pagesizes import letter, landscape
        from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.units import inch
        from reportlab.lib import colors
        from reportlab.lib.enums import TA_CENTER, TA_LEFT

        try:
            # Create document in landscape mode for better table fit
            doc = SimpleDocTemplate(file_path, pagesize=landscape(letter),
                                rightMargin=36, leftMargin=36,
                                topMargin=50, bottomMargin=36)

            story = []
            styles = getSampleStyleSheet()

            # Custom styles
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=20,
                textColor=colors.HexColor('#1a365d'),
                spaceAfter=20,
                alignment=TA_CENTER,
                fontName='Helvetica-Bold'
            )

            heading_style = ParagraphStyle(
                'CustomHeading',
                parent=styles['Heading2'],
                fontSize=12,
                textColor=colors.HexColor('#2c5282'),
                spaceAfter=10,
                fontName='Helvetica-Bold'
            )

            # Cell text style for word wrapping
            cell_style = ParagraphStyle(
                'CellText',
                parent=styles['Normal'],
                fontSize=7,
                textColor=colors.HexColor('#2d3748'),
                fontName='Helvetica',
                leading=9,
                wordWrap='CJK'
            )

            # Header cell style
            header_style = ParagraphStyle(
                'HeaderText',
                parent=styles['Normal'],
                fontSize=8,
                textColor=colors.whitesmoke,
                fontName='Helvetica-Bold',
                alignment=TA_CENTER,
                leading=10
            )

            # Title
            story.append(Paragraph("Corrective Maintenance Report", title_style))
            story.append(Spacer(1, 12))

            # Report metadata
            filter_text = "Applied Filters: "
            filters_applied = []
            if status_filter != "All":
                filters_applied.append(f"Status: {status_filter}")
            if month_filter != "All":
                filters_applied.append(f"Month: {month_filter}")
            if year_filter != "All":
                filters_applied.append(f"Year: {year_filter}")

            if filters_applied:
                filter_text += ", ".join(filters_applied)
            else:
                filter_text += "None (All CMs)"

            meta_data = [
                ['Report Generated:', datetime.now().strftime('%B %d, %Y at %I:%M %p')],
                ['Total Records:', str(len(cm_data))],
                ['Filters:', filter_text]
            ]

            meta_table = Table(meta_data, colWidths=[1.5*inch, 6*inch])
            meta_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#e2e8f0')),
                ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#2d3748')),
                ('ALIGN', (0, 0), (0, -1), 'RIGHT'),
                ('ALIGN', (1, 0), (1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#cbd5e0')),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('LEFTPADDING', (0, 0), (-1, -1), 8),
                ('RIGHTPADDING', (0, 0), (-1, -1), 8),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ]))

            story.append(meta_table)
            story.append(Spacer(1, 20))

            # Helper function to sanitize text for PDF Paragraphs
            def sanitize_text_for_pdf(text):
                """Sanitize text for ReportLab Paragraph rendering"""
                if text is None or text == '':
                    return ''
                text = str(text)
                # Replace tabs with spaces
                text = text.replace('\t', '    ')
                # Escape XML special characters
                text = text.replace('&', '&amp;')
                text = text.replace('<', '&lt;')
                text = text.replace('>', '&gt;')
                # Convert newlines to <br/> tags for proper rendering
                text = text.replace('\n', '<br/>')
                text = text.replace('\r', '')
                return text

            # CM Data Table
            story.append(Paragraph("Corrective Maintenance Records", heading_style))
            story.append(Spacer(1, 10))

            # Prepare table data with Paragraph objects for word wrapping
            # Header row with Paragraph objects (sanitize tabs)
            table_data = [[Paragraph(sanitize_text_for_pdf(col), header_style) for col in columns]]

            for row in cm_data:
                formatted_row = []
                for i, value in enumerate(row):
                    # Format the data for better display with word wrapping
                    if value is None or value == '':
                        cell_text = ''
                    elif i == 1:  # Description - use Paragraph for word wrap
                        desc = sanitize_text_for_pdf(value)
                        cell_text = Paragraph(desc, cell_style)
                    elif i in [3, 4]:  # Date Opened and Date Closed - format dates
                        if value:
                            # Try to format the date nicely
                            date_str = str(value).split('.')[0]  # Remove microseconds if present
                            # Try to parse and reformat
                            try:
                                for fmt in ['%Y-%m-%d %H:%M:%S', '%Y-%m-%d', '%m/%d/%Y', '%m/%d/%y']:
                                    try:
                                        date_obj = datetime.strptime(date_str, fmt)
                                        date_str = date_obj.strftime('%Y-%m-%d')
                                        break
                                    except ValueError:
                                        continue
                            except:
                                pass
                            cell_text = Paragraph(sanitize_text_for_pdf(date_str), cell_style)
                        else:
                            cell_text = Paragraph('', cell_style)
                    else:
                        # CM Number and Status - use Paragraph for consistent formatting
                        text = sanitize_text_for_pdf(value)
                        cell_text = Paragraph(text, cell_style)

                    formatted_row.append(cell_text)

                table_data.append(formatted_row)

            # Column widths optimized for landscape letter (10.5 inches usable)
            col_widths = [
                1.0*inch,   # CM Number
                4.5*inch,   # Description
                1.0*inch,   # Status
                1.2*inch,   # Date Opened
                1.2*inch    # Date Closed
            ]

            # Create table
            cm_table = Table(table_data, colWidths=col_widths, repeatRows=1)
            cm_table.setStyle(TableStyle([
                # Header row styling
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2c5282')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                ('VALIGN', (0, 0), (-1, 0), 'MIDDLE'),

                # Data rows styling
                ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                ('TEXTCOLOR', (0, 1), (-1, -1), colors.HexColor('#2d3748')),
                ('ALIGN', (0, 1), (-1, -1), 'LEFT'),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),

                # Grid
                ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#cbd5e0')),
                ('LINEBELOW', (0, 0), (-1, 0), 2, colors.HexColor('#2c5282')),

                # Padding
                ('LEFTPADDING', (0, 0), (-1, -1), 4),
                ('RIGHTPADDING', (0, 0), (-1, -1), 4),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),

                # Alternating row colors for better readability
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#f7fafc')]),
            ]))

            story.append(cm_table)

            # Build PDF
            doc.build(story)

        except Exception as e:
            raise Exception(f"Failed to generate PDF: {str(e)}")


    def process_sharepoint_excel_file(self, file_path):
        """Process the SharePoint Excel file and import CMDATA"""
        try:
            import pandas as pd
        
            self.sharepoint_status_label.config(text="Processing Excel file...")
            self.root.update()
        
            # Read the CMDATA sheet
            try:
                df = pd.read_excel(file_path, sheet_name='CMData')
            except Exception as e:
                # If CMDATA sheet doesn't exist, show available sheets
                xl_file = pd.ExcelFile(file_path)
                available_sheets = xl_file.sheet_names
            
                messagebox.showerror("Sheet Not Found", 
                                f"Could not find 'CMDATA' sheet.\n\n"
                                f"Available sheets: {', '.join(available_sheets)}\n\n"
                                f"Please verify the correct sheet name.")
                return
        
            # Show data preview and column mapping dialog
            self.show_sharepoint_data_preview(df)
        
        except Exception as e:
            messagebox.showerror("Error", f"Failed to read Excel file: {str(e)}")
            self.sharepoint_status_label.config(text="Import failed")

    def show_sharepoint_data_preview(self, df):
        """Show preview of SharePoint data and allow column mapping"""
        dialog = tk.Toplevel(self.root)
        dialog.title("SharePoint Data Preview & Mapping")
        dialog.geometry("900x700")
        dialog.transient(self.root)
        dialog.grab_set()
    
        # Data preview
        preview_frame = ttk.LabelFrame(dialog, text="Data Preview (First 10 rows)", padding=10)
        preview_frame.pack(fill='both', expand=True, padx=10, pady=5)
    
        # Create treeview for data preview
        preview_columns = list(df.columns)
        preview_tree = ttk.Treeview(preview_frame, columns=preview_columns, show='headings')
    
        # Configure columns
        for col in preview_columns:
            preview_tree.heading(col, text=col)
            preview_tree.column(col, width=100)
    
        # Add data (first 10 rows)
        for index, row in df.head(10).iterrows():
            values = [str(val) if pd.notna(val) else '' for val in row]
            preview_tree.insert('', 'end', values=values)
    
        # Scrollbars
        preview_v_scrollbar = ttk.Scrollbar(preview_frame, orient='vertical', command=preview_tree.yview)
        preview_h_scrollbar = ttk.Scrollbar(preview_frame, orient='horizontal', command=preview_tree.xview)
        preview_tree.configure(yscrollcommand=preview_v_scrollbar.set, xscrollcommand=preview_h_scrollbar.set)
    
        preview_tree.grid(row=0, column=0, sticky='nsew')
        preview_v_scrollbar.grid(row=0, column=1, sticky='ns')
        preview_h_scrollbar.grid(row=1, column=0, sticky='ew')
    
        preview_frame.grid_rowconfigure(0, weight=1)
        preview_frame.grid_columnconfigure(0, weight=1)
    
        # Column mapping
        mapping_frame = ttk.LabelFrame(dialog, text="Map Columns to CM Fields", padding=10)
        mapping_frame.pack(fill='x', padx=10, pady=5)
    
        # Column mappings
        mappings = {}
    
        # CM fields that can be mapped
        cm_fields = [
            ("CM Number/ID", "cm_number"),
            ("Equipment/BFM Number", "bfm_equipment_no"),
            ("Problem Description", "description"),
            ("Priority Level", "priority"),
            ("Assigned Technician", "assigned_technician"),
            ("Status", "status"),
            ("Created Date", "created_date"),
            ("Notes/Comments", "notes")
        ]
    
        # Add "None" option to CSV columns
        column_options = ["(Not in Data)"] + list(df.columns)
    
        row = 0
        for field_name, field_key in cm_fields:
            ttk.Label(mapping_frame, text=field_name + ":").grid(row=row, column=0, sticky='w', pady=2)
        
            mapping_var = tk.StringVar()
            combo = ttk.Combobox(mapping_frame, textvariable=mapping_var, values=column_options, width=30)
            combo.grid(row=row, column=1, padx=10, pady=2)
        
            # Try to auto-match common column names
            for col in df.columns:
                col_lower = col.lower()
                if field_key == 'cm_number' and any(term in col_lower for term in ['cm', 'id', 'number', 'ticket']):
                    mapping_var.set(col)
                    break
                elif field_key == 'bfm_equipment_no' and any(term in col_lower for term in ['bfm', 'equipment', 'asset']):
                    mapping_var.set(col)
                    break
                elif field_key == 'description' and any(term in col_lower for term in ['description', 'problem', 'issue']):
                    mapping_var.set(col)
                    break
                elif field_key == 'priority' and 'priority' in col_lower:
                    mapping_var.set(col)
                    break
                elif field_key == 'assigned_technician' and any(term in col_lower for term in ['technician', 'assigned', 'owner']):
                    mapping_var.set(col)
                    break
                elif field_key == 'status' and 'status' in col_lower:
                    mapping_var.set(col)
                    break
                elif field_key == 'created_date' and any(term in col_lower for term in ['date', 'created', 'opened']):
                    mapping_var.set(col)
                    break
        
            mappings[field_key] = mapping_var
            row += 1
    
        def import_sharepoint_data():
            """Import the mapped SharePoint data"""
            try:
                cursor = self.conn.cursor()
                imported_count = 0
                error_count = 0
            
                self.sharepoint_status_label.config(text="Importing SharePoint data...")
                self.root.update()
            
                for index, row in df.iterrows():
                    try:
                        # Extract mapped data
                        data = {}
                        for field_key, mapping_var in mappings.items():
                            column_name = mapping_var.get()
                            if column_name != "(Not in Data)" and column_name in df.columns:
                                value = row[column_name]
                                if pd.isna(value):
                                    data[field_key] = None
                                else:
                                    # Handle different data types
                                    if field_key == 'created_date':
                                        try:
                                            # Try to parse date
                                            parsed_date = pd.to_datetime(value).strftime('%Y-%m-%d')
                                            data[field_key] = parsed_date
                                        except:
                                            data[field_key] = str(value)
                                    else:
                                        data[field_key] = str(value)
                            else:
                                data[field_key] = None
                    
                        # Generate CM number if not provided
                        if not data.get('cm_number'):
                            data['cm_number'] = f"SP-{datetime.now().strftime('%Y%m%d')}-{index+1:04d}"
                    
                        # Set defaults
                        if not data.get('priority'):
                            data['priority'] = 'Medium'
                        if not data.get('status'):
                            data['status'] = 'Open'
                        if not data.get('created_date'):
                            data['created_date'] = datetime.now().strftime('%Y-%m-%d')
                    
                        # Insert into database with source tracking
                        cursor.execute('''
                            INSERT OR REPLACE INTO corrective_maintenance 
                            (cm_number, bfm_equipment_no, description, priority, assigned_technician, 
                            status, created_date, notes)
                            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                        ''', (
                            data.get('cm_number'),
                            data.get('bfm_equipment_no'),
                            data.get('description'),
                            data.get('priority'),
                            data.get('assigned_technician'),
                            data.get('status'),
                            data.get('created_date'),
                            f"Imported from SharePoint: {data.get('notes', '')}"
                        ))
                    
                        imported_count += 1
                    
                    except Exception as e:
                        print(f"Error importing row {index}: {e}")
                        error_count += 1
                        continue
            
                self.conn.commit()
                dialog.destroy()
            
                # Show results
                result_msg = f"SharePoint import completed!\n\n"
                result_msg += f"Successfully imported: {imported_count} records\n"
                if error_count > 0:
                    result_msg += f"Skipped (errors): {error_count} records\n"
                result_msg += f"\nTotal processed: {imported_count + error_count} records"
            
                messagebox.showinfo("Import Results", result_msg)
            
                # Refresh CM list
                self.load_corrective_maintenance()
                self.sharepoint_status_label.config(text=f"Imported {imported_count} CMs from SharePoint")
                self.update_status(f"Imported {imported_count} CM records from SharePoint")
            
            except Exception as e:
                messagebox.showerror("Error", f"Failed to import data: {str(e)}")
                self.sharepoint_status_label.config(text="Import failed")
    
        # Buttons
        button_frame = ttk.Frame(dialog)
        button_frame.pack(side='bottom', fill='x', padx=10, pady=10)
    
        ttk.Button(button_frame, text="Import Data", command=import_sharepoint_data).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side='right', padx=5)


    def connect_to_sharepoint_direct(self, site_url, username, password):
        """Attempt direct SharePoint connection"""
        try:
            # This is a simplified example - real implementation would use proper authentication
            # You would need libraries like Office365-REST-Python-Client or similar
        
            # Placeholder for actual SharePoint connection
            # In reality, you'd need proper OAuth2 authentication
        
            return False  # For now, return False to redirect to manual upload
        
        except Exception as e:
            print(f"SharePoint connection error: {e}")
            return False

    # Enhanced load_corrective_maintenance to show source
    def load_corrective_maintenance(self):
        """Load corrective maintenance data with enhanced source tracking"""
        try:
            cursor = self.conn.cursor()

            # Check if completion_date column exists
            cursor.execute("""
                SELECT column_name
                FROM information_schema.columns
                WHERE table_name='corrective_maintenance'
                AND column_name='completion_date'
            """)
            has_completion_date = cursor.fetchone() is not None

            # Build query based on available columns
            if has_completion_date:
                date_field = "COALESCE(completion_date, closed_date)"
            else:
                date_field = "closed_date"

            cursor.execute(f'''
                SELECT cm_number, bfm_equipment_no, description, priority,
                    assigned_technician, status, created_date, notes, {date_field} as completion_date
                FROM corrective_maintenance
                ORDER BY created_date DESC
            ''')

            # Clear existing items
            for item in self.cm_tree.get_children():
                self.cm_tree.delete(item)

            # Add CM records (include completion_date as hidden column for filtering)
            for idx, cm in enumerate(cursor.fetchall()):
                cm_number, bfm_no, description, priority, assigned, status, created, notes, completion = cm

                # Determine source
                source = "SharePoint" if notes and "Imported from SharePoint" in notes else "Manual"

                # Truncate description for display
                display_desc = (description[:47] + '...') if description and len(description) > 50 else (description or '')

                # Store completion date as a hidden column (last column) for filtering
                self.cm_tree.insert('', 'end', values=(
                    cm_number, bfm_no, display_desc, priority, assigned, status, created, source, completion
                ))

                # Yield to event loop every 50 items to keep UI responsive
                if idx % 50 == 0:
                    self.root.update_idletasks()

        except Exception as e:
            print(f"Error loading corrective maintenance: {e}")


    def load_missing_parts_list(self):
        """Load equipment missing parts data with status feedback"""
        try:
            cursor = self.conn.cursor()

            # Count total records first
            cursor.execute('SELECT COUNT(*) FROM equipment_missing_parts')
            total_count = cursor.fetchone()[0]

            # Fetch all missing parts records
            cursor.execute('''
                SELECT emp_number, bfm_equipment_no, description, priority,
                    assigned_technician, status, reported_date, missing_parts_description
                FROM equipment_missing_parts
                ORDER BY reported_date DESC
            ''')

            # Clear existing items
            for item in self.emp_tree.get_children():
                self.emp_tree.delete(item)

            # Add missing parts records
            records = cursor.fetchall()
            for idx, emp in enumerate(records):
                emp_number, bfm_no, description, priority, assigned, status, reported_date, missing_parts = emp

                # Truncate description and missing parts for display
                display_desc = (description[:47] + '...') if description and len(description) > 50 else (description or '')
                display_parts = (missing_parts[:97] + '...') if missing_parts and len(missing_parts) > 100 else (missing_parts or '')

                self.emp_tree.insert('', 'end', values=(
                    emp_number, bfm_no, display_desc, priority, assigned, status, reported_date, display_parts
                ))

                # Yield to event loop every 50 items to keep UI responsive
                if idx % 50 == 0:
                    self.root.update_idletasks()

            # Update status bar with count
            if hasattr(self, 'update_status'):
                if total_count > 0:
                    self.update_status(f" Loaded {total_count} equipment missing parts entries")
                else:
                    self.update_status(" No missing parts entries found - Create one using 'Report Missing Parts' button")

            print(f"DEBUG: Successfully loaded {total_count} missing parts entries")
            cursor.close()

        except Exception as e:
            print(f"Error loading equipment missing parts: {e}")
            messagebox.showerror("Error", f"Failed to load equipment missing parts: {e}")




    def create_analytics_dashboard_tab(self):
        """Analytics and dashboard tab"""
        self.analytics_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.analytics_frame, text="Analytics Dashboard")
        
        # Analytics controls
        controls_frame = ttk.LabelFrame(self.analytics_frame, text="Analytics Controls", padding=10)
        controls_frame.pack(fill='x', padx=10, pady=5)
        
        ttk.Button(controls_frame, text="Refresh Dashboard", 
                  command=self.refresh_analytics_dashboard).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Equipment Analytics", 
                  command=self.show_equipment_analytics).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="PM Trends", 
                  command=self.show_pm_trends).pack(side='left', padx=5)
        ttk.Button(controls_frame, text="Export Analytics", 
                  command=self.export_analytics).pack(side='left', padx=5)
        
        # Dashboard display
        dashboard_frame = ttk.LabelFrame(self.analytics_frame, text="Analytics Dashboard", padding=10)
        dashboard_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        # Create notebook for different analytics views
        self.analytics_notebook = ttk.Notebook(dashboard_frame)
        self.analytics_notebook.pack(fill='both', expand=True)
        
        # Overview tab
        overview_frame = ttk.Frame(self.analytics_notebook)
        self.analytics_notebook.add(overview_frame, text="Overview")
        
        self.analytics_text = tk.Text(overview_frame, wrap='word', font=('Courier', 10))
        analytics_scrollbar = ttk.Scrollbar(overview_frame, orient='vertical', command=self.analytics_text.yview)
        self.analytics_text.configure(yscrollcommand=analytics_scrollbar.set)
        
        self.analytics_text.pack(side='left', fill='both', expand=True)
        analytics_scrollbar.pack(side='right', fill='y')
        
        # Load initial analytics
        self.refresh_analytics_dashboard()
    
    def update_status(self, message):
        """Update status bar with message"""
        if hasattr(self, 'status_bar'):
            self.status_bar.config(text=f"AIT CMMS - {message}")
            self.root.update_idletasks()
        else:
            print(f"STATUS: {message}")
    
    
    def update_equipment_suggestions(self, event):
        """Update equipment suggestions in completion form"""
        search_term = self.completion_bfm_var.get().lower()
        
        if len(search_term) >= 2:
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT bfm_equipment_no FROM equipment 
                WHERE LOWER(bfm_equipment_no) LIKE %s OR LOWER(description) LIKE %s
                ORDER BY bfm_equipment_no LIMIT 10
            ''', (f'%{search_term}%', f'%{search_term}%'))
            
            suggestions = [row[0] for row in cursor.fetchall()]
            self.bfm_combo['values'] = suggestions
    
    
    
    def load_latest_weekly_schedule(self):
        """Load the most recent weekly schedule on startup"""
        try:
            cursor = self.conn.cursor()
        
            # Find the most recent week with scheduled PMs
            cursor.execute('''
                SELECT week_start_date 
                FROM weekly_pm_schedules 
                ORDER BY week_start_date DESC 
                LIMIT 1
            ''')
        
            latest_week = cursor.fetchone()
        
            if latest_week:
                # Set the week start variable to the latest week
                self.week_start_var.set(latest_week[0])
                # Refresh the display with this week's data
                self.refresh_technician_schedules()
                self.update_status(f"Loaded latest weekly schedule: {latest_week[0]}")
            else:
                # No schedules exist, keep current week
                self.update_status("No weekly schedules found")
            
        except Exception as e:
            print(f"Error loading latest weekly schedule: {e}")
    
    
    
    
    
    
    def submit_pm_completion(self):
        """Enhanced PM completion with validation and verification - PREVENTS DUPLICATES"""
        try:
            # Validate required fields
            if not self.completion_bfm_var.get():
                messagebox.showerror("Error", "Please enter BFM Equipment Number")
                return

            if not self.pm_type_var.get():
                messagebox.showerror("Error", "Please select PM Type")
                return

            if not self.completion_tech_var.get():
                messagebox.showerror("Error", "Please select Technician")
                return

            # Get form data
            bfm_no = self.completion_bfm_var.get().strip()
            pm_type = self.pm_type_var.get()
            technician = self.completion_tech_var.get()
            labor_hours = float(self.labor_hours_var.get() or 0)
            labor_minutes = float(self.labor_minutes_var.get() or 0)
            pm_due_date = self.pm_due_date_var.get().strip()
            special_equipment = self.special_equipment_var.get()
            notes = self.notes_text.get('1.0', 'end-1c')
            next_annual_pm = self.next_annual_pm_var.get().strip()

            # Use PM Due Date as completion date if provided, otherwise today's date
            if pm_due_date:
                completion_date = pm_due_date
            else:
                completion_date = datetime.now().strftime('%Y-%m-%d')

            cursor = self.conn.cursor()
            
            # Ensure we start with a clean transaction state
            try:
                self.conn.rollback()
            except:
                pass

            # WARNING: ENHANCED VALIDATION - Check for recent duplicates
            validation_result = self.validate_pm_completion(cursor, bfm_no, pm_type, technician, completion_date)
            if not validation_result['valid']:
                # Show detailed warning dialog
                response = messagebox.askyesno(
                    "WARNING: Potential Duplicate PM Detected",
                    f"{validation_result['message']}\n\n"
                    f"Details:\n"
                    f"- Equipment: {bfm_no}\n"
                    f"- PM Type: {pm_type}\n"
                    f"- Technician: {technician}\n"
                    f"- Completion Date: {completion_date}\n\n"
                    f"Do you want to proceed anyway?\n\n"
                    f"Click 'No' to review and make changes.",
                    icon='warning'
                )
                if not response:
                    # User chose not to proceed - rollback any pending transaction
                    try:
                        self.conn.rollback()
                    except:
                        pass
                    self.update_status("PM submission cancelled - potential duplicate detected")
                    return

            # CRITICAL FIX: Validate PM type matches the weekly schedule
            # This prevents Monthly PMs from being logged as Annual PMs
            try:
                cursor.execute('''
                    SELECT pm_type, assigned_technician, scheduled_date
                    FROM weekly_pm_schedules
                    WHERE bfm_equipment_no = %s AND status = 'Scheduled'
                    ORDER BY week_start_date DESC, scheduled_date DESC
                    LIMIT 1
                ''', (bfm_no,))

                scheduled_pm = cursor.fetchone()
                if scheduled_pm:
                    scheduled_pm_type = scheduled_pm[0]
                    scheduled_tech = scheduled_pm[1]
                    scheduled_date = scheduled_pm[2]

                    # Warn if PM type doesn't match schedule
                    if pm_type != scheduled_pm_type:
                        response = messagebox.askyesno(
                            "WARNING: PM Type Mismatch Detected",
                            f"The PM type you selected does NOT match the schedule!\n\n"
                            f"You selected: {pm_type}\n"
                            f"Schedule shows: {scheduled_pm_type}\n\n"
                            f"Equipment: {bfm_no}\n"
                            f"Scheduled for: {scheduled_date}\n"
                            f"Assigned to: {scheduled_tech}\n\n"
                            f"This is the issue that caused Monthly PMs to be logged as Annual!\n\n"
                            f"Do you want to proceed with '{pm_type}' anyway?\n"
                            f"Click 'No' to go back and select '{scheduled_pm_type}' instead.",
                            icon='warning'
                        )
                        if not response:
                            try:
                                self.conn.rollback()
                            except:
                                pass
                            self.update_status(f"PM submission cancelled - please select '{scheduled_pm_type}' PM type")
                            # Auto-correct the PM type for the user
                            self.pm_type_var.set(scheduled_pm_type)
                            return
            except Exception as e:
                print(f"Warning: Could not validate PM type against schedule: {e}")

            # Auto-calculate next annual PM date if blank
            if not next_annual_pm and pm_type in ['Monthly', 'Six Month', 'Annual']:
                try:
                    completion_dt = datetime.strptime(completion_date, '%Y-%m-%d')
                except ValueError:
                    completion_dt = datetime.now()

                # ONLY set annual PM date when completing an Annual PM
                if pm_type == 'Annual':
                    next_annual_dt = completion_dt + timedelta(days=365)

                    # Add equipment-specific offset to spread annual PMs
                    try:
                        import re
                        numeric_part = re.findall(r'\d+', bfm_no)
                        if numeric_part:
                            last_digits = int(numeric_part[-1]) % 61
                            offset_days = last_digits - 30  # -30 to +30 days
                        else:
                            offset_days = (hash(bfm_no) % 61) - 30
        
                        next_annual_dt = next_annual_dt + timedelta(days=offset_days)
                    except Exception:
                        import random
                        offset_days = random.randint(-21, 21)
                        next_annual_dt = next_annual_dt + timedelta(days=offset_days)

                    next_annual_pm = next_annual_dt.strftime('%Y-%m-%d')
                    self.next_annual_pm_var.set(next_annual_pm)
                # For Monthly and Six Month PMs, DO NOT change the existing Annual PM date
                # This preserves the independent Annual PM schedule

            # Handle different PM types with TRANSACTION SAFETY
            try:
                # PostgreSQL automatically starts a transaction with the first query
                # No need for explicit BEGIN TRANSACTION

                if pm_type == 'CANNOT FIND':
                    success = self.process_cannot_find_pm(cursor, bfm_no, technician, completion_date, notes)
                
                elif pm_type == 'Run to Failure':
                    success = self.process_run_to_failure_pm(cursor, bfm_no, technician, completion_date, 
                                                        labor_hours + (labor_minutes/60), notes)
                
                else:  # Normal PM (Monthly, Six Month, Annual)
                    success = self.process_normal_pm_completion(cursor, bfm_no, pm_type, technician, 
                                                            completion_date, labor_hours, labor_minutes, 
                                                            pm_due_date, special_equipment, notes, next_annual_pm)

                if success:
                    # Commit transaction
                    cursor.execute('COMMIT')
                
                    # WARNING: VERIFY the completion was saved correctly
                    verification_result = self.verify_pm_completion_saved(cursor, bfm_no, pm_type, technician, completion_date)
                
                    if verification_result['verified']:
                        messagebox.showinfo("CHECK: Success", 
                                        f"PM completion recorded and verified!\n\n"
                                        f"Equipment: {bfm_no}\n"
                                        f"PM Type: {pm_type}\n"
                                        f"Technician: {technician}\n"
                                        f"Date: {completion_date}\n\n"
                                        f"CHECK: Database verification passed")
                    
                        # Clear form and refresh displays
                        self.clear_completion_form()
                        self.load_recent_completions()
                        if hasattr(self, 'refresh_technician_schedules'):
                            self.refresh_technician_schedules()
                        self.update_status(f"CHECK: PM completed and verified: {bfm_no} - {pm_type} by {technician}")
                        if hasattr(self, 'auto_sync_after_action'):
                            self.auto_sync_after_action()
                    else:
                        messagebox.showerror("WARNING: Warning", 
                                        f"PM was saved but verification failed!\n\n"
                                        f"{verification_result['message']}\n\n"
                                        f"Please check the PM History tab to confirm the completion was recorded.")
                        self.update_status(f"WARNING: PM saved but verification incomplete: {bfm_no}")
                else:
                    # Rollback on failure
                    cursor.execute('ROLLBACK')
                    messagebox.showerror("Error", "Failed to process PM completion. Transaction rolled back.")
                
            except Exception as e:
                # Rollback on exception
                cursor.execute('ROLLBACK')
                raise e

        except Exception as e:
            messagebox.showerror("Error", f"Failed to submit PM completion: {str(e)}")
            import traceback
            print(f"PM Completion Error: {traceback.format_exc()}")
    
    
    def auto_pull_from_sharepoint(self):
        """Automatically pull latest data from SharePoint every 30 seconds"""
        try:
            # Check if there's a newer backup available
            if hasattr(self, 'backup_sync_dir') and self.backup_sync_dir:
                db_file = 'ait_cmms_database.db'
                backup_dir = self.backup_sync_dir
            
                if os.path.exists(backup_dir):
                    # Get latest backup
                    backup_files = []
                    for f in os.listdir(backup_dir):
                        if f.startswith('ait_cmms_backup_') and f.endswith('.db'):
                            full_path = os.path.join(backup_dir, f)
                            backup_files.append((full_path, os.path.getmtime(full_path)))
                
                    if backup_files:
                        backup_files.sort(key=lambda x: x[1], reverse=True)
                        latest_backup_path, latest_backup_time = backup_files[0]
                    
                        # Check if backup is newer than local
                        if os.path.exists(db_file):
                            local_time = os.path.getmtime(db_file)
                        
                            if latest_backup_time > local_time:
                                print(f"Newer backup detected, pulling from SharePoint...")
                                
                                # Close connection
                                self.conn.close()
                                
                                # Copy newer backup
                                shutil.copy2(latest_backup_path, db_file)
                                
                                # Reopen connection
                                #self.conn = sqlite3.connect(db_file)
                                
                                # Refresh views based on user role
                                if self.current_user_role == 'Manager':
                                    # Manager has all views (equipment list now uses direct SQL queries)
                                    if hasattr(self, 'load_recent_completions'):
                                        self.load_recent_completions()
                            
                                # Both Manager and Technician have CM access
                                if hasattr(self, 'load_corrective_maintenance'):
                                    self.load_corrective_maintenance()
                            
                                self.update_status("CHECK: Data updated from SharePoint")
        
            # Schedule next pull in 30 seconds
            #self.root.after(30 * 1000, self.auto_pull_from_sharepoint)
        
        except Exception as e:
            print(f"Auto-pull error: {e}")
            # Schedule next pull anyway
            #self.root.after(30 * 1000, self.auto_pull_from_sharepoint)
    
    
    def auto_save_and_sync(self):
        """Auto-save database changes and sync to SharePoint every 5 seconds"""
        try:
            # Commit any pending database changes
            if hasattr(self, 'conn') and self.conn:
                self.conn.commit()
        
            # Push to SharePoint immediately after saving
            if hasattr(self, 'backup_sync_dir') and self.backup_sync_dir:
                self.sharepoint_only_backup(self.backup_sync_dir)
                print("Auto-saved and synced to SharePoint")
        
            # Schedule next auto-save in 5 minutes
            #self.root.after(300 * 1000, self.auto_save_and_sync)
        
        except Exception as e:
            print(f"Auto-save error: {e}")
            # Schedule next auto-save anyway
            #self.root.after(300 * 1000, self.auto_save_and_sync)
    
    
    
    def validate_pm_completion(self, cursor, bfm_no, pm_type, technician, completion_date):
        """Comprehensive validation to prevent duplicate PMs"""
        try:
            issues = []
        
            # Check 1: Same PM type completed recently for this equipment
            cursor.execute('''
                SELECT completion_date, technician_name, id
                FROM pm_completions 
                WHERE bfm_equipment_no = %s AND pm_type = %s
                ORDER BY completion_date DESC LIMIT 1
            ''', (bfm_no, pm_type))
        
            recent_completion = cursor.fetchone()
            if recent_completion:
                last_completion_date, last_technician, completion_id = recent_completion
                try:
                    last_date = datetime.strptime(last_completion_date, '%Y-%m-%d')
                    current_date = datetime.strptime(completion_date, '%Y-%m-%d')
                    days_since = (current_date - last_date).days
                
                    # Different thresholds for different PM types
                    min_days = {
                        'Monthly': 25,      # Monthly PMs should be ~30 days apart
                        'Six Month': 150,   # Six month PMs should be ~180 days apart
                        'Annual': 300       # Annual PMs should be ~365 days apart
                    }
                
                    threshold = min_days.get(pm_type, 7)  # Default 7 days for other types
                
                    if days_since < threshold:
                        issues.append(f"WARNING: DUPLICATE DETECTED: {pm_type} PM for {bfm_no} was completed only {days_since} days ago")
                        issues.append(f"   Previous completion: {last_completion_date} by {last_technician}")
                        issues.append(f"   Minimum interval for {pm_type} PM: {threshold} days")
                    
                except ValueError:
                    # If date parsing fails, flag it as potential issue
                    issues.append(f"WARNING: Date parsing issue with previous completion: {last_completion_date}")

            # Check 2: Same technician completing SAME PM TYPE on same equipment too frequently  
            cursor.execute('''
                SELECT COUNT(*) 
                FROM pm_completions 
                WHERE bfm_equipment_no = %s 
                AND technician_name = %s
                AND pm_type = %s
                AND completion_date::date >= %s::date - INTERVAL '7 days'
            ''', (bfm_no, technician, pm_type, completion_date))
        
            recent_count = cursor.fetchone()[0]
            if recent_count > 0:
                issues.append(f"WARNING: Same technician ({technician}) completed {pm_type} PM on {bfm_no} within last 7 days")

            # Check 3: Equipment exists and is active
            cursor.execute('SELECT status FROM equipment WHERE bfm_equipment_no = %s', (bfm_no,))
            equipment_status = cursor.fetchone()
        
            if not equipment_status:
                issues.append(f"CHECK: Equipment {bfm_no} not found in database")
            elif equipment_status[0] in ['Missing', 'Run to Failure'] and pm_type not in ['CANNOT FIND', 'Run to Failure']:
                issues.append(f"WARNING: Equipment {bfm_no} has status '{equipment_status[0]}' - unusual for {pm_type} PM")

            # Check 4: Scheduled PM exists for this week
            #current_week_start = self.get_week_start(datetime.strptime(completion_date, '%Y-%m-%d'))
            #cursor.execute('''
            #   SELECT COUNT(*) FROM weekly_pm_schedules 
            #   WHERE bfm_equipment_no = %s AND pm_type = %s 
            #    AND assigned_technician = %s AND week_start_date = %s
            #''', (bfm_no, pm_type, technician, current_week_start.strftime('%Y-%m-%d')))
            #
            #scheduled_count = cursor.fetchone()[0]
            #if scheduled_count == 0 and pm_type in ['Monthly', 'Annual']:
            #   issues.append(f"WARNING: No scheduled PM found for this week - completing ahead of schedule")

            # Return validation result
            if issues:
                return {
                    'valid': False,
                    'message': f"Found {len(issues)} potential issue(s):\n\n" + "\n\n".join(issues)
                }
            else:
                return {'valid': True, 'message': 'Validation passed'}
            
        except Exception as e:
            # Rollback any failed queries in validation
            try:
                self.conn.rollback()
            except:
                pass
            # Show the actual error for debugging
            import traceback
            error_detail = f"{str(e)}\n\nQuery error details:\n{traceback.format_exc()}"
            return {
                'valid': False,
                'verified': False,
                'message': f"Validation error: {str(e)}"
            }

    def verify_pm_completion_saved(self, cursor, bfm_no, pm_type, technician, completion_date):
        """Verify that the PM completion was actually saved to the database"""
        try:
            # Check 1: PM completion record exists
            cursor.execute('''
                SELECT id, completion_date, technician_name, created_date
                FROM pm_completions 
                WHERE bfm_equipment_no = %s AND pm_type = %s AND technician_name = %s
                AND completion_date = %s
                ORDER BY created_date DESC LIMIT 1
            ''', (bfm_no, pm_type, technician, completion_date))
        
            completion_record = cursor.fetchone()
            if not completion_record:
                return {
                    'verified': False,
                    'message': f"CHECK: PM completion record not found in database"
                }

            # Check 2: Equipment PM dates updated (for normal PMs)
            if pm_type in ['Monthly', 'Six Month', 'Annual']:
                date_field = f'last_{pm_type.lower().replace(" ", "_")}_pm'
                cursor.execute(f'SELECT {date_field} FROM equipment WHERE bfm_equipment_no = %s', (bfm_no,))
            
                equipment_date = cursor.fetchone()
                if equipment_date and equipment_date[0] != completion_date:
                    return {
                        'verified': False,
                        'message': f"WARNING: Equipment {date_field} not updated correctly. Expected: {completion_date}, Found: {equipment_date[0]}"
                    }

            # Check 3: Weekly schedule updated if applicable
            current_week_start = self.get_week_start(datetime.strptime(completion_date, '%Y-%m-%d'))
            cursor.execute('''
                SELECT status FROM weekly_pm_schedules 
                WHERE bfm_equipment_no = %s AND pm_type = %s
                AND assigned_technician = %s AND week_start_date = %s
            ''', (bfm_no, pm_type, technician, current_week_start.strftime('%Y-%m-%d')))
        
            schedule_status = cursor.fetchone()
            if schedule_status and schedule_status[0] != 'Completed':
                return {
                    'verified': False,
                    'message': f"WARNING: Weekly schedule not marked as completed. Status: {schedule_status[0]}"
                }

            return {
                'verified': True,
                'message': f"CHECK: All verification checks passed",
                'completion_id': completion_record[0]
            }
        
        except Exception as e:
            return {
                'verified': False,
                'message': f"Verification error: {str(e)}"
            }

    def process_normal_pm_completion(self, cursor, bfm_no, pm_type, technician, completion_date, 
                                labor_hours, labor_minutes, pm_due_date, special_equipment, notes, next_annual_pm):
        """Process normal PM completion with enhanced error handling"""
        try:
            cursor.execute('''
                INSERT INTO pm_completions 
                (bfm_equipment_no, pm_type, technician_name, completion_date, 
                labor_hours, labor_minutes, pm_due_date, special_equipment, 
                notes, next_annual_pm_date)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                RETURNING id
            ''', (
                bfm_no, pm_type, technician, completion_date,
                labor_hours, labor_minutes, pm_due_date, special_equipment,
                notes, next_annual_pm
            ))
        
         
            completion_id = cursor.fetchone()[0]
            if not completion_id:
                raise Exception("Failed to get completion record ID")

            # Update equipment PM dates
            if pm_type == 'Monthly':
                if next_annual_pm: 
                    cursor.execute('''
                        UPDATE equipment SET 
                        last_monthly_pm = %s, 
                        next_monthly_pm = %s::date + INTERVAL '30 days',
                        next_annual_pm = %s,  
                        updated_date = CURRENT_TIMESTAMP
                        WHERE bfm_equipment_no = %s
                    ''', (completion_date, completion_date, next_annual_pm, bfm_no))
                else:
                    cursor.execute('''
                        UPDATE equipment SET 
                        last_monthly_pm = %s, 
                        next_monthly_pm = %s::date + INTERVAL '30 days',
                        updated_date = CURRENT_TIMESTAMP
                        WHERE bfm_equipment_no = %s
                    ''', (completion_date, completion_date, bfm_no))
                    
            elif pm_type == 'Six Month':
                cursor.execute('''
                    UPDATE equipment SET 
                    last_six_month_pm = %s, 
                    next_six_month_pm = %s::date + INTERVAL '180 days',
                    updated_date = CURRENT_TIMESTAMP
                    WHERE bfm_equipment_no = %s
                ''', (completion_date, completion_date, bfm_no))
                
            elif pm_type == 'Annual':
                cursor.execute('''
                    UPDATE equipment SET 
                    last_annual_pm = %s, 
                    next_annual_pm = %s::date + INTERVAL '365 days',
                    updated_date = CURRENT_TIMESTAMP
                    WHERE bfm_equipment_no = %s
                ''', (completion_date, completion_date, bfm_no))

            # Verify equipment update worked
            affected_rows = cursor.rowcount
            if affected_rows != 1:
                raise Exception(f"Equipment update failed - affected {affected_rows} rows instead of 1")

            # Update weekly schedule status if exists
            # Find and update any scheduled PM for this equipment/PM type/technician combination
            # regardless of which week it was scheduled for (PMs can be completed in different weeks)
            cursor.execute('''
                UPDATE weekly_pm_schedules SET
                status = 'Completed',
                completion_date = %s,
                labor_hours = %s,
                notes = %s
                WHERE id = (
                    SELECT id FROM weekly_pm_schedules
                    WHERE bfm_equipment_no = %s AND pm_type = %s AND assigned_technician = %s
                    AND status = 'Scheduled'
                    ORDER BY scheduled_date
                    LIMIT 1
                )
            ''', (completion_date, labor_hours + (labor_minutes/60), notes,
                bfm_no, pm_type, technician))

            # DEBUG: Check if the update worked
            updated_rows = cursor.rowcount
            print(f"DEBUG: Updated {updated_rows} weekly schedule rows for {bfm_no} - {pm_type} by {technician}")

            print(f"CHECK: Normal PM completion processed successfully: {bfm_no} - {pm_type}")
            return True
            
        except Exception as e:
            print(f"CHECK: Error processing normal PM completion: {str(e)}")
            return False
    
    def fix_weekly_schedule_status_flexible(self):
        """Enhanced method to fix weekly schedule status with flexible matching"""
        try:
            cursor = self.conn.cursor()
        
            # First, get all actual completions for the week
            cursor.execute('''
                SELECT bfm_equipment_no, pm_type, technician_name, completion_date,
                    (labor_hours + labor_minutes/60.0) as total_hours, notes
                FROM pm_completions 
                WHERE completion_date BETWEEN '2025-08-25' AND '2025-08-31'
            ''')
        
            completions = cursor.fetchall()
            print(f"Found {len(completions)} actual completions to process")
        
            updated_count = 0
        
            for completion in completions:
                bfm_no, pm_type, technician, comp_date, hours, notes = completion
            
                # Try exact match first
                cursor.execute('''
                    UPDATE weekly_pm_schedules 
                    SET status = 'Completed',
                        completion_date = %s,
                        labor_hours = %s,
                        notes = %s
                    WHERE bfm_equipment_no = %s AND pm_type = %s AND assigned_technician = %s
                    AND week_start_date = '2025-08-25' AND status = 'Scheduled'
                ''', (comp_date, hours, notes, bfm_no, pm_type, technician))
            
                exact_matches = cursor.rowcount
            
                # If no exact match, try equipment + PM type match (without LIMIT)
                if exact_matches == 0:
                    # First check if there's an available scheduled PM for this equipment/PM type
                    cursor.execute('''
                        SELECT id FROM weekly_pm_schedules 
                        WHERE bfm_equipment_no = %s AND pm_type = %s
                        AND week_start_date = '2025-08-25' AND status = 'Scheduled'
                    ''', (bfm_no, pm_type))
                
                    available = cursor.fetchone()
                
                    if available:
                        # Update the first available matching record
                        cursor.execute('''
                            UPDATE weekly_pm_schedules 
                            SET status = 'Completed',
                                completion_date = %s,
                                labor_hours = %s,
                                notes = %s,
                                assigned_technician = %s
                            WHERE id = %s
                        ''', (comp_date, hours, notes, technician, available[0]))
                    
                        flexible_matches = cursor.rowcount
                        if flexible_matches > 0:
                            print(f"Flexible match: {bfm_no} {pm_type} reassigned to {technician}")
                    
                        updated_count += flexible_matches
                    else:
                        print(f"No scheduled PM found for {bfm_no} {pm_type}")
                else:
                    updated_count += exact_matches
                    print(f"Exact match: {bfm_no} {pm_type} by {technician}")
        
            self.conn.commit()
        
            messagebox.showinfo("Success", 
                            f"Processed {len(completions)} completions\n"
                            f"Updated {updated_count} weekly schedule records!")
            print(f"Final result: Updated {updated_count} out of {len(completions)} completions")
        
        except Exception as e:
            messagebox.showerror("Error", f"Failed to fix weekly schedule: {str(e)}")
            print(f"Error: {e}")

    def fix_cannot_find_schedules_retroactive(self, silent=False):
        """Retroactively update all PM schedules for Cannot Find assets

        Args:
            silent: If True, runs without user confirmation (for auto-migration)
        """
        try:
            cursor = self.conn.cursor()

            # Find all equipment in cannot_find_assets table
            cursor.execute('''
                SELECT bfm_equipment_no, reported_date, technician_name, notes
                FROM cannot_find_assets
                WHERE status = 'Missing'
            ''')

            cannot_find_assets = cursor.fetchall()
            print(f"Found {len(cannot_find_assets)} Cannot Find assets")

            if not cannot_find_assets:
                if not silent:
                    messagebox.showinfo("No Updates Needed", "No Cannot Find assets found to update.")
                return 0

            # Confirm with user before making changes (unless silent mode)
            if not silent:
                response = messagebox.askyesno(
                    "Retroactive Schedule Update",
                    f"Found {len(cannot_find_assets)} Cannot Find assets.\n\n"
                    f"This will update ALL scheduled PMs for these assets to 'Cannot Find' status.\n\n"
                    f"Do you want to proceed?"
                )

                if not response:
                    return 0

            updated_count = 0

            for asset in cannot_find_assets:
                bfm_no, reported_date, technician, notes = asset

                # Update all scheduled PMs for this equipment to "Cannot Find"
                cursor.execute('''
                    UPDATE weekly_pm_schedules
                    SET status = 'Cannot Find',
                        completion_date = %s,
                        notes = COALESCE(%s, notes)
                    WHERE bfm_equipment_no = %s
                      AND status = 'Scheduled'
                ''', (reported_date, notes, bfm_no))

                rows_updated = cursor.rowcount
                if rows_updated > 0:
                    print(f"Updated {rows_updated} schedules for {bfm_no}")
                    updated_count += rows_updated

            self.conn.commit()

            if not silent:
                messagebox.showinfo(
                    "Success",
                    f"Retroactive update complete!\n\n"
                    f"Updated {updated_count} scheduled PMs to 'Cannot Find' status\n"
                    f"for {len(cannot_find_assets)} assets."
                )

            print(f"Total: Updated {updated_count} schedules for {len(cannot_find_assets)} Cannot Find assets")

            # Refresh displays
            if hasattr(self, 'refresh_technician_schedules'):
                self.refresh_technician_schedules()

            return updated_count

        except Exception as e:
            self.conn.rollback()
            if not silent:
                messagebox.showerror("Error", f"Failed to fix Cannot Find schedules: {str(e)}")
            print(f"Error fixing Cannot Find schedules: {e}")
            return 0


    
    
    def process_cannot_find_pm(self, cursor, bfm_no, technician, completion_date, notes):
        """Process CANNOT FIND PM with validation"""
        try:
            # Get equipment info
            cursor.execute('SELECT description, location FROM equipment WHERE bfm_equipment_no = %s', (bfm_no,))
            equipment_info = cursor.fetchone()
            description = equipment_info[0] if equipment_info else ''
            location = equipment_info[1] if equipment_info else ''

            # Insert into cannot_find_assets table
            cursor.execute('''
                INSERT INTO cannot_find_assets 
                (bfm_equipment_no, description, location, technician_name, reported_date, notes)
                VALUES (%s, %s, %s, %s, %s, %s)
            ''', (bfm_no, description, location, technician, completion_date, notes))

            # Update equipment status
            cursor.execute('UPDATE equipment SET status = "Missing" WHERE bfm_equipment_no = %s', (bfm_no,))

            affected_rows = cursor.rowcount
            if affected_rows != 1:
                raise Exception(f"Equipment status update failed - affected {affected_rows} rows")

            # Update weekly schedule status to "Cannot Find"
            cursor.execute('''
                UPDATE weekly_pm_schedules SET
                status = 'Cannot Find',
                completion_date = %s,
                notes = %s
                WHERE id = (
                    SELECT id FROM weekly_pm_schedules
                    WHERE bfm_equipment_no = %s AND assigned_technician = %s
                    AND status = 'Scheduled'
                    ORDER BY scheduled_date
                    LIMIT 1
                )
            ''', (completion_date, notes, bfm_no, technician))

            print(f"CHECK: Cannot Find PM processed: {bfm_no}")
            return True
        
        except Exception as e:
            print(f"CHECK: Error processing Cannot Find PM: {str(e)}")
            return False

    def process_run_to_failure_pm(self, cursor, bfm_no, technician, completion_date, total_hours, notes):
        """Process Run to Failure PM with validation"""
        try:
            # Get equipment info
            cursor.execute('SELECT description, location FROM equipment WHERE bfm_equipment_no = %s', (bfm_no,))
            equipment_info = cursor.fetchone()
            description = equipment_info[0] if equipment_info else ''
            location = equipment_info[1] if equipment_info else ''

            # Insert into run_to_failure_assets table
            cursor.execute('''
                INSERT INTO run_to_failure_assets 
                (bfm_equipment_no, description, location, technician_name, completion_date, labor_hours, notes)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
            ''', (bfm_no, description, location, technician, completion_date, total_hours, notes))

            # Update equipment status and disable all PM types
            cursor.execute('''
                UPDATE equipment SET 
                status = "Run to Failure",
                monthly_pm = 0,
                six_month_pm = 0,
                annual_pm = 0,
                updated_date = CURRENT_TIMESTAMP
                WHERE bfm_equipment_no = %s
            ''', (bfm_no,))
        
            affected_rows = cursor.rowcount
            if affected_rows != 1:
                raise Exception(f"Equipment update failed - affected {affected_rows} rows")

            # Update weekly schedule status if exists - mark as completed with special note
            cursor.execute('''
                UPDATE weekly_pm_schedules SET
                status = 'Completed',
                completion_date = %s,
                labor_hours = %s,
                notes = %s
                WHERE id = (
                    SELECT id FROM weekly_pm_schedules
                    WHERE bfm_equipment_no = %s AND assigned_technician = %s
                    AND status = 'Scheduled'
                    ORDER BY scheduled_date
                    LIMIT 1
                )
            ''', (completion_date, total_hours, f"RUN TO FAILURE: {notes}", bfm_no, technician))

            print(f"CHECK: Run to Failure PM processed: {bfm_no}")
            return True
        
        except Exception as e:
            print(f"CHECK: Error processing Run to Failure PM: {str(e)}")
            return False

    # Additional method to add to your class:
    def show_recent_completions_for_equipment(self, bfm_no):
        """Show recent completions for specific equipment - useful for debugging"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT pm_type, technician_name, completion_date, 
                    (labor_hours + labor_minutes/60.0) as total_hours,
                    notes
                FROM pm_completions 
                WHERE bfm_equipment_no = %s
                ORDER BY completion_date DESC LIMIT 10
            ''', (bfm_no,))
        
            completions = cursor.fetchall()
        
            if completions:
                report = f"RECENT PM COMPLETIONS FOR {bfm_no}\n"
                report += "=" * 50 + "\n\n"
            
                for pm_type, tech, date, hours, notes in completions:
                    report += f"- {date} - {pm_type} PM by {tech} ({hours:.1f}h)\n"
                    if notes:
                        report += f"  Notes: {notes[:100]}...\n" if len(notes) > 100 else f"  Notes: {notes}\n"
                    report += "\n"
            
                # Show in a dialog
                dialog = tk.Toplevel(self.root)
                dialog.title(f"PM History - {bfm_no}")
                dialog.geometry("600x400")
            
                text_widget = tk.Text(dialog, wrap='word', font=('Courier', 10))
                text_widget.pack(fill='both', expand=True, padx=10, pady=10)
                text_widget.insert('1.0', report)
                text_widget.config(state='disabled')
            
            else:
                messagebox.showinfo("No History", f"No PM completions found for equipment {bfm_no}")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load PM history: {str(e)}")
      
    def load_cannot_find_assets(self):
        """Load cannot find assets data and store for filtering"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT bfm_equipment_no, description, location, technician_name, reported_date, status
                FROM cannot_find_assets 
                WHERE status = 'Missing'
                ORDER BY reported_date DESC
            ''')
        
            # Store all data for filtering
            self.cannot_find_data = cursor.fetchall()
        
            # Display the data
            self.filter_cannot_find_assets()
        
        except Exception as e:
            print(f"Error loading cannot find assets: {e}")




    def filter_cannot_find_assets(self):
        """Filter the Cannot Find assets based on search term"""
        # Clear existing items
        for item in self.cannot_find_tree.get_children():
            self.cannot_find_tree.delete(item)

        # Get search term
        search_term = self.cannot_find_search_var.get().lower().strip()

        # If no data loaded yet, return
        if not hasattr(self, 'cannot_find_data'):
            return

        # Filter and display data
        for idx, asset in enumerate(self.cannot_find_data):
            bfm_no, description, location, technician, reported_date, status = asset

            # If search term is empty, show all
            if not search_term:
                self.cannot_find_tree.insert('', 'end', values=(
                    bfm_no, description or '', location or '', technician, reported_date, status
                ))
            else:
                # Search in all fields
                searchable_text = ' '.join([
                    str(bfm_no or ''),
                    str(description or ''),
                    str(location or ''),
                    str(technician or ''),
                    str(reported_date or ''),
                    str(status or '')
                ]).lower()

                if search_term in searchable_text:
                    self.cannot_find_tree.insert('', 'end', values=(
                        bfm_no, description or '', location or '', technician, reported_date, status
                    ))

            # Yield to event loop every 50 items to keep UI responsive
            if idx % 50 == 0:
                self.root.update_idletasks()
    
        # Update count in status bar if method exists
        visible_count = len(self.cannot_find_tree.get_children())
        total_count = len(self.cannot_find_data) if hasattr(self, 'cannot_find_data') else 0
    
        if hasattr(self, 'update_status'):
            if search_term:
                self.update_status(f"Showing {visible_count} of {total_count} Cannot Find assets (filtered)")
            else:
                self.update_status(f"Showing {total_count} Cannot Find assets")

    def load_deactivated_assets(self, search_term=None):
        """Load deactivated assets data with optional search filter"""
        try:
            # Clear existing items
            for item in self.deactivated_tree.get_children():
                self.deactivated_tree.delete(item)

            cursor = self.conn.cursor()

            # Build query with JOIN to get SAP number from equipment table
            query = '''
                SELECT da.bfm_equipment_no, da.description, da.location,
                       da.deactivated_by, da.deactivated_date, da.reason,
                       e.sap_material_no
                FROM deactivated_assets da
                LEFT JOIN equipment e ON TRIM(da.bfm_equipment_no) = TRIM(e.bfm_equipment_no)
                WHERE da.status = 'Deactivated'
            '''
            params = []

            # Add search filter if provided
            if search_term:
                query += ''' AND (
                    LOWER(da.bfm_equipment_no) LIKE LOWER(%s) OR
                    LOWER(da.description) LIKE LOWER(%s) OR
                    LOWER(e.sap_material_no) LIKE LOWER(%s)
                )'''
                search_param = f'%{search_term}%'
                params.extend([search_param] * 3)

            query += ' ORDER BY da.deactivated_date DESC'

            cursor.execute(query, params)
            assets = cursor.fetchall()

            for asset in assets:
                bfm_no, description, location, deactivated_by, deactivated_date, reason, sap_no = asset
                self.deactivated_tree.insert('', 'end', values=(
                    bfm_no,
                    description or '',
                    location or '',
                    deactivated_by or '',
                    deactivated_date or '',
                    reason or ''
                ))

            # Update status bar
            count = len(assets)
            if hasattr(self, 'update_status'):
                if search_term:
                    self.update_status(f"Showing {count} Deactivated assets (filtered)")
                else:
                    self.update_status(f"Showing {count} Deactivated assets")

        except Exception as e:
            print(f"Error loading deactivated assets: {e}")


    def filter_deactivated_list(self, *args):
        """Filter deactivated assets list based on search term"""
        try:
            # Check if deactivated tree exists yet (might be called during tab creation)
            if not hasattr(self, 'deactivated_tree'):
                return

            # Get search term from entry field
            search_term = self.deactivated_search_entry.get().strip() if hasattr(self, 'deactivated_search_entry') else ''

            # Reload deactivated assets with search filter
            self.load_deactivated_assets(search_term=search_term if search_term else None)

        except Exception as e:
            print(f"Error filtering deactivated assets: {e}")


    def import_deactivated_csv(self):
        """Import deactivated assets from CSV file"""
        file_path = filedialog.askopenfilename(
            title="Select Deactivated Assets CSV File",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )

        if file_path:
            try:
                # Show column mapping dialog first
                self.show_deactivated_csv_mapping_dialog(file_path)

            except Exception as e:
                messagebox.showerror("Error", f"Failed to import CSV file: {str(e)}")


    def show_deactivated_csv_mapping_dialog(self, file_path):
        """Show dialog to map CSV columns to deactivated assets database fields"""

        try:
            # Read CSV to get column headers
            df = pd.read_csv(file_path, encoding='cp1252', nrows=5)  # Just read first 5 rows to see structure
            csv_columns = list(df.columns)

            dialog = tk.Toplevel(self.root)
            dialog.title("Map CSV Columns to Deactivated Assets Fields")
            dialog.geometry("700x600")
            dialog.transient(self.root)
            dialog.grab_set()

            # Main container with scrollbar
            main_canvas = tk.Canvas(dialog)
            scrollbar = ttk.Scrollbar(dialog, orient="vertical", command=main_canvas.yview)
            scrollable_frame = ttk.Frame(main_canvas)

            scrollable_frame.bind(
                "<Configure>",
                lambda e: main_canvas.configure(scrollregion=main_canvas.bbox("all"))
            )

            main_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            main_canvas.configure(yscrollcommand=scrollbar.set)

            # Instructions
            ttk.Label(scrollable_frame, text="Map your CSV columns to the correct database fields:",
                    font=('Arial', 12, 'bold')).pack(pady=10)

            # Create mapping frame
            mapping_frame = ttk.Frame(scrollable_frame)
            mapping_frame.pack(fill='both', expand=True, padx=20, pady=10)

            # Column mappings
            mappings = {}

            # Database fields that can be mapped for deactivated assets
            db_fields = [
                ("SAP Material No", "sap_material_no"),
                ("BFM Equipment No (Required)", "bfm_equipment_no"),
                ("Description", "description"),
                ("Reason for Deactivation", "reason")
            ]

            # Add "None" option to CSV columns
            csv_options = ["(Not in CSV)"] + csv_columns

            row = 0
            for field_name, field_key in db_fields:
                ttk.Label(mapping_frame, text=field_name + ":").grid(row=row, column=0, sticky='w', pady=2)

                mapping_var = tk.StringVar()
                combo = ttk.Combobox(mapping_frame, textvariable=mapping_var, values=csv_options, width=30)
                combo.grid(row=row, column=1, padx=10, pady=2)

                # Try to auto-match common column names
                for csv_col in csv_columns:
                    csv_lower = csv_col.lower()
                    if field_key == 'sap_material_no' and 'sap' in csv_lower:
                        mapping_var.set(csv_col)
                        break
                    elif field_key == 'bfm_equipment_no' and 'bfm' in csv_lower:
                        mapping_var.set(csv_col)
                        break
                    elif field_key == 'description' and 'description' in csv_lower:
                        mapping_var.set(csv_col)
                        break
                    elif field_key == 'reason' and 'reason' in csv_lower:
                        mapping_var.set(csv_col)
                        break

                mappings[field_key] = mapping_var
                row += 1

            # Show sample data
            sample_frame = ttk.LabelFrame(scrollable_frame, text="Sample Data from Your CSV", padding=10)
            sample_frame.pack(fill='x', padx=20, pady=10)

            sample_text = tk.Text(sample_frame, height=6, width=80)
            sample_text.pack()
            sample_text.insert('1.0', df.to_string())
            sample_text.config(state='disabled')

            def process_import():
                """Process the import with mapped columns"""
                try:
                    # Get the full CSV data
                    full_df = pd.read_csv(file_path, encoding='cp1252')
                    full_df.columns = full_df.columns.str.strip()  # Strip whitespace from column names

                    cursor = self.conn.cursor()
                    imported_count = 0
                    error_count = 0
                    current_date = datetime.now().strftime('%Y-%m-%d')

                    for index, row in full_df.iterrows():
                        try:
                            # Extract mapped data with whitespace stripping
                            data = {}
                            for field_key, mapping_var in mappings.items():
                                csv_column = mapping_var.get()
                                if csv_column != "(Not in CSV)" and csv_column in full_df.columns:
                                    value = row[csv_column]
                                    if pd.isna(value):
                                        data[field_key] = None
                                    else:
                                        # Strip whitespace from all string values
                                        data[field_key] = str(value).strip()
                                else:
                                    data[field_key] = None

                            # Only import if BFM number exists
                            bfm_no = data.get('bfm_equipment_no')
                            if bfm_no:
                                # Ensure BFM number has no whitespace
                                bfm_no = bfm_no.strip()

                                # First, check if equipment exists in equipment table, if not, create it
                                cursor.execute('''
                                    SELECT bfm_equipment_no FROM equipment WHERE TRIM(bfm_equipment_no) = TRIM(%s)
                                ''', (bfm_no,))

                                equipment_exists = cursor.fetchone()

                                if not equipment_exists:
                                    # Create the equipment record first
                                    cursor.execute('''
                                        INSERT INTO equipment
                                        (sap_material_no, bfm_equipment_no, description, status)
                                        VALUES (%s, %s, %s, %s)
                                        ON CONFLICT (bfm_equipment_no) DO NOTHING
                                    ''', (
                                        data.get('sap_material_no'),
                                        bfm_no,
                                        data.get('description'),
                                        'Deactivated'
                                    ))
                                else:
                                    # Update existing equipment status to Deactivated
                                    cursor.execute('''
                                        UPDATE equipment
                                        SET status = 'Deactivated'
                                        WHERE TRIM(bfm_equipment_no) = TRIM(%s)
                                    ''', (bfm_no,))

                                # Insert into deactivated_assets table
                                cursor.execute('''
                                    INSERT INTO deactivated_assets
                                    (bfm_equipment_no, description, deactivated_by, deactivated_date,
                                     reason, status)
                                    VALUES (%s, %s, %s, %s, %s, %s)
                                    ON CONFLICT (bfm_equipment_no) DO UPDATE SET
                                        description = EXCLUDED.description,
                                        deactivated_by = EXCLUDED.deactivated_by,
                                        deactivated_date = EXCLUDED.deactivated_date,
                                        reason = EXCLUDED.reason,
                                        status = EXCLUDED.status
                                ''', (
                                    bfm_no,
                                    data.get('description'),
                                    self.user_name,
                                    current_date,
                                    data.get('reason'),
                                    'Deactivated'
                                ))
                                imported_count += 1
                            else:
                                error_count += 1

                        except Exception as e:
                            print(f"Error importing row {index}: {e}")
                            error_count += 1
                            continue

                    self.conn.commit()
                    dialog.destroy()

                    # Show results
                    result_msg = f"Import completed!\n\n"
                    result_msg += f"CHECK: Successfully imported: {imported_count} records\n"
                    if error_count > 0:
                        result_msg += f"WARNING: Skipped (errors): {error_count} records\n"
                    result_msg += f"\nTotal processed: {imported_count + error_count} records"

                    messagebox.showinfo("Import Results", result_msg)
                    self.load_deactivated_assets()
                    self.update_equipment_statistics()
                    self.update_status(f"Imported {imported_count} deactivated asset records")

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to process import: {str(e)}")

            def cancel_import():
                """Cancel the import process"""
                dialog.destroy()

            # Buttons frame
            button_frame = ttk.Frame(scrollable_frame)
            button_frame.pack(side='bottom', fill='x', padx=20, pady=20)

            # Import button
            import_button = ttk.Button(button_frame, text="Import with These Mappings",
                                    command=process_import)
            import_button.pack(side='left', padx=10)

            # Cancel button
            cancel_button = ttk.Button(button_frame, text="Cancel",
                                    command=cancel_import)
            cancel_button.pack(side='right', padx=10)

            # Pack the canvas and scrollbar
            main_canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to read CSV file: {str(e)}")


    # 8. LOAD RUN TO FAILURE ASSETS
    def load_run_to_failure_assets(self):
        """Stubbed out - Run to Failure functionality replaced with Deactivated tab"""
        # This function is kept for backwards compatibility but does nothing
        # The Run to Failure tab has been replaced with the Deactivated tab
        if not hasattr(self, 'run_to_failure_tree'):
            return  # Tab doesn't exist, nothing to do

        # If the tree somehow exists (shouldn't happen), just clear it
        try:
            for item in self.run_to_failure_tree.get_children():
                self.run_to_failure_tree.delete(item)
        except Exception as e:
            # Silently ignore errors since this functionality is deprecated
            pass
            
            
    # 9. EXPORT CANNOT FIND TO PDF
    def export_deactivated_pdf(self):
        """Export Deactivated assets to PDF"""
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            default_filename = f"Deactivated_Assets_{timestamp}.pdf"

            # Ask user where to save the file
            filename = filedialog.asksaveasfilename(
                title="Save Deactivated Assets Report",
                initialdir=os.path.expanduser("~/Documents"),
                initialfile=default_filename,
                defaultextension=".pdf",
                filetypes=[("PDF files", "*.pdf"), ("All files", "*.*")]
            )

            if not filename:
                return  # User cancelled

            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT
                    da.bfm_equipment_no,
                    e.sap_material_no,
                    da.description,
                    da.location,
                    da.deactivated_by,
                    da.deactivated_date,
                    da.reason,
                    da.notes
                FROM deactivated_assets da
                LEFT JOIN equipment e ON da.bfm_equipment_no = e.bfm_equipment_no
                WHERE da.status = 'Deactivated'
                ORDER BY da.deactivated_date DESC
            ''')

            assets = cursor.fetchall()

            doc = SimpleDocTemplate(filename, pagesize=letter)
            story = []
            styles = getSampleStyleSheet()

            # Title
            title_style = ParagraphStyle('TitleStyle', parent=styles['Title'],
                                    fontSize=18, textColor=colors.darkred, alignment=1)
            story.append(Paragraph("AIRBUS AIT - DEACTIVATED ASSETS REPORT", title_style))
            story.append(Spacer(1, 20))

            # Report info
            story.append(Paragraph(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", styles['Normal']))
            story.append(Paragraph(f"Total Deactivated Assets: {len(assets)}", styles['Normal']))
            story.append(Spacer(1, 20))

            if assets:
                # Create table with proper column widths
                data = [['SAP No.', 'BFM No.', 'Description', 'Location', 'Deactivated By', 'Date', 'Reason']]

                # Create a style for wrapping text in cells with word wrap enabled
                cell_style = ParagraphStyle(
                    'CellStyle',
                    parent=styles['Normal'],
                    fontSize=8,
                    leading=10,
                    wordWrap='CJK'  # Enable word wrapping
                )

                for asset in assets:
                    bfm_no, sap_no, description, location, deactivated_by, deactivated_date, reason, notes = asset
                    data.append([
                        Paragraph(str(sap_no or 'N/A'), cell_style),
                        Paragraph(str(bfm_no or 'N/A'), cell_style),
                        Paragraph(str(description or ''), cell_style),
                        Paragraph(str(location or ''), cell_style),
                        Paragraph(str(deactivated_by or ''), cell_style),
                        Paragraph(str(deactivated_date or ''), cell_style),
                        Paragraph(str(reason or ''), cell_style)
                    ])

                # Adjusted column widths
                table = Table(data, colWidths=[0.85*inch, 0.85*inch, 1.8*inch, 0.9*inch, 0.9*inch, 0.8*inch, 1.3*inch])
                table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
                    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                    ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, 0), 9),
                    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                    ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black),
                    ('TOPPADDING', (0, 1), (-1, -1), 6),
                    ('BOTTOMPADDING', (0, 1), (-1, -1), 6),
                    ('WORDWRAP', (0, 0), (-1, -1), True)
                ]))

                story.append(table)
            else:
                story.append(Paragraph("No deactivated assets found.", styles['Normal']))

            doc.build(story)
            messagebox.showinfo("Success", f"Deactivated Assets report exported to: {filename}")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to export PDF: {str(e)}")

    def export_cannot_find_pdf(self):
        """Export Cannot Find assets to PDF"""
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            default_filename = f"Cannot_Find_Assets_{timestamp}.pdf"

            # Ask user where to save the file
            filename = filedialog.asksaveasfilename(
                title="Save Cannot Find Assets Report",
                initialdir=os.path.expanduser("~/Documents"),
                initialfile=default_filename,
                defaultextension=".pdf",
                filetypes=[("PDF files", "*.pdf"), ("All files", "*.*")]
            )

            if not filename:
                return  # User cancelled

            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT
                    cf.bfm_equipment_no,
                    e.sap_material_no,
                    cf.description,
                    cf.location,
                    cf.technician_name,
                    cf.reported_date,
                    cf.notes
                FROM cannot_find_assets cf
                LEFT JOIN equipment e ON cf.bfm_equipment_no = e.bfm_equipment_no
                WHERE cf.status = 'Missing'
                ORDER BY cf.reported_date DESC
            ''')

            assets = cursor.fetchall()

            doc = SimpleDocTemplate(filename, pagesize=letter)
            story = []
            styles = getSampleStyleSheet()

            # Title
            title_style = ParagraphStyle('TitleStyle', parent=styles['Title'],
                                    fontSize=18, textColor=colors.darkred, alignment=1)
            story.append(Paragraph("AIRBUS AIT - CANNOT FIND ASSETS REPORT", title_style))
            story.append(Spacer(1, 20))

            # Report info
            story.append(Paragraph(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", styles['Normal']))
            story.append(Paragraph(f"Total Missing Assets: {len(assets)}", styles['Normal']))
            story.append(Spacer(1, 20))

            if assets:
                # Create table with proper column widths
                data = [['SAP No.', 'BFM No.', 'Description', 'Location', 'Reported By', 'Report Date']]

                # Create a style for wrapping text in cells with word wrap enabled
                cell_style = ParagraphStyle(
                    'CellStyle',
                    parent=styles['Normal'],
                    fontSize=8,
                    leading=10,
                    wordWrap='CJK'  # Enable word wrapping
                )

                for asset in assets:
                    bfm_no, sap_no, description, location, technician, reported_date, notes = asset
                    data.append([
                        Paragraph(str(sap_no or 'N/A'), cell_style),
                        Paragraph(str(bfm_no or 'N/A'), cell_style),
                        Paragraph(str(description or ''), cell_style),
                        Paragraph(str(location or ''), cell_style),
                        Paragraph(str(technician or ''), cell_style),
                        Paragraph(str(reported_date or ''), cell_style)
                    ])

                # Adjusted column widths to fit both SAP and BFM numbers
                table = Table(data, colWidths=[0.95*inch, 0.95*inch, 2.4*inch, 1.1*inch, 1.1*inch, 0.9*inch])
                table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
                    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                    ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, 0), 9),
                    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                    ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black),
                    ('TOPPADDING', (0, 1), (-1, -1), 6),
                    ('BOTTOMPADDING', (0, 1), (-1, -1), 6),
                    ('WORDWRAP', (0, 0), (-1, -1), True)
                ]))
            
                story.append(table)
            else:
                story.append(Paragraph("No missing assets found.", styles['Normal']))
        
            doc.build(story)
            messagebox.showinfo("Success", f"Cannot Find report exported to: {filename}")
        
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export Cannot Find report: {str(e)}")

    # 10. EXPORT RUN TO FAILURE TO PDF
    def export_run_to_failure_pdf(self):
        """Stubbed out - Run to Failure functionality replaced with Deactivated tab"""
        messagebox.showinfo("Feature Replaced",
                          "The Run to Failure feature has been replaced with the Deactivated Assets feature.\n\n"
                          "Please use the 'Deactivated' tab and 'Export to PDF' button to export deactivated assets.")

    # 11. MARK ASSET AS FOUND
    def mark_asset_found(self):
        """Mark a cannot find asset as found and reactivate with PM configuration"""
        selected = self.cannot_find_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select an asset to mark as found")
            return

        item = self.cannot_find_tree.item(selected[0])
        bfm_no = str(item['values'][0])
        description = str(item['values'][1]) if len(item['values']) > 1 else "N/A"

        # Create reactivation dialog
        dialog = tk.Toplevel(self.root)
        dialog.title(f"Reactivate Asset - {bfm_no}")
        dialog.geometry("700x550")
        dialog.transient(self.root)
        dialog.grab_set()

        # Center the dialog
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (700 // 2)
        y = (dialog.winfo_screenheight() // 2) - (550 // 2)
        dialog.geometry(f"700x550+{x}+{y}")

        # Header
        header_frame = ttk.Frame(dialog, padding=15)
        header_frame.pack(fill='x')

        ttk.Label(header_frame, text=f"Reactivate Found Asset for PM Scheduling",
                font=('Arial', 14, 'bold')).pack()
        ttk.Label(header_frame, text=f"BFM: {bfm_no}",
                font=('Arial', 10)).pack(pady=5)
        ttk.Label(header_frame, text=f"Description: {description}",
                font=('Arial', 9), wraplength=650).pack()

        # Separator
        ttk.Separator(dialog, orient='horizontal').pack(fill='x', pady=10)

        # PM Frequency Selection Frame
        pm_frame = ttk.LabelFrame(dialog, text="Select PM Frequencies to Enable", padding=20)
        pm_frame.pack(fill='x', padx=20, pady=10)

        ttk.Label(pm_frame, text="Choose which preventive maintenance schedules to enable:",
                font=('Arial', 10)).pack(anchor='w', pady=(0, 15))

        # PM Type Checkboxes
        monthly_var = tk.BooleanVar(value=True)  # Default: Monthly enabled
        six_month_var = tk.BooleanVar(value=False)  # Default: Six Month disabled
        annual_var = tk.BooleanVar(value=True)  # Default: Annual enabled

        # Monthly PM
        monthly_frame = ttk.Frame(pm_frame)
        monthly_frame.pack(fill='x', pady=5)
        monthly_cb = ttk.Checkbutton(monthly_frame, text="Monthly PM (every 30 days)",
                                    variable=monthly_var)
        monthly_cb.pack(side='left')
        ttk.Label(monthly_frame, text="Recommended for most equipment",
                foreground='green', font=('Arial', 8, 'italic')).pack(side='left', padx=10)

        # Six Month PM
        six_month_frame = ttk.Frame(pm_frame)
        six_month_frame.pack(fill='x', pady=5)
        six_month_cb = ttk.Checkbutton(six_month_frame, text="Six Month PM (every 180 days)",
                                       variable=six_month_var)
        six_month_cb.pack(side='left')
        ttk.Label(six_month_frame, text="For semi-annual maintenance",
                foreground='blue', font=('Arial', 8, 'italic')).pack(side='left', padx=10)

        # Annual PM
        annual_frame = ttk.Frame(pm_frame)
        annual_frame.pack(fill='x', pady=5)
        annual_cb = ttk.Checkbutton(annual_frame, text="Annual PM (every 365 days)",
                                    variable=annual_var)
        annual_cb.pack(side='left')
        ttk.Label(annual_frame, text="For yearly inspection",
                foreground='orange', font=('Arial', 8, 'italic')).pack(side='left', padx=10)

        # Information text
        info_frame = ttk.Frame(dialog, padding=20)
        info_frame.pack(fill='x', padx=20, pady=10)

        info_text = ("The asset will be:\n"
                    " Removed from the Cannot Find list\n"
                    " Set to Active status in the main equipment list\n"
                    " Scheduled for the selected preventive maintenance frequencies")

        ttk.Label(info_frame, text=info_text, font=('Arial', 9),
                foreground='#444444', justify='left').pack(anchor='w')

        def validate_and_reactivate():
            """Validate selections and perform reactivation"""
            # Validate at least one PM is selected
            if not monthly_var.get() and not six_month_var.get() and not annual_var.get():
                messagebox.showerror("Validation Error",
                                   "You must select at least one PM frequency to reactivate.\n\n"
                                   "If you don't want to schedule PMs, leave the asset in Cannot Find status.")
                return

            # Build PM list
            pm_list = []
            if monthly_var.get():
                pm_list.append("Monthly")
            if six_month_var.get():
                pm_list.append("Six Month")
            if annual_var.get():
                pm_list.append("Annual")

            pm_enabled = ", ".join(pm_list)

            # Confirmation
            confirm_msg = (f"Reactivate asset {bfm_no}?\n\n"
                          f"Equipment will be:\n"
                          f" Set to Active status\n"
                          f" PM Frequencies: {pm_enabled}\n"
                          f" Removed from Cannot Find list\n\n"
                          f"Continue?")

            result = messagebox.askyesno("Confirm Reactivation", confirm_msg)

            if not result:
                return

            # Perform reactivation
            try:
                cursor = self.conn.cursor()

                # Update equipment status and enable selected PMs
                cursor.execute('''
                    UPDATE equipment SET
                    status = 'Active',
                    monthly_pm = %s,
                    six_month_pm = %s,
                    annual_pm = %s,
                    updated_date = CURRENT_TIMESTAMP
                    WHERE bfm_equipment_no = %s
                ''', (
                    True if monthly_var.get() else False,
                    True if six_month_var.get() else False,
                    True if annual_var.get() else False,
                    bfm_no
                ))

                # Update cannot_find_assets record instead of deleting (for historical tracking)
                # Mark as Found with date and user
                found_by = getattr(self, 'current_user', 'System')  # Get current user if available
                cursor.execute('''
                    UPDATE cannot_find_assets
                    SET status = 'Found',
                        found_date = CURRENT_DATE,
                        found_by = %s,
                        updated_date = CURRENT_TIMESTAMP
                    WHERE bfm_equipment_no = %s
                ''', (found_by, bfm_no))

                # Update any "Cannot Find" PM schedules back to "Scheduled"
                cursor.execute('''
                    UPDATE weekly_pm_schedules
                    SET status = 'Scheduled'
                    WHERE bfm_equipment_no = %s AND status = 'Cannot Find'
                ''', (bfm_no,))

                self.conn.commit()

                messagebox.showinfo(
                    "Success",
                    f"Asset {bfm_no} successfully reactivated!\n\n"
                    f"Status: Active\n"
                    f"PMs Enabled: {pm_enabled}\n\n"
                    f"Equipment moved back to main equipment list"
                )

                dialog.destroy()

                # Refresh all displays
                self.refresh_equipment_list()
                self.load_cannot_find_assets()
                self.update_equipment_statistics()

                self.update_status(f"Reactivated asset {bfm_no} with {pm_enabled} PMs")

            except Exception as e:
                messagebox.showerror("Error", f"Failed to reactivate asset: {str(e)}")

        # Buttons
        button_frame = ttk.Frame(dialog)
        button_frame.pack(fill='x', padx=20, pady=15)

        ttk.Button(button_frame, text="Reactivate Asset",
                   command=validate_and_reactivate,
                   style='Accent.TButton').pack(side='right', padx=5)
        ttk.Button(button_frame, text="Cancel",
                   command=dialog.destroy).pack(side='right')

    def reactivate_deactivated_asset(self):
        """Reactivate a deactivated asset and restore with PM configuration"""
        selected = self.deactivated_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select an asset to reactivate")
            return

        item = self.deactivated_tree.item(selected[0])
        bfm_no = str(item['values'][0])
        description = str(item['values'][1]) if len(item['values']) > 1 else "N/A"

        # Create reactivation dialog
        dialog = tk.Toplevel(self.root)
        dialog.title(f"Reactivate Asset - {bfm_no}")
        dialog.geometry("700x550")
        dialog.transient(self.root)
        dialog.grab_set()

        # Center the dialog
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (700 // 2)
        y = (dialog.winfo_screenheight() // 2) - (550 // 2)
        dialog.geometry(f"700x550+{x}+{y}")

        # Header
        header_frame = ttk.Frame(dialog, padding=15)
        header_frame.pack(fill='x')

        ttk.Label(header_frame, text=f"Reactivate Deactivated Asset for PM Scheduling",
                font=('Arial', 14, 'bold')).pack()
        ttk.Label(header_frame, text=f"BFM: {bfm_no}",
                font=('Arial', 10)).pack(pady=5)
        ttk.Label(header_frame, text=f"Description: {description}",
                font=('Arial', 9), wraplength=650).pack()

        # Separator
        ttk.Separator(dialog, orient='horizontal').pack(fill='x', pady=10)

        # PM Frequency Selection Frame
        pm_frame = ttk.LabelFrame(dialog, text="Select PM Frequencies to Enable", padding=20)
        pm_frame.pack(fill='x', padx=20, pady=10)

        ttk.Label(pm_frame, text="Choose which preventive maintenance schedules to enable:",
                font=('Arial', 10)).pack(anchor='w', pady=(0, 15))

        # PM Type Checkboxes
        monthly_var = tk.BooleanVar(value=True)  # Default: Monthly enabled
        six_month_var = tk.BooleanVar(value=False)  # Default: Six Month disabled
        annual_var = tk.BooleanVar(value=True)  # Default: Annual enabled

        # Monthly PM
        monthly_frame = ttk.Frame(pm_frame)
        monthly_frame.pack(fill='x', pady=5)
        monthly_cb = ttk.Checkbutton(monthly_frame, text="Monthly PM (every 30 days)",
                                    variable=monthly_var)
        monthly_cb.pack(side='left')
        ttk.Label(monthly_frame, text="Recommended for most equipment",
                foreground='green', font=('Arial', 8, 'italic')).pack(side='left', padx=10)

        # Six Month PM
        six_month_frame = ttk.Frame(pm_frame)
        six_month_frame.pack(fill='x', pady=5)
        six_month_cb = ttk.Checkbutton(six_month_frame, text="Six Month PM (every 180 days)",
                                       variable=six_month_var)
        six_month_cb.pack(side='left')
        ttk.Label(six_month_frame, text="For semi-annual maintenance",
                foreground='blue', font=('Arial', 8, 'italic')).pack(side='left', padx=10)

        # Annual PM
        annual_frame = ttk.Frame(pm_frame)
        annual_frame.pack(fill='x', pady=5)
        annual_cb = ttk.Checkbutton(annual_frame, text="Annual PM (every 365 days)",
                                    variable=annual_var)
        annual_cb.pack(side='left')
        ttk.Label(annual_frame, text="For yearly inspection",
                foreground='orange', font=('Arial', 8, 'italic')).pack(side='left', padx=10)

        # Information text
        info_frame = ttk.Frame(dialog, padding=20)
        info_frame.pack(fill='x', padx=20, pady=10)

        info_text = ("The asset will be:\n"
                    " Removed from the Deactivated list\n"
                    " Set to Active status in the main equipment list\n"
                    " Scheduled for the selected preventive maintenance frequencies")

        ttk.Label(info_frame, text=info_text, font=('Arial', 9),
                foreground='#444444', justify='left').pack(anchor='w')

        def validate_and_reactivate():
            """Validate selections and perform reactivation"""
            # Validate at least one PM is selected
            if not monthly_var.get() and not six_month_var.get() and not annual_var.get():
                messagebox.showerror("Validation Error",
                                   "You must select at least one PM frequency to reactivate.\n\n"
                                   "If you don't want to schedule PMs, leave the asset in Deactivated status.")
                return

            # Build PM list
            pm_list = []
            if monthly_var.get():
                pm_list.append("Monthly")
            if six_month_var.get():
                pm_list.append("Six Month")
            if annual_var.get():
                pm_list.append("Annual")

            pm_enabled = ", ".join(pm_list)

            # Confirmation
            confirm_msg = (f"Reactivate asset {bfm_no}?\n\n"
                          f"Equipment will be:\n"
                          f" Set to Active status\n"
                          f" PM Frequencies: {pm_enabled}\n"
                          f" Removed from Deactivated list\n\n"
                          f"Continue?")

            result = messagebox.askyesno("Confirm Reactivation", confirm_msg)

            if not result:
                return

            # Perform reactivation
            try:
                cursor = self.conn.cursor()

                # Update equipment status and enable selected PMs
                cursor.execute('''
                    UPDATE equipment SET
                    status = 'Active',
                    monthly_pm = %s,
                    six_month_pm = %s,
                    annual_pm = %s,
                    updated_date = CURRENT_TIMESTAMP
                    WHERE bfm_equipment_no = %s
                ''', (
                    True if monthly_var.get() else False,
                    True if six_month_var.get() else False,
                    True if annual_var.get() else False,
                    bfm_no
                ))

                # Remove from deactivated_assets table
                cursor.execute('''
                    DELETE FROM deactivated_assets
                    WHERE bfm_equipment_no = %s
                ''', (bfm_no,))

                # Update any "Deactivated" PM schedules back to "Scheduled"
                cursor.execute('''
                    UPDATE weekly_pm_schedules
                    SET status = 'Scheduled'
                    WHERE bfm_equipment_no = %s AND status = 'Deactivated'
                ''', (bfm_no,))

                self.conn.commit()

                messagebox.showinfo(
                    "Success",
                    f"Asset {bfm_no} successfully reactivated!\n\n"
                    f"Status: Active\n"
                    f"PMs Enabled: {pm_enabled}\n\n"
                    f"Equipment moved back to main equipment list"
                )

                dialog.destroy()

                # Refresh all displays
                self.refresh_equipment_list()
                self.load_deactivated_assets()
                self.update_equipment_statistics()

                self.update_status(f"Reactivated asset {bfm_no} with {pm_enabled} PMs")

            except Exception as e:
                messagebox.showerror("Error", f"Failed to reactivate asset: {str(e)}")

        # Buttons
        button_frame = ttk.Frame(dialog)
        button_frame.pack(fill='x', padx=20, pady=15)

        ttk.Button(button_frame, text="Reactivate Asset",
                   command=validate_and_reactivate,
                   style='Accent.TButton').pack(side='right', padx=5)
        ttk.Button(button_frame, text="Cancel",
                   command=dialog.destroy).pack(side='right')

    # 12. REACTIVATE ASSET
    def reactivate_asset(self):
        """Stubbed out - Run to Failure functionality replaced with Deactivated tab"""
        messagebox.showinfo("Feature Replaced",
                          "The Run to Failure feature has been replaced with the Deactivated Assets feature.\n\n"
                          "To reactivate assets:\n"
                          "1. Go to the 'Deactivated' tab\n"
                          "2. Select the asset(s) to reactivate\n"
                          "3. Click 'Reactivate Asset' button")
        return

    def clear_completion_form(self):
        """Clear the PM completion form"""
        self.completion_bfm_var.set('')
        self.pm_type_var.set('')
        self.completion_tech_var.set('')
        self.labor_hours_var.set('0')
        self.labor_minutes_var.set('0')
        self.pm_due_date_var.set('')
        self.special_equipment_var.set('')
        self.notes_text.delete('1.0', 'end')
        self.next_annual_pm_var.set('')
    
    def load_recent_completions(self):
        """Load recent PM completions with debugging"""
        print("DEBUG: load_recent_completions called")
        
        # ADD THIS SAFETY CHECK AT THE VERY BEGINNING:
        if not hasattr(self, 'recent_completions_tree'):
            print("DEBUG: recent_completions_tree not yet created, skipping load")
            return
        
        
        
        try:
            cursor = self.conn.cursor()
            print("DEBUG: Database cursor created")
        
            cursor.execute('''
                SELECT completion_date, bfm_equipment_no, pm_type, technician_name, 
                    (labor_hours + labor_minutes/60.0) as total_hours
                FROM pm_completions 
                ORDER BY completion_date DESC, id DESC LIMIT 500
            ''')
        
            completions = cursor.fetchall()
            print(f"DEBUG: Found {len(completions)} completions in database")
        
            # Clear existing items
            for item in self.recent_completions_tree.get_children():
                self.recent_completions_tree.delete(item)
            print("DEBUG: Cleared existing tree items")
        
            # Add recent completions
            for idx, completion in enumerate(completions):
                completion_date, bfm_no, pm_type, technician, total_hours = completion
                hours_display = f"{total_hours:.1f}h" if total_hours else "0.0h"

                self.recent_completions_tree.insert('', 'end', values=(
                    completion_date, bfm_no, pm_type, technician, hours_display
                ))
                print(f"DEBUG: Added {bfm_no} - {pm_type} - {technician}")

                # Yield to event loop every 50 items to keep UI responsive
                if idx % 50 == 0:
                    self.root.update_idletasks()
        
            print("DEBUG: Successfully loaded recent completions")
            print(f"Refreshed: {len(completions)} recent completions loaded")
        
        except Exception as e:
            print(f"ERROR in load_recent_completions: {e}")
            import traceback
            traceback.print_exc()
    
    def generate_current_week_report(self):
        """Generate report for current week"""
        try:
            week_start = datetime.strptime(self.week_start_var.get(), '%Y-%m-%d')
            week_end = week_start + timedelta(days=6)
            
            cursor = self.conn.cursor()
            
            # Get weekly statistics
            cursor.execute('''
                SELECT 
                    COUNT(*) as total_scheduled,
                    COUNT(CASE WHEN status = 'Completed' THEN 1 END) as total_completed
                FROM weekly_pm_schedules 
                WHERE week_start_date = %s
            ''', (week_start.strftime('%Y-%m-%d'),))
            
            total_scheduled, total_completed = cursor.fetchone()
            completion_rate = (total_completed / total_scheduled * 100) if total_scheduled > 0 else 0
            
            # Get technician performance
            cursor.execute('''
                SELECT 
                    assigned_technician,
                    COUNT(*) as assigned,
                    COUNT(CASE WHEN status = 'Completed' THEN 1 END) as completed,
                    AVG(CASE WHEN status = 'Completed' THEN labor_hours END) as avg_hours
                FROM weekly_pm_schedules 
                WHERE week_start_date = %s
                GROUP BY assigned_technician
                ORDER BY assigned_technician
            ''', (week_start.strftime('%Y-%m-%d'),))
            
            tech_performance = cursor.fetchall()
            
            # Generate report text
            report = f"WEEKLY PM PERFORMANCE REPORT\n"
            report += f"Week: {week_start.strftime('%Y-%m-%d')} to {week_end.strftime('%Y-%m-%d')}\n"
            report += "=" * 80 + "\n\n"
            
            report += f"OVERALL PERFORMANCE:\n"
            report += f"Target PMs for Week: {self.weekly_pm_target}\n"
            report += f"Scheduled PMs: {total_scheduled}\n"
            report += f"Completed PMs: {total_completed}\n"
            report += f"Completion Rate: {completion_rate:.1f}%\n"
            report += f"Remaining PMs: {total_scheduled - total_completed}\n\n"
            
            # Performance status
            if completion_rate >= 95:
                status = "EXCELLENT"
            elif completion_rate >= 85:
                status = "GOOD"
            elif completion_rate >= 75:
                status = "SATISFACTORY"
            else:
                status = "NEEDS IMPROVEMENT"
            
            report += f"PERFORMANCE STATUS: {status}\n\n"
            
            report += "TECHNICIAN PERFORMANCE:\n"
            report += f"{'Technician':<20} {'Assigned':<10} {'Completed':<10} {'Rate':<8} {'Avg Hours':<10}\n"
            report += "-" * 70 + "\n"
            
            # Clear and update technician performance tree
            for item in self.tech_performance_tree.get_children():
                self.tech_performance_tree.delete(item)
            
            for tech_data in tech_performance:
                technician, assigned, completed, avg_hours = tech_data
                tech_rate = (completed / assigned * 100) if assigned > 0 else 0
                avg_hours_display = f"{avg_hours:.1f}h" if avg_hours else "N/A"
                
                report += f"{technician:<20} {assigned:<10} {completed:<10} {tech_rate:<7.1f}% {avg_hours_display:<10}\n"
                
                # Add to tree
                self.tech_performance_tree.insert('', 'end', values=(
                    technician, assigned, completed, f"{tech_rate:.1f}%", avg_hours_display
                ))
            
            # Add PM type breakdown
            cursor.execute('''
                SELECT pm_type, 
                       COUNT(*) as scheduled,
                       COUNT(CASE WHEN status = 'Completed' THEN 1 END) as completed
                FROM weekly_pm_schedules 
                WHERE week_start_date = %s
                GROUP BY pm_type
            ''', (week_start.strftime('%Y-%m-%d'),))
            
            pm_types = cursor.fetchall()
            
            if pm_types:
                report += "\nPM TYPE BREAKDOWN:\n"
                report += f"{'PM Type':<15} {'Scheduled':<10} {'Completed':<10} {'Rate':<8}\n"
                report += "-" * 45 + "\n"
                
                for pm_type, scheduled, completed in pm_types:
                    pm_rate = (completed / scheduled * 100) if scheduled > 0 else 0
                    report += f"{pm_type:<15} {scheduled:<10} {completed:<10} {pm_rate:<7.1f}%\n"
            
            # Display report
            self.weekly_report_text.delete('1.0', 'end')
            self.weekly_report_text.insert('end', report)
            
            # Save report to database
            cursor.execute('''
                INSERT OR REPLACE INTO weekly_reports 
                (week_start_date, total_scheduled, total_completed, completion_rate, 
                 technician_performance, report_data)
                VALUES (%s, %s, %s, %s, %s, %s)
            ''', (
                week_start.strftime('%Y-%m-%d'),
                total_scheduled,
                total_completed,
                completion_rate,
                json.dumps(tech_performance),
                report
            ))
            
            self.conn.commit()
            self.update_status(f"Weekly report generated - {completion_rate:.1f}% completion rate")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to generate weekly report: {str(e)}")
    
    def generate_monthly_report(self):
        """Generate monthly PM performance report"""
        try:
            # Rollback any failed transaction before starting
            self.conn.rollback()

            current_date = datetime.now()
            month_start = current_date.replace(day=1)

            cursor = self.conn.cursor()
            
            # Get monthly statistics from weekly reports
            cursor.execute('''
                SELECT week_start_date, total_scheduled, total_completed, completion_rate
                FROM weekly_reports 
                WHERE week_start_date >= DATE_TRUNC('month', %s::date)
                ORDER BY week_start_date
            ''', (current_date.strftime('%Y-%m-%d'),))
            
            weekly_data = cursor.fetchall()
            
            # Get monthly PM completions
            cursor.execute('''
                SELECT 
                    pm_type,
                    COUNT(*) as total_completed,
                    AVG(labor_hours + labor_minutes/60.0) as avg_hours
                FROM pm_completions 
                WHERE completion_date >= DATE_TRUNC('month', %s::date)
                GROUP BY pm_type
            ''', (current_date.strftime('%Y-%m-%d'),))
            
            monthly_completions = cursor.fetchall()
            
            # Generate monthly report
            report = f"MONTHLY PM PERFORMANCE REPORT\n"
            report += f"Month: {current_date.strftime('%B %Y')}\n"
            report += "=" * 80 + "\n\n"
            
            if weekly_data:
                total_scheduled = sum(row[1] for row in weekly_data)
                total_completed = sum(row[2] for row in weekly_data)
                avg_completion_rate = sum(row[3] for row in weekly_data) / len(weekly_data)
                
                report += f"MONTHLY SUMMARY:\n"
                report += f"Total Weeks Reported: {len(weekly_data)}\n"
                report += f"Total PMs Scheduled: {total_scheduled}\n"
                report += f"Total PMs Completed: {total_completed}\n"
                report += f"Average Completion Rate: {avg_completion_rate:.1f}%\n"
                report += f"Monthly Target ({len(weekly_data)} weeks  {self.weekly_pm_target}): {len(weekly_data) * self.weekly_pm_target}\n\n"
                
                report += "WEEKLY BREAKDOWN:\n"
                report += f"{'Week Starting':<15} {'Scheduled':<10} {'Completed':<10} {'Rate':<8}\n"
                report += "-" * 45 + "\n"
                
                for week_start, scheduled, completed, rate in weekly_data:
                    report += f"{week_start:<15} {scheduled:<10} {completed:<10} {rate:<7.1f}%\n"
            
            if monthly_completions:
                report += "\nPM TYPE PERFORMANCE (Month):\n"
                report += f"{'PM Type':<15} {'Completed':<10} {'Avg Hours':<10}\n"
                report += "-" * 37 + "\n"
                
                for pm_type, completed, avg_hours in monthly_completions:
                    report += f"{pm_type:<15} {completed:<10} {avg_hours:<9.1f}h\n"
            
            # Display report
            self.weekly_report_text.delete('1.0', 'end')
            self.weekly_report_text.insert('end', report)
            
            self.update_status("Monthly report generated")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to generate monthly report: {str(e)}")
    
    def export_reports(self):
        """Export reports to file"""
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"PM_Reports_{timestamp}.txt"
            
            content = self.weekly_report_text.get('1.0', 'end-1c')
            
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(content)
            
            messagebox.showinfo("Success", f"Reports exported to: {filename}")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export reports: {str(e)}")
    
    
    
    
    def create_cm_dialog(self):
        """Create new Corrective Maintenance with calendar date picker"""
        dialog = tk.Toplevel(self.root)
        dialog.title("Create New Corrective Maintenance")
        dialog.geometry("600x550")
        dialog.transient(self.root)
        dialog.grab_set()

        # Generate next CM number in format CM-YYYYMMDD-XXXX
        cursor = self.conn.cursor()
        today = datetime.now().strftime('%Y%m%d')
        cursor.execute(
            "SELECT MAX(CAST(SPLIT_PART(cm_number, '-', 3) AS INTEGER)) "
            "FROM corrective_maintenance "
            "WHERE cm_number LIKE %s",
            (f'CM-{today}-%',)
        )
        result = cursor.fetchone()[0]
        next_seq = (result + 1) if result else 1
        next_cm_num = f"CM-{today}-{next_seq:04d}"

        row = 0

        # CM Number (auto-generated, read-only)
        ttk.Label(dialog, text="CM Number:", font=('Arial', 10, 'bold')).grid(row=row, column=0, sticky='w', padx=10, pady=5)
        cm_number_var = tk.StringVar(value=next_cm_num)
        ttk.Entry(dialog, textvariable=cm_number_var, width=20, state='readonly').grid(row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1

        # ========== ENHANCED DATE PICKER SECTION ==========
        ttk.Label(dialog, text="CM Date:", font=('Arial', 10)).grid(row=row, column=0, sticky='w', padx=10, pady=5)
        
        # Create frame for date entry and calendar button
        date_frame = ttk.Frame(dialog)
        date_frame.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        
        # Date entry field - default to today's date
        cm_date_var = tk.StringVar(value=datetime.now().strftime('%Y-%m-%d'))
        date_entry = ttk.Entry(date_frame, textvariable=cm_date_var, width=15)
        date_entry.pack(side='left', padx=(0, 5))
        
        # Calendar picker button
        def open_calendar():
            """Open calendar dialog to pick a date"""
            from tkcalendar import Calendar
        
            # Create calendar dialog
            cal_dialog = tk.Toplevel(dialog)
            cal_dialog.title("Select Date")
            cal_dialog.geometry("300x300")
            cal_dialog.transient(dialog)
            cal_dialog.grab_set()
        
            # Parse current date or use today
            try:
                current_date = datetime.strptime(cm_date_var.get(), '%Y-%m-%d')
            except:
                current_date = datetime.now()
        
            # Create calendar widget
            cal = Calendar(cal_dialog, 
                          selectmode='day',
                          year=current_date.year,
                          month=current_date.month,
                          day=current_date.day,
                          date_pattern='yyyy-mm-dd')
            cal.pack(pady=20, padx=20, fill='both', expand=True)
        
            def select_date():
                cm_date_var.set(cal.get_date())
                cal_dialog.destroy()
        
            # Buttons
            button_frame = ttk.Frame(cal_dialog)
            button_frame.pack(pady=10)
            ttk.Button(button_frame, text="Select", command=select_date).pack(side='left', padx=5)
            ttk.Button(button_frame, text="Today", 
                    command=lambda: [cm_date_var.set(datetime.now().strftime('%Y-%m-%d')), 
                                    cal_dialog.destroy()]).pack(side='left', padx=5)
            ttk.Button(button_frame, text="Cancel", command=cal_dialog.destroy).pack(side='left', padx=5)
    
        # Calendar button with icon
        ttk.Button(date_frame, text="Pick Date", command=open_calendar).pack(side='left')
        
        # Date format helper label
        ttk.Label(dialog, text="Format: YYYY-MM-DD", 
                font=('Arial', 8), foreground='gray').grid(row=row, column=2, sticky='w', padx=5)
        row += 1
        # ================================================

        # Equipment Selection
        ttk.Label(dialog, text="Equipment (BFM):").grid(row=row, column=0, sticky='w', padx=10, pady=5)
        bfm_var = tk.StringVar()
        
        cursor.execute("SELECT DISTINCT bfm_equipment_no FROM equipment WHERE status = 'Active' ORDER BY bfm_equipment_no")
        equipment_list = [row[0] for row in cursor.fetchall()]
        
        bfm_combo = ttk.Combobox(dialog, textvariable=bfm_var, values=equipment_list, width=20)
        bfm_combo.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1

        # Description
        ttk.Label(dialog, text="Description:").grid(row=row, column=0, sticky='nw', padx=10, pady=5)
        description_text = tk.Text(dialog, width=40, height=6)
        description_text.grid(row=row, column=1, columnspan=2, sticky='w', padx=10, pady=5)
        row += 1

        # Priority
        ttk.Label(dialog, text="Priority:").grid(row=row, column=0, sticky='w', padx=10, pady=5)
        priority_var = tk.StringVar(value="Medium")
        priority_combo = ttk.Combobox(dialog, textvariable=priority_var, 
                                    values=["Low", "Medium", "High", "Critical"], 
                                    state="readonly", width=20)
        priority_combo.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1

        # Assigned Technician
        ttk.Label(dialog, text="Assigned Technician:").grid(row=row, column=0, sticky='w', padx=10, pady=5)
        assigned_var = tk.StringVar()

        if self.current_user_role == 'Technician':
            # Auto-assign to current technician and make read-only
            assigned_var.set(self.user_name)
            assigned_entry = ttk.Entry(dialog, textvariable=assigned_var, width=20, state='readonly')
            assigned_entry.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        else:
            # Manager can assign to anyone
            assigned_combo = ttk.Combobox(dialog, textvariable=assigned_var, 
                                        values=self.technicians, width=20)
            assigned_combo.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1

        def validate_and_save_cm():
            """Validate the CM date format and save"""
            try:
                # Validate the date format
                cm_date_input = cm_date_var.get().strip()
        
                if not cm_date_input:
                    messagebox.showerror("Error", "Please enter a CM date")
                    return
        
                # Try to parse the date to validate format
                try:
                    parsed_date = datetime.strptime(cm_date_input, '%Y-%m-%d')
            
                    if parsed_date > datetime.now() + timedelta(days=1):
                        result = messagebox.askyesno("Future Date Warning", 
                                                f"The CM date '{cm_date_input}' is in the future.\n\n"
                                                f"Are you sure this is correct?")
                        if not result:
                            return
            
                    if parsed_date < datetime.now() - timedelta(days=365):
                        result = messagebox.askyesno("Old Date Warning", 
                                                f"The CM date '{cm_date_input}' is more than 1 year ago.\n\n"
                                                f"Are you sure this is correct?")
                        if not result:
                            return
            
                    validated_date = parsed_date.strftime('%Y-%m-%d')
            
                except ValueError:
                    messagebox.showerror("Invalid Date Format", 
                                    f"Please enter the date in YYYY-MM-DD format.\n\n"
                                    f"Examples:\n"
                                    f"- 2025-08-04 (August 4th, 2025)\n"
                                    f"- 2025-12-15 (December 15th, 2025)\n\n"
                                    f"You entered: '{cm_date_input}'")
                    return
        
                # Validate other required fields
                if not bfm_var.get():
                    messagebox.showerror("Error", "Please select equipment")
                    return
            
                if not description_text.get('1.0', 'end-1c').strip():
                    messagebox.showerror("Error", "Please enter a description")
                    return
        
                # Save to database with the manually entered date
                cursor = self.conn.cursor()
                cursor.execute('''
                    INSERT INTO corrective_maintenance 
                    (cm_number, bfm_equipment_no, description, priority, assigned_technician, created_date)
                    VALUES (%s, %s, %s, %s, %s, %s)
                ''', (
                    cm_number_var.get(),
                    bfm_var.get(),
                    description_text.get('1.0', 'end-1c'),
                    priority_var.get(),
                    assigned_var.get(),
                    validated_date
                ))
                self.conn.commit()
            
                messagebox.showinfo("Success", 
                                f"Corrective Maintenance created successfully!\n\n"
                                f"CM Number: {cm_number_var.get()}\n"
                                f"CM Date: {validated_date}\n"
                                f"Equipment: {bfm_var.get()}\n"
                                f"Assigned to: {assigned_var.get()}")
                dialog.destroy()
                self.load_corrective_maintenance()
        
            except Exception as e:
                messagebox.showerror("Error", f"Failed to create CM: {str(e)}")

        # Buttons
        button_frame = ttk.Frame(dialog)
        button_frame.grid(row=row, column=0, columnspan=3, pady=20)
        
        ttk.Button(button_frame, text="Create CM", command=validate_and_save_cm).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side='left', padx=5)


    def create_missing_parts_dialog(self):
        """Create new Equipment Missing Parts entry"""
        dialog = tk.Toplevel(self.root)
        dialog.title("Report Equipment with Missing Parts")
        dialog.geometry("650x700")
        dialog.transient(self.root)
        dialog.grab_set()

        # Generate next EMP number in format EMP-YYYYMMDD-XXXX
        try:
            cursor = self.conn.cursor()
            today = datetime.now().strftime('%Y%m%d')

            # Get the maximum sequence number for today
            cursor.execute(
                "SELECT MAX(CAST(SPLIT_PART(emp_number, '-', 3) AS INTEGER)) "
                "FROM equipment_missing_parts "
                "WHERE emp_number LIKE %s",
                (f'EMP-{today}-%',)
            )
            result = cursor.fetchone()[0]
            next_seq = (result + 1) if result else 1
            next_emp_num = f"EMP-{today}-{next_seq:04d}"

            print(f"DEBUG: Generated EMP number: {next_emp_num}")
            cursor.close()

        except Exception as e:
            print(f"Error generating EMP number: {e}")
            # Fallback to simple sequence
            next_emp_num = f"EMP-{datetime.now().strftime('%Y%m%d')}-0001"
            messagebox.showwarning("Warning", f"Could not generate sequence number, using default: {next_emp_num}")

        row = 0

        # EMP Number (auto-generated, read-only)
        ttk.Label(dialog, text="EMP Number:", font=('Arial', 10, 'bold')).grid(row=row, column=0, sticky='w', padx=10, pady=5)
        emp_number_var = tk.StringVar(value=next_emp_num)
        ttk.Entry(dialog, textvariable=emp_number_var, width=20, state='readonly').grid(row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1

        # Date Picker
        ttk.Label(dialog, text="Reported Date:", font=('Arial', 10)).grid(row=row, column=0, sticky='w', padx=10, pady=5)

        date_frame = ttk.Frame(dialog)
        date_frame.grid(row=row, column=1, sticky='w', padx=10, pady=5)

        emp_date_var = tk.StringVar(value=datetime.now().strftime('%Y-%m-%d'))
        date_entry = ttk.Entry(date_frame, textvariable=emp_date_var, width=15)
        date_entry.pack(side='left', padx=(0, 5))

        def open_calendar():
            """Open calendar dialog to pick a date"""
            from tkcalendar import Calendar

            cal_dialog = tk.Toplevel(dialog)
            cal_dialog.title("Select Date")
            cal_dialog.geometry("300x300")
            cal_dialog.transient(dialog)
            cal_dialog.grab_set()

            try:
                current_date = datetime.strptime(emp_date_var.get(), '%Y-%m-%d')
            except:
                current_date = datetime.now()

            cal = Calendar(cal_dialog,
                          selectmode='day',
                          year=current_date.year,
                          month=current_date.month,
                          day=current_date.day,
                          date_pattern='yyyy-mm-dd')
            cal.pack(pady=20, padx=20, fill='both', expand=True)

            def select_date():
                emp_date_var.set(cal.get_date())
                cal_dialog.destroy()

            button_frame_cal = ttk.Frame(cal_dialog)
            button_frame_cal.pack(pady=10)
            ttk.Button(button_frame_cal, text="Select", command=select_date).pack(side='left', padx=5)
            ttk.Button(button_frame_cal, text="Today",
                    command=lambda: [emp_date_var.set(datetime.now().strftime('%Y-%m-%d')),
                                    cal_dialog.destroy()]).pack(side='left', padx=5)
            ttk.Button(button_frame_cal, text="Cancel", command=cal_dialog.destroy).pack(side='left', padx=5)

        ttk.Button(date_frame, text="Pick Date", command=open_calendar).pack(side='left')
        ttk.Label(dialog, text="Format: YYYY-MM-DD",
                font=('Arial', 8), foreground='gray').grid(row=row, column=2, sticky='w', padx=5)
        row += 1

        # Equipment Selection
        ttk.Label(dialog, text="Equipment (BFM):").grid(row=row, column=0, sticky='w', padx=10, pady=5)
        bfm_var = tk.StringVar()

        # Create a new cursor for equipment query
        cursor = self.conn.cursor()
        cursor.execute("SELECT DISTINCT bfm_equipment_no FROM equipment WHERE status = 'Active' ORDER BY bfm_equipment_no")
        equipment_list = [row_data[0] for row_data in cursor.fetchall()]
        cursor.close()

        bfm_combo = ttk.Combobox(dialog, textvariable=bfm_var, values=equipment_list, width=20)
        bfm_combo.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1

        # SAP Material Number (auto-populated from equipment selection)
        ttk.Label(dialog, text="SAP Material No:").grid(row=row, column=0, sticky='w', padx=10, pady=5)
        sap_var = tk.StringVar()
        sap_entry = ttk.Entry(dialog, textvariable=sap_var, width=20)
        sap_entry.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1

        # Tool ID / Drawing Number (auto-populated from equipment selection)
        ttk.Label(dialog, text="Tool ID / Drawing No:").grid(row=row, column=0, sticky='w', padx=10, pady=5)
        tool_id_var = tk.StringVar()
        tool_id_entry = ttk.Entry(dialog, textvariable=tool_id_var, width=20)
        tool_id_entry.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1

        # Function to auto-populate SAP and Tool ID when BFM is selected
        def on_bfm_selected(event=None):
            """Auto-populate SAP and Tool ID when equipment is selected"""
            selected_bfm = bfm_var.get()
            if selected_bfm:
                try:
                    cursor = self.conn.cursor()
                    cursor.execute(
                        "SELECT sap_material_no, tool_id_drawing_no FROM equipment WHERE bfm_equipment_no = %s",
                        (selected_bfm,)
                    )
                    result = cursor.fetchone()
                    cursor.close()

                    if result:
                        sap_var.set(result[0] or 'N/A')
                        tool_id_var.set(result[1] or 'N/A')
                    else:
                        sap_var.set('N/A')
                        tool_id_var.set('N/A')
                except Exception as e:
                    print(f"Error fetching equipment details: {e}")
                    sap_var.set('N/A')
                    tool_id_var.set('N/A')

        # Bind the selection event to auto-populate fields
        bfm_combo.bind('<<ComboboxSelected>>', on_bfm_selected)

        # Description
        ttk.Label(dialog, text="Description:").grid(row=row, column=0, sticky='nw', padx=10, pady=5)
        description_text = tk.Text(dialog, width=40, height=4)
        description_text.grid(row=row, column=1, columnspan=2, sticky='w', padx=10, pady=5)
        row += 1

        # Missing Parts Description (The key differentiator)
        ttk.Label(dialog, text="Missing Parts:", font=('Arial', 10, 'bold')).grid(row=row, column=0, sticky='nw', padx=10, pady=5)
        ttk.Label(dialog, text="(List all missing parts)", font=('Arial', 8), foreground='gray').grid(row=row, column=1, sticky='w', padx=10, pady=0)
        row += 1
        missing_parts_text = tk.Text(dialog, width=40, height=6)
        missing_parts_text.grid(row=row, column=1, columnspan=2, sticky='w', padx=10, pady=5)
        row += 1

        # Priority
        ttk.Label(dialog, text="Priority:").grid(row=row, column=0, sticky='w', padx=10, pady=5)
        priority_var = tk.StringVar(value="Medium")
        priority_combo = ttk.Combobox(dialog, textvariable=priority_var,
                                    values=["Low", "Medium", "High", "Critical"],
                                    state="readonly", width=20)
        priority_combo.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1

        # Assigned Technician
        ttk.Label(dialog, text="Assigned Technician:").grid(row=row, column=0, sticky='w', padx=10, pady=5)
        assigned_var = tk.StringVar()

        if self.current_user_role == 'Technician':
            assigned_var.set(self.user_name)
            assigned_entry = ttk.Entry(dialog, textvariable=assigned_var, width=20, state='readonly')
            assigned_entry.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        else:
            assigned_combo = ttk.Combobox(dialog, textvariable=assigned_var,
                                        values=self.technicians, width=20)
            assigned_combo.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1

        # Notes (Optional)
        ttk.Label(dialog, text="Additional Notes:").grid(row=row, column=0, sticky='nw', padx=10, pady=5)
        notes_text = tk.Text(dialog, width=40, height=4)
        notes_text.grid(row=row, column=1, columnspan=2, sticky='w', padx=10, pady=5)
        row += 1

        def validate_and_save_emp():
            """Validate and save the missing parts entry"""
            try:
                emp_date_input = emp_date_var.get().strip()

                if not emp_date_input:
                    messagebox.showerror("Error", "Please enter a reported date")
                    return

                try:
                    parsed_date = datetime.strptime(emp_date_input, '%Y-%m-%d')

                    if parsed_date > datetime.now() + timedelta(days=1):
                        result = messagebox.askyesno("Future Date Warning",
                                                f"The date '{emp_date_input}' is in the future.\n\n"
                                                f"Are you sure this is correct?")
                        if not result:
                            return

                    if parsed_date < datetime.now() - timedelta(days=365):
                        result = messagebox.askyesno("Old Date Warning",
                                                f"The date '{emp_date_input}' is more than 1 year ago.\n\n"
                                                f"Are you sure this is correct?")
                        if not result:
                            return

                    validated_date = parsed_date.strftime('%Y-%m-%d')

                except ValueError:
                    messagebox.showerror("Invalid Date Format",
                                    f"Please enter the date in YYYY-MM-DD format.\n\n"
                                    f"Examples:\n"
                                    f"- 2025-08-04 (August 4th, 2025)\n"
                                    f"- 2025-12-15 (December 15th, 2025)\n\n"
                                    f"You entered: '{emp_date_input}'")
                    return

                if not bfm_var.get():
                    messagebox.showerror("Error", "Please select equipment")
                    return

                if not description_text.get('1.0', 'end-1c').strip():
                    messagebox.showerror("Error", "Please enter a description")
                    return

                if not missing_parts_text.get('1.0', 'end-1c').strip():
                    messagebox.showerror("Error", "Please enter missing parts details")
                    return

                # Save to database
                print(f"DEBUG: Attempting to save missing parts entry {emp_number_var.get()}")

                cursor = self.conn.cursor()
                cursor.execute('''
                    INSERT INTO equipment_missing_parts
                    (emp_number, bfm_equipment_no, description, priority, assigned_technician,
                     reported_date, missing_parts_description, notes, reported_by, status)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                ''', (
                    emp_number_var.get(),
                    bfm_var.get(),
                    description_text.get('1.0', 'end-1c'),
                    priority_var.get(),
                    assigned_var.get(),
                    validated_date,
                    missing_parts_text.get('1.0', 'end-1c'),
                    notes_text.get('1.0', 'end-1c'),
                    self.user_name,
                    'Open'
                ))
                self.conn.commit()
                cursor.close()

                print(f"DEBUG: Successfully saved missing parts entry {emp_number_var.get()}")

                messagebox.showinfo("Success",
                                f" Equipment Missing Parts entry created successfully!\n\n"
                                f"EMP Number: {emp_number_var.get()}\n"
                                f"Date: {validated_date}\n"
                                f"Equipment: {bfm_var.get()}\n"
                                f"Assigned to: {assigned_var.get()}\n\n"
                                f" Check the 'Equipment with Missing Parts' section below the CM list!")
                dialog.destroy()

                # Refresh the missing parts list to show the new entry
                print("DEBUG: Refreshing missing parts list...")
                self.load_missing_parts_list()

                # Update status bar
                if hasattr(self, 'update_status'):
                    self.update_status(f" Created missing parts entry: {emp_number_var.get()}")

            except Exception as e:
                messagebox.showerror("Error", f"Failed to create missing parts entry: {str(e)}")

        # Buttons
        button_frame = ttk.Frame(dialog)
        button_frame.grid(row=row, column=0, columnspan=3, pady=20)

        ttk.Button(button_frame, text="Create Entry", command=validate_and_save_emp).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side='left', padx=5)


    def edit_missing_parts_dialog(self):
        """Edit existing Equipment Missing Parts entry"""
        selected = self.emp_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select an equipment missing parts entry to edit")
            return

        # Get selected EMP data
        item = self.emp_tree.item(selected[0])
        emp_number = item['values'][0]

        # Fetch full EMP data from database
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT emp_number, bfm_equipment_no, description, priority, assigned_technician,
                status, reported_date, missing_parts_description, notes, reported_by,
                closed_date, closed_by
            FROM equipment_missing_parts
            WHERE emp_number = %s
        ''', (emp_number,))

        emp_data = cursor.fetchone()
        if not emp_data:
            messagebox.showerror("Error", "Equipment missing parts entry not found in database")
            return

        # Extract data
        (orig_emp_number, orig_bfm_no, orig_description, orig_priority, orig_assigned,
        orig_status, orig_reported_date, orig_missing_parts, orig_notes, orig_reported_by,
        orig_closed_date, orig_closed_by) = emp_data

        # Create edit dialog
        dialog = tk.Toplevel(self.root)
        dialog.title(f"Edit Equipment Missing Parts - {emp_number}")
        dialog.geometry("700x800")
        dialog.transient(self.root)
        dialog.grab_set()

        # Main container with scrollbar
        main_canvas = tk.Canvas(dialog)
        scrollbar = ttk.Scrollbar(dialog, orient="vertical", command=main_canvas.yview)
        scrollable_frame = ttk.Frame(main_canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: main_canvas.configure(scrollregion=main_canvas.bbox("all"))
        )

        main_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        main_canvas.configure(yscrollcommand=scrollbar.set)

        # Header information
        header_frame = ttk.LabelFrame(scrollable_frame, text="Entry Information", padding=10)
        header_frame.pack(fill='x', padx=10, pady=5)

        row = 0

        # EMP Number (read-only)
        ttk.Label(header_frame, text="EMP Number:").grid(row=row, column=0, sticky='w', padx=5, pady=5)
        ttk.Label(header_frame, text=orig_emp_number, font=('Arial', 10, 'bold')).grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1

        # Reported By (read-only)
        ttk.Label(header_frame, text="Reported By:").grid(row=row, column=0, sticky='w', padx=5, pady=5)
        ttk.Label(header_frame, text=orig_reported_by or 'N/A').grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1

        # Reported Date (read-only)
        ttk.Label(header_frame, text="Reported Date:").grid(row=row, column=0, sticky='w', padx=5, pady=5)
        ttk.Label(header_frame, text=orig_reported_date or 'N/A').grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1

        # Equipment (editable)
        ttk.Label(header_frame, text="BFM Equipment No:").grid(row=row, column=0, sticky='w', padx=5, pady=5)
        bfm_var = tk.StringVar(value=orig_bfm_no or '')
        cursor.execute('SELECT DISTINCT bfm_equipment_no FROM equipment ORDER BY bfm_equipment_no')
        equipment_list = [row_data[0] for row_data in cursor.fetchall()]
        bfm_combo = ttk.Combobox(header_frame, textvariable=bfm_var, values=equipment_list, width=25)
        bfm_combo.grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1

        # Priority (editable)
        ttk.Label(header_frame, text="Priority:").grid(row=row, column=0, sticky='w', padx=5, pady=5)
        priority_var = tk.StringVar(value=orig_priority or 'Medium')
        priority_combo = ttk.Combobox(header_frame, textvariable=priority_var,
                                values=['Low', 'Medium', 'High', 'Critical'], width=15)
        priority_combo.grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1

        # Assigned Technician (editable)
        ttk.Label(header_frame, text="Assigned Technician:").grid(row=row, column=0, sticky='w', padx=5, pady=5)
        assigned_var = tk.StringVar(value=orig_assigned or '')
        assigned_combo = ttk.Combobox(header_frame, textvariable=assigned_var,
                                values=self.technicians, width=20)
        assigned_combo.grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1

        # Status (editable)
        ttk.Label(header_frame, text="Status:").grid(row=row, column=0, sticky='w', padx=5, pady=5)
        status_var = tk.StringVar(value=orig_status or 'Open')
        status_combo = ttk.Combobox(header_frame, textvariable=status_var,
                              values=['Open', 'Closed'], width=15)
        status_combo.grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1

        # Description (editable)
        desc_frame = ttk.LabelFrame(scrollable_frame, text="Description", padding=10)
        desc_frame.pack(fill='x', padx=10, pady=5)

        description_text = tk.Text(desc_frame, width=60, height=4)
        description_text.pack(fill='x', padx=5, pady=5)
        description_text.insert('1.0', orig_description or '')

        # Missing Parts (editable)
        parts_frame = ttk.LabelFrame(scrollable_frame, text="Missing Parts", padding=10)
        parts_frame.pack(fill='x', padx=10, pady=5)

        missing_parts_text = tk.Text(parts_frame, width=60, height=6)
        missing_parts_text.pack(fill='x', padx=5, pady=5)
        missing_parts_text.insert('1.0', orig_missing_parts or '')

        # Notes (editable)
        notes_frame = ttk.LabelFrame(scrollable_frame, text="Additional Notes", padding=10)
        notes_frame.pack(fill='x', padx=10, pady=5)

        notes_text = tk.Text(notes_frame, width=60, height=4)
        notes_text.pack(fill='x', padx=5, pady=5)
        notes_text.insert('1.0', orig_notes or '')

        # Closure information (if closed)
        if orig_status == 'Closed':
            closure_frame = ttk.LabelFrame(scrollable_frame, text="Closure Information", padding=10)
            closure_frame.pack(fill='x', padx=10, pady=5)

            closure_row = 0
            ttk.Label(closure_frame, text="Closed Date:").grid(row=closure_row, column=0, sticky='w', padx=5, pady=5)
            ttk.Label(closure_frame, text=orig_closed_date or 'N/A').grid(row=closure_row, column=1, sticky='w', padx=5, pady=5)
            closure_row += 1

            ttk.Label(closure_frame, text="Closed By:").grid(row=closure_row, column=0, sticky='w', padx=5, pady=5)
            ttk.Label(closure_frame, text=orig_closed_by or 'N/A').grid(row=closure_row, column=1, sticky='w', padx=5, pady=5)

        def save_changes():
            """Save the edited entry"""
            try:
                if not bfm_var.get():
                    messagebox.showerror("Error", "Please select equipment")
                    return

                if not description_text.get('1.0', 'end-1c').strip():
                    messagebox.showerror("Error", "Please enter a description")
                    return

                if not missing_parts_text.get('1.0', 'end-1c').strip():
                    messagebox.showerror("Error", "Please enter missing parts details")
                    return

                # Update database
                cursor = self.conn.cursor()
                cursor.execute('''
                    UPDATE equipment_missing_parts
                    SET bfm_equipment_no = %s,
                        description = %s,
                        priority = %s,
                        assigned_technician = %s,
                        status = %s,
                        missing_parts_description = %s,
                        notes = %s,
                        updated_date = CURRENT_TIMESTAMP
                    WHERE emp_number = %s
                ''', (
                    bfm_var.get(),
                    description_text.get('1.0', 'end-1c'),
                    priority_var.get(),
                    assigned_var.get(),
                    status_var.get(),
                    missing_parts_text.get('1.0', 'end-1c'),
                    notes_text.get('1.0', 'end-1c'),
                    orig_emp_number
                ))
                self.conn.commit()

                messagebox.showinfo("Success", f"Equipment Missing Parts entry {orig_emp_number} updated successfully!")
                dialog.destroy()
                self.load_missing_parts_list()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to update entry: {str(e)}")

        def delete_entry():
            """Delete this entry with confirmation"""
            result = messagebox.askyesno("Confirm Delete",
                                        f"Are you sure you want to delete entry {orig_emp_number}?\n\n"
                                        f"This action cannot be undone.")
            if result:
                try:
                    cursor = self.conn.cursor()
                    cursor.execute('DELETE FROM equipment_missing_parts WHERE emp_number = %s', (orig_emp_number,))
                    self.conn.commit()

                    messagebox.showinfo("Success", f"Entry {orig_emp_number} deleted successfully!")
                    dialog.destroy()
                    self.load_missing_parts_list()

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to delete entry: {str(e)}")

        # Buttons
        button_frame = ttk.Frame(scrollable_frame)
        button_frame.pack(fill='x', padx=10, pady=10)

        ttk.Button(button_frame, text="Save Changes", command=save_changes).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Delete Entry", command=delete_entry).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side='left', padx=5)

        # Pack canvas and scrollbar
        main_canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")


    def close_missing_parts_dialog(self):
        """Close an Equipment Missing Parts entry"""
        selected = self.emp_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select an equipment missing parts entry to close")
            return

        # Get selected EMP data
        item = self.emp_tree.item(selected[0])
        emp_number = item['values'][0]

        # Fetch current data
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT emp_number, bfm_equipment_no, description, status, missing_parts_description
            FROM equipment_missing_parts
            WHERE emp_number = %s
        ''', (emp_number,))

        emp_data = cursor.fetchone()
        if not emp_data:
            messagebox.showerror("Error", "Equipment missing parts entry not found")
            return

        orig_emp_number, orig_bfm_no, orig_description, orig_status, orig_missing_parts = emp_data

        if orig_status == 'Closed':
            messagebox.showinfo("Already Closed", f"Entry {emp_number} is already closed.")
            return

        # Create close dialog
        dialog = tk.Toplevel(self.root)
        dialog.title(f"Close Equipment Missing Parts - {emp_number}")
        dialog.geometry("600x450")
        dialog.transient(self.root)
        dialog.grab_set()

        # Display current information
        info_frame = ttk.LabelFrame(dialog, text="Entry Information", padding=10)
        info_frame.pack(fill='x', padx=10, pady=5)

        ttk.Label(info_frame, text="EMP Number:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        ttk.Label(info_frame, text=emp_number, font=('Arial', 10, 'bold')).grid(row=0, column=1, sticky='w', padx=5, pady=5)

        ttk.Label(info_frame, text="Equipment:").grid(row=1, column=0, sticky='w', padx=5, pady=5)
        ttk.Label(info_frame, text=orig_bfm_no or 'N/A').grid(row=1, column=1, sticky='w', padx=5, pady=5)

        ttk.Label(info_frame, text="Description:").grid(row=2, column=0, sticky='nw', padx=5, pady=5)
        desc_label = ttk.Label(info_frame, text=orig_description or 'N/A', wraplength=400)
        desc_label.grid(row=2, column=1, sticky='w', padx=5, pady=5)

        ttk.Label(info_frame, text="Missing Parts:").grid(row=3, column=0, sticky='nw', padx=5, pady=5)
        parts_label = ttk.Label(info_frame, text=orig_missing_parts or 'N/A', wraplength=400)
        parts_label.grid(row=3, column=1, sticky='w', padx=5, pady=5)

        # Closure information
        closure_frame = ttk.LabelFrame(dialog, text="Closure Information", padding=10)
        closure_frame.pack(fill='x', padx=10, pady=5)

        # Closure Date
        ttk.Label(closure_frame, text="Closure Date:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        closure_date_var = tk.StringVar(value=datetime.now().strftime('%Y-%m-%d'))
        ttk.Entry(closure_frame, textvariable=closure_date_var, width=15).grid(row=0, column=1, sticky='w', padx=5, pady=5)
        ttk.Label(closure_frame, text="Format: YYYY-MM-DD", font=('Arial', 8), foreground='gray').grid(row=0, column=2, sticky='w', padx=5)

        # Closure Notes
        ttk.Label(closure_frame, text="Closure Notes:").grid(row=1, column=0, sticky='nw', padx=5, pady=5)
        ttk.Label(closure_frame, text="(Parts procured, issue resolved, etc.)", font=('Arial', 8), foreground='gray').grid(row=1, column=1, sticky='w', padx=5, pady=0)
        closure_notes_text = tk.Text(closure_frame, width=40, height=6)
        closure_notes_text.grid(row=2, column=1, columnspan=2, sticky='w', padx=5, pady=5)

        def save_closure():
            """Save the closure"""
            try:
                closure_date_input = closure_date_var.get().strip()

                if not closure_date_input:
                    messagebox.showerror("Error", "Please enter a closure date")
                    return

                try:
                    parsed_date = datetime.strptime(closure_date_input, '%Y-%m-%d')
                    validated_date = parsed_date.strftime('%Y-%m-%d')
                except ValueError:
                    messagebox.showerror("Invalid Date Format",
                                    f"Please enter the date in YYYY-MM-DD format.\n\n"
                                    f"You entered: '{closure_date_input}'")
                    return

                closure_notes = closure_notes_text.get('1.0', 'end-1c').strip()

                # Update database
                cursor = self.conn.cursor()
                cursor.execute('''
                    UPDATE equipment_missing_parts
                    SET status = 'Closed',
                        closed_date = %s,
                        closed_by = %s,
                        notes = COALESCE(notes, '') || %s,
                        updated_date = CURRENT_TIMESTAMP
                    WHERE emp_number = %s
                ''', (
                    validated_date,
                    self.user_name,
                    '\n\n[CLOSURE NOTES]\n' + closure_notes if closure_notes else '',
                    emp_number
                ))
                self.conn.commit()

                messagebox.showinfo("Success",
                                f"Entry {emp_number} closed successfully!\n\n"
                                f"Closed Date: {validated_date}\n"
                                f"Closed By: {self.user_name}")
                dialog.destroy()
                self.load_missing_parts_list()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to close entry: {str(e)}")

        # Buttons
        button_frame = ttk.Frame(dialog)
        button_frame.pack(fill='x', padx=10, pady=20)

        ttk.Button(button_frame, text="Close Entry", command=save_closure).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side='left', padx=5)


    def edit_cm_dialog(self):
        """Edit existing Corrective Maintenance with full functionality"""
        selected = self.cm_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a CM to edit")
            return

        # Get selected CM data
        item = self.cm_tree.item(selected[0])
        cm_number = item['values'][0]

        # Fetch full CM data from database
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT cm_number, bfm_equipment_no, description, priority, assigned_technician, 
                status, created_date, completion_date, labor_hours, notes, root_cause, corrective_action
            FROM corrective_maintenance 
            WHERE cm_number = %s
        ''', (cm_number,))

        cm_data = cursor.fetchone()
        if not cm_data:
            messagebox.showerror("Error", "CM not found in database")
            return

        # Extract CM data
        (orig_cm_number, orig_bfm_no, orig_description, orig_priority, orig_assigned, 
        orig_status, orig_created, orig_completion, orig_hours, orig_notes, 
        orig_root_cause, orig_corrective_action) = cm_data

        # Create edit dialog
        dialog = tk.Toplevel(self.root)
        dialog.title(f"Edit Corrective Maintenance - {cm_number}")
        dialog.geometry("700x600")
        dialog.transient(self.root)
        dialog.grab_set()

        # Main container with scrollbar
        main_canvas = tk.Canvas(dialog)
        scrollbar = ttk.Scrollbar(dialog, orient="vertical", command=main_canvas.yview)
        scrollable_frame = ttk.Frame(main_canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: main_canvas.configure(scrollregion=main_canvas.bbox("all"))
        )

        main_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        main_canvas.configure(yscrollcommand=scrollbar.set)

        # CM Information (header)
        header_frame = ttk.LabelFrame(scrollable_frame, text="CM Information", padding=10)
        header_frame.pack(fill='x', padx=10, pady=5)

        row = 0

        # CM Number (read-only)
        ttk.Label(header_frame, text="CM Number:").grid(row=row, column=0, sticky='w', padx=5, pady=5)
        ttk.Label(header_frame, text=orig_cm_number, font=('Arial', 10, 'bold')).grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1

        # Equipment (editable)
        ttk.Label(header_frame, text="BFM Equipment No:").grid(row=row, column=0, sticky='w', padx=5, pady=5)
        bfm_var = tk.StringVar(value=orig_bfm_no or '')
        bfm_combo = ttk.Combobox(header_frame, textvariable=bfm_var, width=25)
        bfm_combo.grid(row=row, column=1, sticky='w', padx=5, pady=5)

        # Populate equipment list
        cursor.execute('SELECT bfm_equipment_no FROM equipment ORDER BY bfm_equipment_no')
        equipment_list = [row[0] for row in cursor.fetchall()]
        bfm_combo['values'] = equipment_list
        row += 1

        # Priority (editable)
        ttk.Label(header_frame, text="Priority:").grid(row=row, column=0, sticky='w', padx=5, pady=5)
        priority_var = tk.StringVar(value=orig_priority or 'Medium')
        priority_combo = ttk.Combobox(header_frame, textvariable=priority_var, 
                                values=['Low', 'Medium', 'High', 'Emergency'], width=15)
        priority_combo.grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1

        # Assigned Technician (editable)
        ttk.Label(header_frame, text="Assigned Technician:").grid(row=row, column=0, sticky='w', padx=5, pady=5)
        assigned_var = tk.StringVar(value=orig_assigned or '')
        assigned_combo = ttk.Combobox(header_frame, textvariable=assigned_var, 
                                values=self.technicians, width=20)
        assigned_combo.grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1

        # Status (editable)
        ttk.Label(header_frame, text="Status:").grid(row=row, column=0, sticky='w', padx=5, pady=5)
        status_var = tk.StringVar(value=orig_status or 'Open')
        status_combo = ttk.Combobox(header_frame, textvariable=status_var, 
                              values=['Open', 'Closed'], width=15)
        status_combo.grid(row=row, column=1, sticky='w', padx=5, pady=5)
        row += 1

        # Description (editable)
        desc_frame = ttk.LabelFrame(scrollable_frame, text="Description", padding=10)
        desc_frame.pack(fill='x', padx=10, pady=5)

        description_text = tk.Text(desc_frame, width=60, height=4)
        description_text.pack(fill='x', padx=5, pady=5)
        description_text.insert('1.0', orig_description or '')

        # Completion Information (if completed)
        completion_frame = ttk.LabelFrame(scrollable_frame, text="Completion Information", padding=10)
        completion_frame.pack(fill='x', padx=10, pady=5)

        comp_row = 0

        # Labor Hours
        ttk.Label(completion_frame, text="Labor Hours:").grid(row=comp_row, column=0, sticky='w', padx=5, pady=5)
        labor_hours_var = tk.StringVar(value=str(orig_hours or ''))
        ttk.Entry(completion_frame, textvariable=labor_hours_var, width=10).grid(row=comp_row, column=1, sticky='w', padx=5, pady=5)
        comp_row += 1

        # Completion Date
        ttk.Label(completion_frame, text="Completion Date:").grid(row=comp_row, column=0, sticky='w', padx=5, pady=5)
        completion_date_var = tk.StringVar(value=orig_completion or '')
        ttk.Entry(completion_frame, textvariable=completion_date_var, width=15).grid(row=comp_row, column=1, sticky='w', padx=5, pady=5)
        comp_row += 1

        # Notes
        notes_frame = ttk.LabelFrame(scrollable_frame, text="Notes", padding=10)
        notes_frame.pack(fill='x', padx=10, pady=5)

        notes_text = tk.Text(notes_frame, width=60, height=4)
        notes_text.pack(fill='x', padx=5, pady=5)
        notes_text.insert('1.0', orig_notes or '')

        # Root Cause
        root_cause_frame = ttk.LabelFrame(scrollable_frame, text="Root Cause Analysis", padding=10)
        root_cause_frame.pack(fill='x', padx=10, pady=5)

        root_cause_text = tk.Text(root_cause_frame, width=60, height=3)
        root_cause_text.pack(fill='x', padx=5, pady=5)
        root_cause_text.insert('1.0', orig_root_cause or '')

        # Corrective Action
        corrective_action_frame = ttk.LabelFrame(scrollable_frame, text="Corrective Action", padding=10)
        corrective_action_frame.pack(fill='x', padx=10, pady=5)

        corrective_action_text = tk.Text(corrective_action_frame, width=60, height=3)
        corrective_action_text.pack(fill='x', padx=5, pady=5)
        corrective_action_text.insert('1.0', orig_corrective_action or '')

        def save_changes():
            try:
                # Validate inputs
                if not description_text.get('1.0', 'end-1c').strip():
                    messagebox.showerror("Error", "Please enter a description")
                    return

                # Update database
                cursor = self.conn.cursor()
                cursor.execute('''
                    UPDATE corrective_maintenance SET
                    bfm_equipment_no = %s,
                    description = %s,
                    priority = %s,
                    assigned_technician = %s,
                    status = %s,
                    labor_hours = %s,
                    completion_date = %s,
                    notes = %s,
                    root_cause = %s,
                    corrective_action = %s
                    WHERE cm_number = %s
                ''', (
                    bfm_var.get(),
                    description_text.get('1.0', 'end-1c'),
                    priority_var.get(),
                    assigned_var.get(),
                    status_var.get(),
                    float(labor_hours_var.get() or 0),
                    completion_date_var.get() if completion_date_var.get() else None,
                    notes_text.get('1.0', 'end-1c'),
                    root_cause_text.get('1.0', 'end-1c'),
                    corrective_action_text.get('1.0', 'end-1c'),
                    orig_cm_number
                ))

                self.conn.commit()
                messagebox.showinfo("Success", f"CM {orig_cm_number} updated successfully!")
                dialog.destroy()
                self.load_corrective_maintenance()

            except Exception as e:
                try:
                    self.conn.rollback()
                except Exception:
                    pass
                messagebox.showerror("Error", f"Failed to update CM: {str(e)}")

        def delete_cm():
            result = messagebox.askyesno("Confirm Delete", 
                                    f"Delete CM {orig_cm_number}?\n\n"
                                    f"This action cannot be undone.")
            if result:
                try:
                    cursor = self.conn.cursor()
                    # First delete any child part requests (defensive; FK now also cascades)
                    cursor.execute('DELETE FROM cm_parts_requests WHERE cm_number = %s', (orig_cm_number,))
                    # Then delete the CM itself
                    cursor.execute('DELETE FROM corrective_maintenance WHERE cm_number = %s', (orig_cm_number,))
                    self.conn.commit()
                    messagebox.showinfo("Success", f"CM {orig_cm_number} deleted successfully!")
                    dialog.destroy()
                    self.load_corrective_maintenance()
                except Exception as e:
                    # Roll back so the connection is not left in an aborted state
                    try:
                        self.conn.rollback()
                    except Exception:
                        pass
                    messagebox.showerror("Error", f"Failed to delete CM: {str(e)}")

        # Buttons frame
        button_frame = ttk.Frame(scrollable_frame)
        button_frame.pack(side='bottom', fill='x', padx=10, pady=10)

        ttk.Button(button_frame, text="Save Changes", command=save_changes).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Delete CM", command=delete_cm).pack(side='left', padx=5)
        
        # ============ ADD THIS NEW SECTION ============
        # View Parts button - shows parts consumed for this CM
        if hasattr(self, 'parts_integration'):
            cursor = self.conn.cursor()
            cursor.execute('SELECT COUNT(*) FROM cm_parts_used WHERE cm_number = %s', (orig_cm_number,))
            parts_count = cursor.fetchone()[0]
            
            if parts_count > 0:
                button_text = f"WARNING: View Parts Used ({parts_count})"
            else:
                button_text = "WARNING: No Parts Used"
            
            def show_parts_detail():
                self.parts_integration.show_cm_parts_details(orig_cm_number)
            
            ttk.Button(button_frame, text=button_text, 
                      command=show_parts_detail).pack(side='left', padx=5)
        # ============ END NEW SECTION ============
        
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side='right', padx=5)

        # Pack the canvas and scrollbar
        main_canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # Update scroll region
        scrollable_frame.update_idletasks()
        main_canvas.configure(scrollregion=main_canvas.bbox("all"))
    
    
    
    def complete_cm_dialog(self):
        """Complete selected CM with parts consumption tracking"""
        selected = self.cm_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a CM to complete")
            return

        # Get selected CM data
        item = self.cm_tree.item(selected[0])
        cm_number = item['values'][0]
    
        # Fetch CM details
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT cm_number, bfm_equipment_no, description, assigned_technician, 
                status, labor_hours, notes, root_cause, corrective_action
            FROM corrective_maintenance 
            WHERE cm_number = %s
        ''', (cm_number,))
    
        cm_data = cursor.fetchone()
        if not cm_data:
            messagebox.showerror("Error", "CM not found")
            return
    
        (cm_num, equipment, desc, tech, status, labor_hrs, 
         notes, root_cause, corr_action) = cm_data
    
        # Check if already closed
        if status in ['Closed', 'Completed']:
            messagebox.showinfo("Info", f"CM {cm_number} is already closed")
            return
    
        # Create closure dialog
        dialog = tk.Toplevel(self.root)
        dialog.title(f"Complete CM - {cm_number}")
        dialog.geometry("950x750")
        dialog.transient(self.root)
        dialog.grab_set()
    
        # Header
        header_frame = ttk.Frame(dialog)
        header_frame.pack(fill='x', padx=10, pady=10)
    
        ttk.Label(header_frame, text=f"Complete Corrective Maintenance", 
                font=('Arial', 12, 'bold')).pack()
        ttk.Label(header_frame, text=f"CM Number: {cm_number}", 
                font=('Arial', 10)).pack()
        ttk.Label(header_frame, text=f"Equipment: {equipment}", 
                font=('Arial', 10)).pack()
    
        # Main form frame with scrollbar
        canvas = tk.Canvas(dialog)
        scrollbar = ttk.Scrollbar(dialog, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
    
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
    
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True, padx=10, pady=10)
        scrollbar.pack(side="right", fill="y")
        
        # Form fields
        row = 0
    
        # Completion Date
        ttk.Label(scrollable_frame, text="Completion Date*:", 
                font=('Arial', 10, 'bold')).grid(row=row, column=0, sticky='w', padx=10, pady=5)
        completion_date_var = tk.StringVar(value=datetime.now().strftime('%Y-%m-%d'))
        ttk.Entry(scrollable_frame, textvariable=completion_date_var, width=40).grid(
            row=row, column=1, sticky='w', padx=10, pady=5)
        ttk.Label(scrollable_frame, text="(Format: YYYY-MM-DD)", 
                font=('Arial', 8, 'italic')).grid(row=row, column=2, sticky='w')
        row += 1
    
        # Labor Hours
        ttk.Label(scrollable_frame, text="Total Labor Hours*:", 
                font=('Arial', 10, 'bold')).grid(row=row, column=0, sticky='w', padx=10, pady=5)
        labor_hours_var = tk.StringVar(value=str(labor_hrs) if labor_hrs else '')
        ttk.Entry(scrollable_frame, textvariable=labor_hours_var, width=40).grid(
            row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1
    
        ttk.Separator(scrollable_frame, orient='horizontal').grid(
            row=row, column=0, columnspan=3, sticky='ew', pady=10)
        row += 1
    
        # Root Cause
        ttk.Label(scrollable_frame, text="Root Cause*:", 
                font=('Arial', 10, 'bold')).grid(row=row, column=0, sticky='nw', padx=10, pady=5)
        root_cause_text = tk.Text(scrollable_frame, width=50, height=4)
        root_cause_text.insert('1.0', root_cause or '')
        root_cause_text.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1
    
        # Corrective Action
        ttk.Label(scrollable_frame, text="Corrective Action Taken*:", 
                font=('Arial', 10, 'bold')).grid(row=row, column=0, sticky='nw', padx=10, pady=5)
        corr_action_text = tk.Text(scrollable_frame, width=50, height=4)
        corr_action_text.insert('1.0', corr_action or '')
        corr_action_text.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1
    
        # Additional Notes
        ttk.Label(scrollable_frame, text="Additional Notes:", 
                font=('Arial', 10, 'bold')).grid(row=row, column=0, sticky='nw', padx=10, pady=5)
        notes_text = tk.Text(scrollable_frame, width=50, height=4)
        notes_text.insert('1.0', notes or '')
        notes_text.grid(row=row, column=1, sticky='w', padx=10, pady=5)
        row += 1
    
        ttk.Separator(scrollable_frame, orient='horizontal').grid(
            row=row, column=0, columnspan=3, sticky='ew', pady=10)
        row += 1
    
        # Parts consumption question - THIS IS THE KEY INTEGRATION POINT
        ttk.Label(scrollable_frame, text="Were any parts used from MRO Stock?", 
                font=('Arial', 11, 'bold'), foreground='blue').grid(
                    row=row, column=0, columnspan=2, sticky='w', padx=10, pady=10)
        row += 1
    
        parts_used_var = tk.StringVar(value="No")
        ttk.Radiobutton(scrollable_frame, text="No parts were used", 
                    variable=parts_used_var, value="No").grid(
                        row=row, column=0, columnspan=2, sticky='w', padx=30, pady=5)
        row += 1
    
        ttk.Radiobutton(scrollable_frame, text="Yes, parts were used (will open parts dialog)",
                    variable=parts_used_var, value="Yes").grid(
                        row=row, column=0, columnspan=2, sticky='w', padx=30, pady=5)
        row += 1

        # Button frame
        button_frame = ttk.Frame(dialog)
        button_frame.pack(fill='x', padx=10, pady=10)

        def gather_form_values():
            """Validate required fields and return a dict of form values, or None if invalid"""
            # Validate required fields
            if not completion_date_var.get().strip():
                messagebox.showerror("Error", "Completion date is required")
                return None
            # Accept multiple common date formats and normalize to YYYY-MM-DD
            date_input = completion_date_var.get().strip()
            parsed_date = None
            for fmt in ('%Y-%m-%d', '%m/%d/%Y', '%m/%d/%y', '%m-%d-%Y', '%m-%d-%y'):
                try:
                    parsed_date = datetime.strptime(date_input, fmt)
                    break
                except ValueError:
                    continue
            if not parsed_date:
                messagebox.showerror("Error", "Invalid date. Use YYYY-MM-DD or MM/DD/YY.")
                return None
            if not labor_hours_var.get().strip():
                messagebox.showerror("Error", "Labor hours is required")
                return None
            try:
                labor_hrs_value = float(labor_hours_var.get())
                if labor_hrs_value < 0:
                    messagebox.showerror("Error", "Labor hours cannot be negative")
                    return None
            except ValueError:
                messagebox.showerror("Error", "Invalid labor hours value")
                return None
            root_cause_value = root_cause_text.get('1.0', 'end-1c').strip()
            if not root_cause_value:
                messagebox.showerror("Error", "Root cause is required")
                return None
            corr_action_value = corr_action_text.get('1.0', 'end-1c').strip()
            if not corr_action_value:
                messagebox.showerror("Error", "Corrective action is required")
                return None
            additional_notes = notes_text.get('1.0', 'end-1c').strip()
            return {
                'completion_date': parsed_date.strftime('%Y-%m-%d'),
                'labor_hours': labor_hrs_value,
                'root_cause': root_cause_value,
                'corrective_action': corr_action_value,
                'notes': additional_notes,
            }

        def finalize_closure(form_values, parts_recorded):
            """Finalize CM closure after parts handling"""
            if not parts_recorded and parts_used_var.get() == "Yes":
                # User cancelled parts dialog, don't close CM
                return

            try:
                cursor = self.conn.cursor()

                # Update CM record
                cursor.execute('''
                    UPDATE corrective_maintenance
                    SET status = 'Closed',
                        completion_date = %s,
                        labor_hours = %s,
                        root_cause = %s,
                        corrective_action = %s,
                        notes = %s
                    WHERE cm_number = %s
                ''', (
                    form_values['completion_date'],
                    form_values['labor_hours'],
                    form_values['root_cause'],
                    form_values['corrective_action'],
                    form_values['notes'],
                    cm_number
                ))

                self.conn.commit()

                messagebox.showinfo("Success",
                    f"CM {cm_number} completed successfully!\n\n"
                    f"Completion Date: {form_values['completion_date']}\n"
                    f"Labor Hours: {form_values['labor_hours']}\n"
                    f"Status: Closed")

                dialog.destroy()
                self.load_corrective_maintenance()

            except Exception as e:
                self.conn.rollback()
                messagebox.showerror("Error", f"Failed to complete CM: {str(e)}")

        def validate_and_proceed():
            """Validate closure form and proceed to parts or close"""
            form_values = gather_form_values()
            if form_values is None:
                return
            
            # Check if parts were used
            if parts_used_var.get() == "Yes":
                # Close this dialog and open parts consumption dialog
                dialog.destroy()
            
                # Open parts consumption dialog
                # This requires the CMPartsIntegration module to be initialized
                if hasattr(self, 'parts_integration'):
                    self.parts_integration.show_parts_consumption_dialog(
                        cm_number=cm_number,
                        technician_name=tech or 'Unknown',
                        callback=lambda success: finalize_closure(form_values, success)
                    )
                else:
                    messagebox.showerror("Error", 
                        "Parts integration module not initialized.\n"
                        "Please contact system administrator.")
                    # Still update CM but without parts
                    finalize_closure(form_values, True)
            else:
                # No parts used, close directly
                finalize_closure(form_values, True)
    
        ttk.Button(button_frame, text="Complete CM", 
                command=validate_and_proceed).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Cancel", 
                command=dialog.destroy).pack(side='left', padx=5)
    
 
    
    
    def load_corrective_maintenance(self):
        """Load corrective maintenance data"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT cm_number, bfm_equipment_no, description, priority, 
                       assigned_technician, status, created_date
                FROM corrective_maintenance 
                ORDER BY created_date DESC
            ''')
            
            # Clear existing items
            for item in self.cm_tree.get_children():
                self.cm_tree.delete(item)
            
            # Add CM records
            for cm in cursor.fetchall():
                cm_number, bfm_no, description, priority, assigned, status, created = cm
                # Truncate description for display
                display_desc = (description[:47] + '...') if len(description) > 50 else description
                self.cm_tree.insert('', 'end', values=(
                    cm_number, bfm_no, display_desc, priority, assigned, status, created
                ))
                
        except Exception as e:
            print(f"Error loading corrective maintenance: {e}")
    
    def refresh_analytics_dashboard(self):
        """Refresh analytics dashboard with current data"""
        try:
            cursor = self.conn.cursor()
            
            # Generate comprehensive analytics
            analytics = "AIT CMMS ANALYTICS DASHBOARD\n"
            analytics += f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            analytics += "=" * 80 + "\n\n"
            
            # Equipment statistics
            cursor.execute("SELECT COUNT(*) FROM equipment WHERE status = 'Active'")
            active_equipment = cursor.fetchone()[0]

            cursor.execute('SELECT COUNT(*) FROM equipment WHERE monthly_pm = TRUE')
            monthly_pm_equipment = cursor.fetchone()[0]

            cursor.execute('SELECT COUNT(*) FROM equipment WHERE six_month_pm = TRUE')
            six_month_pm_equipment = cursor.fetchone()[0]

            cursor.execute('SELECT COUNT(*) FROM equipment WHERE annual_pm = TRUE')
            annual_pm_equipment = cursor.fetchone()[0]
            
            analytics += "EQUIPMENT OVERVIEW:\n"
            analytics += f"Total Active Equipment: {active_equipment}\n"
            analytics += f"Equipment with Monthly PM: {monthly_pm_equipment}\n"
            analytics += f"Equipment with Six Month PM: {six_month_pm_equipment}\n"
            analytics += f"Equipment with Annual PM: {annual_pm_equipment}\n\n"
            
            # PM completion statistics (last 30 days)
            cursor.execute('''
                SELECT COUNT(*) FROM pm_completions
                WHERE completion_date >= CURRENT_DATE - INTERVAL '30 days'
            ''')
            recent_completions = cursor.fetchone()[0]
            
            cursor.execute('''
                SELECT pm_type, COUNT(*)
                FROM pm_completions
                WHERE completion_date >= CURRENT_DATE - INTERVAL '30 days'
                GROUP BY pm_type
            ''')
            pm_type_stats = cursor.fetchall()
            
            analytics += "PM COMPLETION STATISTICS (Last 30 Days):\n"
            analytics += f"Total PM Completions: {recent_completions}\n"
            for pm_type, count in pm_type_stats:
                analytics += f"{pm_type} PMs: {count}\n"
            analytics += "\n"
            
            # Technician performance (last 30 days)
            cursor.execute('''
                SELECT technician_name,
                       COUNT(*) as completed_pms,
                       AVG(labor_hours + labor_minutes/60.0) as avg_hours
                FROM pm_completions
                WHERE completion_date >= CURRENT_DATE - INTERVAL '30 days'
                GROUP BY technician_name
                ORDER BY completed_pms DESC
            ''')
            tech_stats = cursor.fetchall()
            
            analytics += "TECHNICIAN PERFORMANCE (Last 30 Days):\n"
            analytics += f"{'Technician':<20} {'Completed PMs':<15} {'Avg Hours':<10}\n"
            analytics += "-" * 47 + "\n"
            for tech, completed, avg_hours in tech_stats:
                analytics += f"{tech:<20} {completed:<15} {avg_hours:<9.1f}h\n"
            analytics += "\n"
            
            # CM statistics
            cursor.execute("SELECT COUNT(*) FROM corrective_maintenance WHERE status = 'Open'")
            open_cms = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM corrective_maintenance WHERE status = 'Completed'")
            completed_cms = cursor.fetchone()[0]
            
            analytics += "CORRECTIVE MAINTENANCE:\n"
            analytics += f"Open CMs: {open_cms}\n"
            analytics += f"Completed CMs: {completed_cms}\n\n"
            
            # Current week performance
            current_week_start = self.get_week_start(datetime.now()).strftime('%Y-%m-%d')
            cursor.execute('''
                SELECT 
                    COUNT(*) as scheduled,
                    COUNT(CASE WHEN status = 'Completed' THEN 1 END) as completed
                FROM weekly_pm_schedules 
                WHERE week_start_date = %s
            ''', (current_week_start,))
            
            week_scheduled, week_completed = cursor.fetchone()
            week_rate = (week_completed / week_scheduled * 100) if week_scheduled > 0 else 0
            
            analytics += "CURRENT WEEK PERFORMANCE:\n"
            analytics += f"Scheduled PMs: {week_scheduled}\n"
            analytics += f"Completed PMs: {week_completed}\n"
            analytics += f"Completion Rate: {week_rate:.1f}%\n\n"
            
            # Display analytics
            self.analytics_text.delete('1.0', 'end')
            self.analytics_text.insert('end', analytics)
            
        except Exception as e:
            print(f"Error refreshing analytics dashboard: {e}")
    
    def show_equipment_analytics(self):
        """Show comprehensive equipment analytics in a new dialog window"""
        try:
            # Create analytics dialog
            analytics_dialog = tk.Toplevel(self.root)
            analytics_dialog.title("Equipment Analytics Dashboard")
            analytics_dialog.geometry("1200x800")
            analytics_dialog.transient(self.root)
            analytics_dialog.grab_set()
        
            # Create notebook for different analytics tabs
            analytics_notebook = ttk.Notebook(analytics_dialog)
            analytics_notebook.pack(fill='both', expand=True, padx=10, pady=10)
        
            # Tab 1: Equipment Overview
            overview_frame = ttk.Frame(analytics_notebook)
            analytics_notebook.add(overview_frame, text="Equipment Overview")
        
            # Tab 2: PM Performance Analysis
            pm_performance_frame = ttk.Frame(analytics_notebook)
            analytics_notebook.add(pm_performance_frame, text="PM Performance")
        
            # Tab 3: Location Analysis
            location_frame = ttk.Frame(analytics_notebook)
            analytics_notebook.add(location_frame, text="Location Analysis")
        
            # Tab 4: Technician Workload
            technician_frame = ttk.Frame(analytics_notebook)
            analytics_notebook.add(technician_frame, text="Technician Analysis")
        
            # Generate analytics for each tab
            self.generate_equipment_overview(overview_frame)
            self.generate_pm_performance_analysis(pm_performance_frame)
            self.generate_location_analysis(location_frame)
            self.generate_technician_analysis(technician_frame)
        
            # Add export button
            export_frame = ttk.Frame(analytics_dialog)
            export_frame.pack(side='bottom', fill='x', padx=10, pady=5)
        
            ttk.Button(export_frame, text="Export All Analytics to PDF", 
                    command=lambda: self.export_equipment_analytics_pdf(analytics_dialog)).pack(side='right', padx=5)
            ttk.Button(export_frame, text="Close", 
                    command=analytics_dialog.destroy).pack(side='right', padx=5)
        
        except Exception as e:
            messagebox.showerror("Error", f"Failed to generate equipment analytics: {str(e)}")

    def generate_equipment_overview(self, parent_frame):
        """Generate equipment overview analytics"""
        try:
            cursor = self.conn.cursor()
        
            # Create scrollable text area
            text_frame = ttk.Frame(parent_frame)
            text_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
            overview_text = tk.Text(text_frame, wrap='word', font=('Courier', 10))
            scrollbar = ttk.Scrollbar(text_frame, orient='vertical', command=overview_text.yview)
            overview_text.configure(yscrollcommand=scrollbar.set)
        
            overview_text.pack(side='left', fill='both', expand=True)
            scrollbar.pack(side='right', fill='y')
        
            # Generate analytics content
            analytics = "EQUIPMENT ANALYTICS OVERVIEW\n"
            analytics += f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            analytics += "=" * 80 + "\n\n"
        
            # Basic equipment statistics
            cursor.execute('SELECT COUNT(*) FROM equipment')
            total_equipment = cursor.fetchone()[0]
        
            cursor.execute("SELECT COUNT(*) FROM equipment WHERE status = 'Active'")
            active_equipment = cursor.fetchone()[0]
        
            cursor.execute("SELECT COUNT(*) FROM equipment WHERE status = 'Missing'")
            missing_equipment = cursor.fetchone()[0]
        
            cursor.execute("SELECT COUNT(*) FROM equipment WHERE status = 'Run to Failure'")
            rtf_equipment = cursor.fetchone()[0]
        
            analytics += "EQUIPMENT STATUS SUMMARY:\n"
            analytics += f"Total Equipment: {total_equipment}\n"
            analytics += f"Active Equipment: {active_equipment} ({active_equipment/total_equipment*100:.1f}%)\n"
            analytics += f"Missing Equipment: {missing_equipment} ({missing_equipment/total_equipment*100:.1f}%)\n"
            analytics += f"Run to Failure: {rtf_equipment} ({rtf_equipment/total_equipment*100:.1f}%)\n\n"
        
            # PM Type Distribution
            cursor.execute('SELECT COUNT(*) FROM equipment WHERE monthly_pm = TRUE')
            monthly_pm_count = cursor.fetchone()[0]

            cursor.execute('SELECT COUNT(*) FROM equipment WHERE six_month_pm = TRUE')
            six_month_pm_count = cursor.fetchone()[0]

            cursor.execute('SELECT COUNT(*) FROM equipment WHERE annual_pm = TRUE')
            annual_pm_count = cursor.fetchone()[0]
            
            analytics += "PM TYPE REQUIREMENTS:\n"
            analytics += f"Monthly PM Required: {monthly_pm_count} assets ({monthly_pm_count/total_equipment*100:.1f}%)\n"
            analytics += f"Six Month PM Required: {six_month_pm_count} assets ({six_month_pm_count/total_equipment*100:.1f}%)\n"
            analytics += f"Annual PM Required: {annual_pm_count} assets ({annual_pm_count/total_equipment*100:.1f}%)\n\n"
        
            # Location distribution
            cursor.execute('''
                SELECT location, COUNT(*) as count 
                FROM equipment 
                WHERE location IS NOT NULL AND location != ''
                GROUP BY location 
                ORDER BY count DESC 
                LIMIT 10
            ''')
            location_stats = cursor.fetchall()
        
            if location_stats:
                analytics += "TOP 10 EQUIPMENT LOCATIONS:\n"
                analytics += f"{'Location':<20} {'Count':<10} {'Percentage':<12}\n"
                analytics += "-" * 45 + "\n"
            
                for location, count in location_stats:
                    percentage = count / total_equipment * 100
                    analytics += f"{location:<20} {count:<10} {percentage:<11.1f}%\n"
                analytics += "\n"
        
            # Equipment without PM completions (never serviced)
            cursor.execute('''
                SELECT e.bfm_equipment_no, e.description, e.location
                FROM equipment e
                LEFT JOIN pm_completions pc ON e.bfm_equipment_no = pc.bfm_equipment_no
                WHERE pc.bfm_equipment_no IS NULL 
                AND e.status = 'Active'
                ORDER BY e.bfm_equipment_no
                LIMIT 20
            ''')
            never_serviced = cursor.fetchall()
        
            if never_serviced:
                analytics += f"EQUIPMENT NEVER SERVICED ({len(never_serviced)} items shown, may be more):\n"
                analytics += f"{'BFM Number':<15} {'Description':<30} {'Location':<15}\n"
                analytics += "-" * 62 + "\n"
            
                for bfm_no, description, location in never_serviced:
                    desc_short = (description[:27] + '...') if description and len(description) > 27 else (description or 'N/A')
                    loc_short = (location[:12] + '...') if location and len(location) > 12 else (location or 'N/A')
                    analytics += f"{bfm_no:<15} {desc_short:<30} {loc_short:<15}\n"
                analytics += "\n"
        
            # Equipment age analysis (based on creation date if available)
            cursor.execute('''
                SELECT
                    CASE
                        WHEN created_date >= CURRENT_DATE - INTERVAL '30 days' THEN 'Last 30 days'
                        WHEN created_date >= CURRENT_DATE - INTERVAL '90 days' THEN 'Last 90 days'
                        WHEN created_date >= CURRENT_DATE - INTERVAL '180 days' THEN 'Last 6 months'
                        WHEN created_date >= CURRENT_DATE - INTERVAL '365 days' THEN 'Last year'
                        ELSE 'Over 1 year'
                    END as age_category,
                    COUNT(*) as count
                FROM equipment
                WHERE created_date IS NOT NULL
                GROUP BY age_category
                ORDER BY 
                    CASE 
                        WHEN age_category = 'Last 30 days' THEN 1
                        WHEN age_category = 'Last 90 days' THEN 2
                        WHEN age_category = 'Last 6 months' THEN 3
                        WHEN age_category = 'Last year' THEN 4
                        ELSE 5
                    END
            ''')
            age_stats = cursor.fetchall()
        
            if age_stats:
                analytics += "EQUIPMENT AGE DISTRIBUTION (by creation date):\n"
                analytics += f"{'Age Category':<20} {'Count':<10} {'Percentage':<12}\n"
                analytics += "-" * 45 + "\n"
            
                total_with_dates = sum(count for _, count in age_stats)
                for age_category, count in age_stats:
                    percentage = count / total_with_dates * 100
                    analytics += f"{age_category:<20} {count:<10} {percentage:<11.1f}%\n"
                analytics += "\n"
        
            # Display analytics
            overview_text.insert('end', analytics)
            overview_text.config(state='disabled')
        
        except Exception as e:
            print(f"Error generating equipment overview: {e}")

    def generate_pm_performance_analysis(self, parent_frame):
        """Generate PM performance analytics"""
        try:
            cursor = self.conn.cursor()
            
            text_frame = ttk.Frame(parent_frame)
            text_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
            pm_text = tk.Text(text_frame, wrap='word', font=('Courier', 10))
            scrollbar = ttk.Scrollbar(text_frame, orient='vertical', command=pm_text.yview)
            pm_text.configure(yscrollcommand=scrollbar.set)
        
            pm_text.pack(side='left', fill='both', expand=True)
            scrollbar.pack(side='right', fill='y')
        
            analytics = "PM PERFORMANCE ANALYTICS\n"
            analytics += f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            analytics += "=" * 80 + "\n\n"
        
            # PM completion statistics by type
            cursor.execute('''
                SELECT pm_type, COUNT(*) as count, 
                    AVG(labor_hours + labor_minutes/60.0) as avg_hours,
                    MIN(completion_date) as first_completion,
                    MAX(completion_date) as last_completion
                FROM pm_completions 
                GROUP BY pm_type 
                ORDER BY count DESC
            ''')
            pm_type_stats = cursor.fetchall()
        
            if pm_type_stats:
                analytics += "PM COMPLETION STATISTICS BY TYPE:\n"
                analytics += f"{'PM Type':<15} {'Count':<10} {'Avg Hours':<12} {'Date Range':<25}\n"
                analytics += "-" * 65 + "\n"
            
                for pm_type, count, avg_hours, first_date, last_date in pm_type_stats:
                    avg_hours_display = f"{avg_hours:.1f}h" if avg_hours else "N/A"
                    date_range = f"{first_date} to {last_date}" if first_date and last_date else "N/A"
                    analytics += f"{pm_type:<15} {count:<10} {avg_hours_display:<12} {date_range:<25}\n"
                analytics += "\n"
        
            # Monthly completion trends (last 12 months)
            cursor.execute('''
                SELECT
                    TO_CHAR(completion_date::date, 'YYYY-MM') as month,
                    COUNT(*) as completions,
                    AVG(labor_hours + labor_minutes/60.0) as avg_hours
                FROM pm_completions
                WHERE completion_date::date >= CURRENT_DATE - INTERVAL '12 months'
                GROUP BY TO_CHAR(completion_date::date, 'YYYY-MM')
                ORDER BY month DESC
            ''')
            monthly_trends = cursor.fetchall()
        
            if monthly_trends:
                analytics += "MONTHLY PM COMPLETION TRENDS (Last 12 months):\n"
                analytics += f"{'Month':<10} {'Completions':<12} {'Avg Hours':<12}\n"
                analytics += "-" * 36 + "\n"
            
                for month, completions, avg_hours in monthly_trends:
                    avg_hours_display = f"{avg_hours:.1f}h" if avg_hours else "0.0h"
                    analytics += f"{month:<10} {completions:<12} {avg_hours_display:<12}\n"
                analytics += "\n"
        
            # Equipment with overdue PMs
            current_date = datetime.now()
        
            cursor.execute('''
                SELECT e.bfm_equipment_no, e.description, e.location,
                    e.last_monthly_pm, e.last_annual_pm,
                    CASE
                        WHEN e.last_monthly_pm IS NULL OR e.last_monthly_pm + INTERVAL '30 days' < CURRENT_DATE THEN 'Monthly Overdue'
                        WHEN e.last_annual_pm IS NULL OR e.last_annual_pm + INTERVAL '365 days' < CURRENT_DATE THEN 'Annual Overdue'
                        ELSE 'Current'
                    END as pm_status
                FROM equipment e
                WHERE e.status = 'Active'
                AND (
                    (e.monthly_pm = TRUE AND (e.last_monthly_pm IS NULL OR e.last_monthly_pm + INTERVAL '30 days' < CURRENT_DATE))
                    OR
                    (e.annual_pm = TRUE AND (e.last_annual_pm IS NULL OR e.last_annual_pm + INTERVAL '365 days' < CURRENT_DATE))
                )
                ORDER BY e.bfm_equipment_no
                LIMIT 25
            ''')
            overdue_equipment = cursor.fetchall()
        
            if overdue_equipment:
                analytics += f"OVERDUE PM EQUIPMENT ({len(overdue_equipment)} items shown):\n"
                analytics += f"{'BFM Number':<15} {'Description':<25} {'Location':<12} {'Status':<15}\n"
                analytics += "-" * 70 + "\n"
                
                for bfm_no, description, location, pm_status in overdue_equipment:
                    desc_short = (description[:22] + '...') if description and len(description) > 22 else (description or 'N/A')
                    loc_short = (location[:9] + '...') if location and len(location) > 9 else (location or 'N/A')
                    analytics += f"{bfm_no:<15} {desc_short:<25} {loc_short:<12} {pm_status:<15}\n"
                analytics += "\n"
        
            # PM frequency analysis
            cursor.execute('''
                SELECT e.bfm_equipment_no, COUNT(pc.id) as pm_count,
                    MIN(pc.completion_date) as first_pm,
                    MAX(pc.completion_date) as last_pm,
                    AVG(pc.labor_hours + pc.labor_minutes/60.0) as avg_hours
                FROM equipment e
                LEFT JOIN pm_completions pc ON e.bfm_equipment_no = pc.bfm_equipment_no
                WHERE e.status = 'Active'
                GROUP BY e.bfm_equipment_no
                HAVING pm_count > 0
                ORDER BY pm_count DESC
                LIMIT 15
            ''')
            high_maintenance_equipment = cursor.fetchall()
        
            if high_maintenance_equipment:
                analytics += "TOP 15 MOST SERVICED EQUIPMENT:\n"
                analytics += f"{'BFM Number':<15} {'PM Count':<10} {'First PM':<12} {'Last PM':<12} {'Avg Hours':<10}\n"
                analytics += "-" * 62 + "\n"
            
                for bfm_no, pm_count, first_pm, last_pm, avg_hours in high_maintenance_equipment:
                    avg_hours_display = f"{avg_hours:.1f}h" if avg_hours else "0.0h"
                    analytics += f"{bfm_no:<15} {pm_count:<10} {first_pm or 'N/A':<12} {last_pm or 'N/A':<12} {avg_hours_display:<10}\n"
                analytics += "\n"
        
            pm_text.insert('end', analytics)
            pm_text.config(state='disabled')
        
        except Exception as e:
            print(f"Error generating PM performance analysis: {e}")

    def generate_location_analysis(self, parent_frame):
        """Generate location-based analytics"""
        try:
            cursor = self.conn.cursor()
        
            text_frame = ttk.Frame(parent_frame)
            text_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
            location_text = tk.Text(text_frame, wrap='word', font=('Courier', 10))
            scrollbar = ttk.Scrollbar(text_frame, orient='vertical', command=location_text.yview)
            location_text.configure(yscrollcommand=scrollbar.set)
        
            location_text.pack(side='left', fill='both', expand=True)
            scrollbar.pack(side='right', fill='y')
        
            analytics = "LOCATION-BASED ANALYTICS\n"
            analytics += f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            analytics += "=" * 80 + "\n\n"
        
            # Equipment distribution by location
            cursor.execute('''
                SELECT 
                    COALESCE(location, 'Unknown') as location,
                    COUNT(*) as total_equipment,
                    COUNT(CASE WHEN status = 'Active' THEN 1 END) as active,
                    COUNT(CASE WHEN status = 'Missing' THEN 1 END) as missing,
                    COUNT(CASE WHEN status = 'Run to Failure' THEN 1 END) as rtf
                FROM equipment
                GROUP BY COALESCE(location, 'Unknown')
                ORDER BY total_equipment DESC
            ''')
            location_distribution = cursor.fetchall()
        
            if location_distribution:
                analytics += "EQUIPMENT DISTRIBUTION BY LOCATION:\n"
                analytics += f"{'Location':<20} {'Total':<8} {'Active':<8} {'Missing':<8} {'RTF':<8}\n"
                analytics += "-" * 55 + "\n"
            
                for location, total, active, missing, rtf in location_distribution:
                    loc_display = location[:17] + '...' if len(location) > 17 else location
                    analytics += f"{loc_display:<20} {total:<8} {active:<8} {missing:<8} {rtf:<8}\n"
                analytics += "\n"
        
            # PM completion activity by location
            cursor.execute('''
                SELECT 
                    COALESCE(e.location, 'Unknown') as location,
                    COUNT(pc.id) as total_pms,
                    COUNT(CASE WHEN pc.pm_type = 'Monthly' THEN 1 END) as monthly,
                    COUNT(CASE WHEN pc.pm_type = 'Annual' THEN 1 END) as annual,
                    AVG(pc.labor_hours + pc.labor_minutes/60.0) as avg_hours
                FROM pm_completions pc
                JOIN equipment e ON pc.bfm_equipment_no = e.bfm_equipment_no
                WHERE pc.completion_date >= CURRENT_DATE - INTERVAL '90 days'
                GROUP BY COALESCE(e.location, 'Unknown')
                ORDER BY total_pms DESC
            ''')
            location_pm_activity = cursor.fetchall()
        
            if location_pm_activity:
                analytics += "PM ACTIVITY BY LOCATION (Last 90 days):\n"
                analytics += f"{'Location':<20} {'Total PMs':<10} {'Monthly':<8} {'Annual':<8} {'Avg Hours':<10}\n"
                analytics += "-" * 60 + "\n"
            
                for location, total_pms, monthly, annual, avg_hours in location_pm_activity:
                    loc_display = location[:17] + '...' if len(location) > 17 else location
                    avg_hours_display = f"{avg_hours:.1f}h" if avg_hours else "0.0h"
                    analytics += f"{loc_display:<20} {total_pms:<10} {monthly:<8} {annual:<8} {avg_hours_display:<10}\n"
                analytics += "\n"
        
            # Cannot Find assets by location
            cursor.execute('''
                SELECT 
                    COALESCE(location, 'Unknown') as location,
                    COUNT(*) as missing_count,
                    GROUP_CONCAT(bfm_equipment_no, ', ') as missing_assets
                FROM cannot_find_assets
                WHERE status = 'Missing'
                GROUP BY COALESCE(location, 'Unknown')
                ORDER BY missing_count DESC
            ''')
            missing_by_location = cursor.fetchall()
        
            if missing_by_location:
                analytics += "MISSING ASSETS BY LOCATION:\n"
                analytics += f"{'Location':<20} {'Count':<8} {'Equipment Numbers':<50}\n"
                analytics += "-" * 80 + "\n"
            
                for location, count, assets in missing_by_location:
                    loc_display = location[:17] + '...' if len(location) > 17 else location
                    assets_display = assets[:47] + '...' if assets and len(assets) > 47 else (assets or '')
                    analytics += f"{loc_display:<20} {count:<8} {assets_display:<50}\n"
                analytics += "\n"
        
            # Location efficiency analysis
            cursor.execute('''
                SELECT 
                    COALESCE(e.location, 'Unknown') as location,
                    COUNT(DISTINCT e.bfm_equipment_no) as equipment_count,
                    COUNT(pc.id) as pm_completions,
                    ROUND(CAST(COUNT(pc.id) AS FLOAT) / COUNT(DISTINCT e.bfm_equipment_no), 2) as pms_per_equipment
                FROM equipment e
                LEFT JOIN pm_completions pc ON e.bfm_equipment_no = pc.bfm_equipment_no
                    AND pc.completion_date >= CURRENT_DATE - INTERVAL '365 days'
                WHERE e.status = 'Active'
                GROUP BY COALESCE(e.location, 'Unknown')
                HAVING equipment_count >= 3
                ORDER BY pms_per_equipment DESC
            ''')
            location_efficiency = cursor.fetchall()
        
            if location_efficiency:
                analytics += "LOCATION PM EFFICIENCY (PMs per equipment, last year):\n"
                analytics += f"{'Location':<20} {'Equipment':<10} {'PMs':<8} {'PMs/Equipment':<15}\n"
                analytics += "-" * 55 + "\n"
                
                for location, equipment_count, pm_completions, pms_per_equipment in location_efficiency:
                    loc_display = location[:17] + '...' if len(location) > 17 else location
                    analytics += f"{loc_display:<20} {equipment_count:<10} {pm_completions:<8} {pms_per_equipment:<15}\n"
                analytics += "\n"
        
            location_text.insert('end', analytics)
            location_text.config(state='disabled')
        
        except Exception as e:
            print(f"Error generating location analysis: {e}")

    def generate_technician_analysis(self, parent_frame):
        """Generate technician workload and performance analytics"""
        try:
            cursor = self.conn.cursor()
        
            text_frame = ttk.Frame(parent_frame)
            text_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
            tech_text = tk.Text(text_frame, wrap='word', font=('Courier', 10))
            scrollbar = ttk.Scrollbar(text_frame, orient='vertical', command=tech_text.yview)
            tech_text.configure(yscrollcommand=scrollbar.set)
        
            tech_text.pack(side='left', fill='both', expand=True)
            scrollbar.pack(side='right', fill='y')
        
            analytics = "TECHNICIAN PERFORMANCE ANALYTICS\n"
            analytics += f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            analytics += "=" * 80 + "\n\n"
        
            # Overall technician performance
            cursor.execute('''
                SELECT 
                    technician_name,
                    COUNT(*) as total_pms,
                    COUNT(CASE WHEN pm_type = 'Monthly' THEN 1 END) as monthly_pms,
                    COUNT(CASE WHEN pm_type = 'Annual' THEN 1 END) as annual_pms,
                    AVG(labor_hours + labor_minutes/60.0) as avg_hours,
                    SUM(labor_hours + labor_minutes/60.0) as total_hours,
                    MIN(completion_date) as first_completion,
                    MAX(completion_date) as last_completion
                FROM pm_completions
                GROUP BY technician_name
                ORDER BY total_pms DESC
            ''')
            technician_performance = cursor.fetchall()
        
            if technician_performance:
                analytics += "OVERALL TECHNICIAN PERFORMANCE:\n"
                analytics += f"{'Technician':<20} {'Total PMs':<10} {'Monthly':<8} {'Annual':<8} {'Avg Hrs':<8} {'Total Hrs':<10}\n"
                analytics += "-" * 75 + "\n"
            
                for tech_data in technician_performance:
                    technician, total_pms, monthly, annual, avg_hours, total_hours, first_date, last_date = tech_data
                    tech_display = technician[:17] + '...' if len(technician) > 17 else technician
                    avg_hours_display = f"{avg_hours:.1f}" if avg_hours else "0.0"
                    total_hours_display = f"{total_hours:.1f}" if total_hours else "0.0"
                
                    analytics += f"{tech_display:<20} {total_pms:<10} {monthly:<8} {annual:<8} {avg_hours_display:<8} {total_hours_display:<10}\n"
                analytics += "\n"
        
            # Recent activity (last 30 days)
            cursor.execute('''
                SELECT 
                    technician_name,
                    COUNT(*) as recent_pms,
                    AVG(labor_hours + labor_minutes/60.0) as avg_hours,
                    COUNT(DISTINCT bfm_equipment_no) as unique_equipment
                FROM pm_completions
                WHERE completion_date >= CURRENT_DATE - INTERVAL '30 days'
                GROUP BY technician_name
                ORDER BY recent_pms DESC
            ''')
            recent_activity = cursor.fetchall()
        
            if recent_activity:
                analytics += "RECENT ACTIVITY (Last 30 days):\n"
                analytics += f"{'Technician':<20} {'PMs':<6} {'Avg Hours':<10} {'Unique Equipment':<18}\n"
                analytics += "-" * 56 + "\n"
            
                for technician, recent_pms, avg_hours, unique_equipment in recent_activity:
                    tech_display = technician[:17] + '...' if len(technician) > 17 else technician
                    avg_hours_display = f"{avg_hours:.1f}h" if avg_hours else "0.0h"
                
                    analytics += f"{tech_display:<20} {recent_pms:<6} {avg_hours_display:<10} {unique_equipment:<18}\n"
                analytics += "\n"
        
            # Cannot Find reports by technician
            cursor.execute('''
                SELECT
                    technician_name,
                    COUNT(*) as cannot_find_count,
                    COUNT(CASE WHEN reported_date >= CURRENT_DATE - INTERVAL '30 days' THEN 1 END) as recent_cf
                FROM cannot_find_assets
                WHERE status = 'Missing'
                GROUP BY technician_name
                ORDER BY cannot_find_count DESC
            ''')
            cannot_find_by_tech = cursor.fetchall()
        
            if cannot_find_by_tech:
                analytics += "CANNOT FIND REPORTS BY TECHNICIAN:\n"
                analytics += f"{'Technician':<20} {'Total CF':<10} {'Recent (30d)':<15}\n"
                analytics += "-" * 47 + "\n"
            
                for technician, total_cf, recent_cf in cannot_find_by_tech:
                    tech_display = technician[:17] + '...' if len(technician) > 17 else technician
                    analytics += f"{tech_display:<20} {total_cf:<10} {recent_cf:<15}\n"
                analytics += "\n"
        
            # Workload distribution analysis
            cursor.execute('''
                SELECT
                    technician_name,
                    TO_CHAR(completion_date::date, 'YYYY-MM') as month,
                    COUNT(*) as monthly_completions,
                    AVG(labor_hours + labor_minutes/60.0) as avg_hours
                FROM pm_completions
                WHERE completion_date::date >= CURRENT_DATE - INTERVAL '6 months'
                GROUP BY technician_name, TO_CHAR(completion_date::date, 'YYYY-MM')
                ORDER BY technician_name, month DESC
            ''')
            monthly_workload = cursor.fetchall()
        
            if monthly_workload:
                analytics += "MONTHLY WORKLOAD DISTRIBUTION (Last 6 months):\n"
            
                # Group by technician
                tech_monthly = {}
                for technician, month, completions, avg_hours in monthly_workload:
                    if technician not in tech_monthly:
                        tech_monthly[technician] = []
                    tech_monthly[technician].append((month, completions, avg_hours))
            
                for technician, monthly_data in tech_monthly.items():
                    tech_display = technician[:17] + '...' if len(technician) > 17 else technician
                    analytics += f"\n{tech_display}:\n"
                    analytics += f"{'  Month':<12} {'PMs':<6} {'Avg Hours':<10}\n"
                    analytics += "  " + "-" * 30 + "\n"
                
                    for month, completions, avg_hours in monthly_data[:6]:  # Show last 6 months
                        avg_hours_display = f"{avg_hours:.1f}h" if avg_hours else "0.0h"
                        analytics += f"  {month:<12} {completions:<6} {avg_hours_display:<10}\n"
                analytics += "\n"
        
            # Efficiency metrics
            if technician_performance:
                analytics += "TECHNICIAN EFFICIENCY METRICS:\n"
                analytics += f"{'Technician':<20} {'PMs/Month':<12} {'Hours/PM':<10} {'Productivity':<12}\n"
                analytics += "-" * 60 + "\n"
            
                for tech_data in technician_performance:
                    technician, total_pms, monthly, annual, avg_hours, total_hours, first_date, last_date = tech_data
                
                    # Calculate months active (rough estimate)
                    if first_date and last_date:
                        try:
                            first_dt = datetime.strptime(first_date, '%Y-%m-%d')
                            last_dt = datetime.strptime(last_date, '%Y-%m-%d')
                            months_active = max(1, (last_dt - first_dt).days / 30.44)  # Average days per month
                            pms_per_month = total_pms / months_active
                        except:
                            months_active = 1
                            pms_per_month = total_pms
                    else:
                        pms_per_month = total_pms
                
                    hours_per_pm = avg_hours if avg_hours else 0
                
                    # Productivity score (PMs per month / hours per PM)
                    productivity = pms_per_month / max(hours_per_pm, 0.1) if hours_per_pm > 0 else pms_per_month
                    
                    tech_display = technician[:17] + '...' if len(technician) > 17 else technician
                    analytics += f"{tech_display:<20} {pms_per_month:<11.1f} {hours_per_pm:<9.1f} {productivity:<11.1f}\n"
                analytics += "\n"
        
            tech_text.insert('end', analytics)
            tech_text.config(state='disabled')
        
        except Exception as e:
            print(f"Error generating technician analysis: {e}")
    
    def export_equipment_analytics_pdf(self, parent_dialog):
        """Export all analytics to a comprehensive PDF report"""
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"Equipment_Analytics_Report_{timestamp}.pdf"
        
            # Create PDF document
            doc = SimpleDocTemplate(filename, pagesize=letter)
            story = []
            styles = getSampleStyleSheet()
        
            # Title page
            title_style = ParagraphStyle('TitleStyle', parent=styles['Title'], 
                                    fontSize=20, textColor=colors.darkblue, alignment=1)
            story.append(Paragraph("AIT CMMS EQUIPMENT ANALYTICS REPORT", title_style))
            story.append(Spacer(1, 30))
        
            # Report metadata
            story.append(Paragraph(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", styles['Normal']))
            story.append(Paragraph(f"Report ID: {timestamp}", styles['Normal']))
            story.append(Spacer(1, 40))
        
            # Executive Summary
            cursor = self.conn.cursor()
        
            cursor.execute('SELECT COUNT(*) FROM equipment')
            total_equipment = cursor.fetchone()[0]
        
            cursor.execute("SELECT COUNT(*) FROM equipment WHERE status = 'Active'")
            active_equipment = cursor.fetchone()[0]
        
            cursor.execute("SELECT COUNT(*) FROM pm_completions WHERE completion_date >= CURRENT_DATE - INTERVAL '30 days'")
            recent_pms = cursor.fetchone()[0]
        
            cursor.execute("SELECT COUNT(*) FROM cannot_find_assets WHERE status = 'Missing'")
            missing_assets = cursor.fetchone()[0]
        
            story.append(Paragraph("EXECUTIVE SUMMARY", styles['Heading1']))
            summary_data = [
                ['Metric', 'Value', 'Status'],
                ['Total Equipment', str(total_equipment), 'Baseline'],
                ['Active Equipment', str(active_equipment), f'{active_equipment/total_equipment*100:.1f}%'],
                ['PMs Last 30 Days', str(recent_pms), 'Recent Activity'],
                ['Missing Assets', str(missing_assets), 'Attention Needed' if missing_assets > 0 else 'Good']
            ]
        
            summary_table = Table(summary_data, colWidths=[2*inch, 1.5*inch, 2*inch])
            summary_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 10),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
        
            story.append(summary_table)
            story.append(PageBreak())
        
            # Add detailed sections
            sections = [
                ("Equipment Overview", self.get_equipment_overview_text()),
                ("PM Performance Analysis", self.get_pm_performance_text()),
                ("Location Analysis", self.get_location_analysis_text()),
                ("Technician Analysis", self.get_technician_analysis_text())
            ]
        
            for section_title, section_content in sections:
                story.append(Paragraph(section_title, styles['Heading1']))
                story.append(Spacer(1, 12))
            
                # Split content into paragraphs
                paragraphs = section_content.split('\n\n')
                for paragraph in paragraphs:
                    if paragraph.strip():
                        story.append(Paragraph(paragraph.replace('\n', '<br/>'), styles['Normal']))
                        story.append(Spacer(1, 6))
            
                story.append(PageBreak())
        
            # Build PDF
            doc.build(story)
        
            messagebox.showinfo("Success", f"Analytics report exported to: {filename}")
            self.update_status(f"Equipment analytics exported to {filename}")
        
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export analytics: {str(e)}")

    def get_equipment_overview_text(self):
        """Get equipment overview text for PDF export"""
        try:
            cursor = self.conn.cursor()
        
            # Basic statistics
            cursor.execute('SELECT COUNT(*) FROM equipment')
            total_equipment = cursor.fetchone()[0]
        
            cursor.execute("SELECT COUNT(*) FROM equipment WHERE status = 'Active'")
            active_equipment = cursor.fetchone()[0]
        
            text = f"Total Equipment: {total_equipment}\n"
            text += f"Active Equipment: {active_equipment} ({active_equipment/total_equipment*100:.1f}%)\n\n"
        
            # PM requirements
            cursor.execute('SELECT COUNT(*) FROM equipment WHERE monthly_pm = TRUE')
            monthly_count = cursor.fetchone()[0]
            text += f"Equipment requiring Monthly PM: {monthly_count}\n"

            cursor.execute('SELECT COUNT(*) FROM equipment WHERE annual_pm = TRUE')
            annual_count = cursor.fetchone()[0]
            text += f"Equipment requiring Annual PM: {annual_count}\n"
        
            return text
        
        except Exception as e:
            return f"Error generating overview text: {str(e)}"

    def get_pm_performance_text(self):
        """Get PM performance text for PDF export"""
        try:
            cursor = self.conn.cursor()
        
            cursor.execute('SELECT pm_type, COUNT(*) FROM pm_completions GROUP BY pm_type')
            pm_stats = cursor.fetchall()
        
            text = "PM Completion Statistics:\n"
            for pm_type, count in pm_stats:
                text += f"{pm_type}: {count} completions\n"
        
            return text
        
        except Exception as e:
            return f"Error generating PM performance text: {str(e)}"

    def get_location_analysis_text(self):
        """Get location analysis text for PDF export"""
        try:
            cursor = self.conn.cursor()
        
            cursor.execute('''
                SELECT location, COUNT(*) 
                FROM equipment 
                WHERE location IS NOT NULL 
                GROUP BY location 
                ORDER BY COUNT(*) DESC 
                LIMIT 10
            ''')
            location_stats = cursor.fetchall()
        
            text = "Equipment by Location:\n"
            for location, count in location_stats:
                text += f"{location}: {count} assets\n"
        
            return text
        
        except Exception as e:
            return f"Error generating location analysis text: {str(e)}"

    def get_technician_analysis_text(self):
        """Get technician analysis text for PDF export"""
        try:
            cursor = self.conn.cursor()
            
            cursor.execute('''
                SELECT technician_name, COUNT(*) 
                FROM pm_completions 
                GROUP BY technician_name 
                ORDER BY COUNT(*) DESC
            ''')
            tech_stats = cursor.fetchall()
        
            text = "PM Completions by Technician:\n"
            for technician, count in tech_stats:
                text += f"{technician}: {count} PMs completed\n"
        
            return text
        
        except Exception as e:
            return f"Error generating technician analysis text: {str(e)}"
    
    
    def show_pm_trends(self):
        """Comprehensive PM trends analysis with visualizations and insights"""
        try:
            # Create trends analysis dialog
            trends_dialog = tk.Toplevel(self.root)
            trends_dialog.title("PM Trends Analysis Dashboard")
            trends_dialog.geometry("1400x900")
            trends_dialog.transient(self.root)
            trends_dialog.grab_set()

            # Create notebook for different trend views
            trends_notebook = ttk.Notebook(trends_dialog)
            trends_notebook.pack(fill='both', expand=True, padx=10, pady=10)

            # Tab 1: Monthly Completion Trends
            monthly_frame = ttk.Frame(trends_notebook)
            trends_notebook.add(monthly_frame, text="Monthly Trends")

            # Tab 2: Equipment Performance Trends
            equipment_frame = ttk.Frame(trends_notebook)
            trends_notebook.add(equipment_frame, text="Equipment Trends")

            # Tab 3: Technician Performance Trends
            technician_frame = ttk.Frame(trends_notebook)
            trends_notebook.add(technician_frame, text="Technician Trends")

            # Tab 4: PM Type Distribution Trends
            pm_type_frame = ttk.Frame(trends_notebook)
            trends_notebook.add(pm_type_frame, text="PM Type Trends")

            # Generate content for each tab
            self.generate_monthly_trends_analysis(monthly_frame)
            self.generate_equipment_trends_analysis(equipment_frame)
            self.generate_technician_trends_analysis(technician_frame)
            self.generate_pm_type_trends_analysis(pm_type_frame)

            # Add export and close buttons
            button_frame = ttk.Frame(trends_dialog)
            button_frame.pack(side='bottom', fill='x', padx=10, pady=5)

            ttk.Button(button_frame, text="Export Trends to PDF", 
                    command=lambda: self.export_trends_analysis_pdf(trends_dialog)).pack(side='left', padx=5)
            ttk.Button(button_frame, text="Refresh Analysis", 
                    command=lambda: self.refresh_trends_analysis(trends_dialog)).pack(side='left', padx=5)
            ttk.Button(button_frame, text="Close", 
                    command=trends_dialog.destroy).pack(side='right', padx=5)
    
        except Exception as e:
            messagebox.showerror("Error", f"Failed to generate PM trends analysis: {str(e)}")

    def generate_monthly_trends_analysis(self, parent_frame):
        """Generate monthly PM completion trends analysis"""
        try:
            cursor = self.conn.cursor()

            # Create scrollable frame
            canvas = tk.Canvas(parent_frame)
            scrollbar = ttk.Scrollbar(parent_frame, orient="vertical", command=canvas.yview)
            scrollable_frame = ttk.Frame(canvas)

            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )

            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)

            # Monthly completion data (last 24 months)
            cursor.execute('''
                SELECT
                    TO_CHAR(completion_date::date, 'YYYY-MM') as month,
                    COUNT(*) as total_completions,
                    COUNT(CASE WHEN pm_type = 'Monthly' THEN 1 END) as monthly_pms,
                    COUNT(CASE WHEN pm_type = 'Annual' THEN 1 END) as annual_pms,
                    COUNT(CASE WHEN pm_type = 'Six Month' THEN 1 END) as six_month_pms,
                    AVG(labor_hours + labor_minutes/60.0) as avg_hours,
                    COUNT(DISTINCT technician_name) as active_technicians,
                    COUNT(DISTINCT bfm_equipment_no) as unique_equipment
                FROM pm_completions
                WHERE completion_date::date >= CURRENT_DATE - INTERVAL '24 months'
                GROUP BY TO_CHAR(completion_date::date, 'YYYY-MM')
                ORDER BY month ASC
            ''')

            monthly_data = cursor.fetchall()

            # Create text display for trends
            trends_text = tk.Text(scrollable_frame, wrap='word', font=('Courier', 10), height=40)
            text_scrollbar = ttk.Scrollbar(scrollable_frame, orient='vertical', command=trends_text.yview)
            trends_text.configure(yscrollcommand=text_scrollbar.set)

            # Generate trends report
            report = "PM COMPLETION TRENDS ANALYSIS\n"
            report += f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            report += "=" * 80 + "\n\n"

            if monthly_data:
                report += "MONTHLY COMPLETION TRENDS (Last 24 months):\n"
                report += "-" * 80 + "\n"
                report += f"{'Month':<10} {'Total':<8} {'Monthly':<8} {'Annual':<8} {'6-Month':<8} {'Avg Hrs':<8} {'Techs':<6} {'Equipment':<10}\n"
                report += "-" * 80 + "\n"

                total_completions = 0
                total_hours = 0
                peak_month = None
                peak_completions = 0
                lowest_month = None
                lowest_completions = float('inf')

                for month_data in monthly_data:
                    month, total, monthly_pms, annual_pms, six_month_pms, avg_hours, techs, equipment = month_data
                    total_completions += total
                    total_hours += avg_hours if avg_hours else 0

                    # Track peak and low months
                    if total > peak_completions:
                        peak_completions = total
                        peak_month = month
                    if total < lowest_completions:
                        lowest_completions = total
                        lowest_month = month

                    avg_hours_str = f"{avg_hours:.1f}" if avg_hours else "0.0"
                    report += f"{month:<10} {total:<8} {monthly_pms:<8} {annual_pms:<8} {six_month_pms:<8} {avg_hours_str:<8} {techs:<6} {equipment:<10}\n"

                # Calculate trends
                avg_monthly_completions = total_completions / len(monthly_data) if monthly_data else 0
                avg_hours_overall = total_hours / len(monthly_data) if monthly_data else 0

                # Recent trend analysis (last 6 months vs previous 6 months)
                recent_6_months = monthly_data[-6:] if len(monthly_data) >= 6 else monthly_data
                previous_6_months = monthly_data[-12:-6] if len(monthly_data) >= 12 else []

                recent_avg = sum(row[1] for row in recent_6_months) / len(recent_6_months) if recent_6_months else 0
                previous_avg = sum(row[1] for row in previous_6_months) / len(previous_6_months) if previous_6_months else 0

                trend_direction = "UP" if recent_avg > previous_avg else "DOWN" if recent_avg < previous_avg else "STABLE"
                trend_percentage = ((recent_avg - previous_avg) / previous_avg * 100) if previous_avg > 0 else 0

                report += "\n" + "=" * 80 + "\n"
                report += "TREND ANALYSIS SUMMARY:\n"
                report += "=" * 80 + "\n"
                report += f"Total Months Analyzed: {len(monthly_data)}\n"
                report += f"Total Completions: {total_completions}\n"
                report += f"Average Completions per Month: {avg_monthly_completions:.1f}\n"
                report += f"Average Hours per PM: {avg_hours_overall:.1f}h\n\n"

                report += f"Peak Performance Month: {peak_month} ({peak_completions} completions)\n"
                report += f"Lowest Performance Month: {lowest_month} ({lowest_completions} completions)\n\n"

                report += f"6-Month Trend Analysis:\n"
                report += f"Recent 6 months average: {recent_avg:.1f} completions/month\n"
                report += f"Previous 6 months average: {previous_avg:.1f} completions/month\n"
                report += f"Trend Direction: {trend_direction} ({trend_percentage:+.1f}%)\n\n"

                # Seasonal analysis
                report += "SEASONAL PATTERNS:\n"
                report += "-" * 40 + "\n"
                seasonal_data = {}
                for month_data in monthly_data:
                    month_str, total = month_data[0], month_data[1]
                    month_num = int(month_str.split('-')[1])
                    season = self.get_season_from_month(month_num)
                    if season not in seasonal_data:
                        seasonal_data[season] = []
                    seasonal_data[season].append(total)
    
                for season, completions in seasonal_data.items():
                    avg_seasonal = sum(completions) / len(completions)
                    report += f"{season:<10}: {avg_seasonal:.1f} avg completions/month\n"

                # Workload distribution analysis
                report += "\nWORKLOAD DISTRIBUTION INSIGHTS:\n"
                report += "-" * 40 + "\n"
            
                # Calculate coefficient of variation for consistency
                if len(monthly_data) > 1:
                    completions_list = [row[1] for row in monthly_data]
                    import statistics
                    std_dev = statistics.stdev(completions_list)
                    cv = (std_dev / avg_monthly_completions) * 100 if avg_monthly_completions > 0 else 0
                
                    consistency_rating = "Very Consistent" if cv < 15 else "Consistent" if cv < 25 else "Variable" if cv < 35 else "Highly Variable"
                    report += f"Workload Consistency: {consistency_rating} (CV: {cv:.1f}%)\n"
                    report += f"Standard Deviation: {std_dev:.1f} completions\n\n"

                # Recommendations
                report += "RECOMMENDATIONS:\n"
                report += "-" * 40 + "\n"
                if trend_direction == "DOWN":
                    report += "- Investigate causes of declining PM completion rates\n"
                    report += "- Consider additional technician training or resources\n"
                    report += "- Review equipment scheduling and assignment processes\n"
                elif trend_direction == "UP":
                    report += "- Excellent performance trend - maintain current practices\n"
                    report += "- Consider documenting successful strategies for replication\n"
            
                if cv > 30:
                    report += "- High variability detected - investigate scheduling consistency\n"
                    report += "- Consider implementing better workload balancing\n"
            
                if avg_hours_overall > 2.0:
                    report += "- Average PM time is high - review procedures for efficiency\n"
                elif avg_hours_overall < 0.5:
                    report += "- Very low average PM time - verify completeness of work\n"

            else:
                report += "No PM completion data found for trend analysis.\n"

            # Display the report
            trends_text.insert('end', report)
            trends_text.config(state='disabled')

            # Pack widgets
            trends_text.pack(side='left', fill='both', expand=True)
            text_scrollbar.pack(side='right', fill='y')

            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")

        except Exception as e:
            error_label = ttk.Label(parent_frame, text=f"Error generating monthly trends: {str(e)}")
            error_label.pack(pady=20)

    def generate_equipment_trends_analysis(self, parent_frame):
        """Generate equipment-specific PM trends analysis"""
        try:
            cursor = self.conn.cursor()

            # Create text widget for equipment trends
            equipment_text = tk.Text(parent_frame, wrap='word', font=('Courier', 10))
            scrollbar = ttk.Scrollbar(parent_frame, orient='vertical', command=equipment_text.yview)
            equipment_text.configure(yscrollcommand=scrollbar.set)

            report = "EQUIPMENT PM TRENDS ANALYSIS\n"
            report += f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            report += "=" * 80 + "\n\n"

            # Most frequently serviced equipment
            cursor.execute('''
                SELECT e.bfm_equipment_no, e.description, e.location,
                       COUNT(pc.id) as total_pms,
                       AVG(pc.labor_hours + pc.labor_minutes/60.0) as avg_hours,
                       MIN(pc.completion_date) as first_pm,
                       MAX(pc.completion_date) as last_pm,
                       COUNT(CASE WHEN pc.completion_date >= CURRENT_DATE - INTERVAL '90 days' THEN 1 END) as recent_pms
                FROM equipment e
                LEFT JOIN pm_completions pc ON e.bfm_equipment_no = pc.bfm_equipment_no
                WHERE e.status = 'Active'
                GROUP BY e.bfm_equipment_no, e.description, e.location
                HAVING total_pms > 0
                ORDER BY total_pms DESC
                LIMIT 20
            ''')

            high_maintenance_equipment = cursor.fetchall()

            if high_maintenance_equipment:
                report += "TOP 20 MOST SERVICED EQUIPMENT:\n"
                report += "-" * 80 + "\n"
                report += f"{'Rank':<5} {'BFM No':<12} {'Description':<25} {'Total PMs':<10} {'Avg Hours':<10} {'Recent (90d)':<12}\n"
                report += "-" * 80 + "\n"

                for i, equipment in enumerate(high_maintenance_equipment, 1):
                    bfm_no, description, location, total_pms, avg_hours, first_pm, last_pm, recent_pms = equipment
                    desc_short = (description[:22] + '...') if description and len(description) > 22 else (description or 'N/A')
                    avg_hours_str = f"{avg_hours:.1f}h" if avg_hours else "0.0h"
                    
                    report += f"{i:<5} {bfm_no:<12} {desc_short:<25} {total_pms:<10} {avg_hours_str:<10} {recent_pms:<12}\n"

            # Equipment with increasing maintenance needs
            cursor.execute('''
                SELECT bfm_equipment_no,
                       COUNT(CASE WHEN completion_date >= CURRENT_DATE - INTERVAL '90 days' THEN 1 END) as last_90_days,
                       COUNT(CASE WHEN completion_date >= CURRENT_DATE - INTERVAL '180 days' AND completion_date < CURRENT_DATE - INTERVAL '90 days' THEN 1 END) as prev_90_days,
                       COUNT(*) as total_pms
                FROM pm_completions
                WHERE completion_date >= CURRENT_DATE - INTERVAL '180 days'
                GROUP BY bfm_equipment_no
                HAVING last_90_days > prev_90_days AND prev_90_days > 0
                ORDER BY (last_90_days - prev_90_days) DESC
                LIMIT 10
            ''')

            increasing_maintenance = cursor.fetchall()

            if increasing_maintenance:
                report += "\n\nEQUIPMENT WITH INCREASING MAINTENANCE NEEDS:\n"
                report += "-" * 60 + "\n"
                report += f"{'BFM No':<15} {'Recent 90d':<12} {'Previous 90d':<12} {'Increase':<10}\n"
                report += "-" * 60 + "\n"

                for equipment in increasing_maintenance:
                    bfm_no, last_90, prev_90, total = equipment
                    increase = last_90 - prev_90
                    report += f"{bfm_no:<15} {last_90:<12} {prev_90:<12} +{increase:<9}\n"

            # Equipment that hasn't been serviced recently
            cursor.execute('''
                SELECT e.bfm_equipment_no, e.description, e.location,
                       MAX(pc.completion_date) as last_pm_date,
                       JULIANDAY('now') - JULIANDAY(MAX(pc.completion_date)) as days_since_last_pm
                FROM equipment e
                LEFT JOIN pm_completions pc ON e.bfm_equipment_no = pc.bfm_equipment_no
                WHERE e.status = 'Active' AND e.monthly_pm = TRUE
                GROUP BY e.bfm_equipment_no, e.description, e.location
                HAVING days_since_last_pm > 60 OR last_pm_date IS NULL
                ORDER BY days_since_last_pm DESC NULLS LAST
                LIMIT 15
            ''')

            neglected_equipment = cursor.fetchall()

            if neglected_equipment:
                report += "\n\nEQUIPMENT REQUIRING ATTENTION (>60 days since last PM):\n"
                report += "-" * 70 + "\n"
                report += f"{'BFM No':<15} {'Description':<25} {'Last PM':<12} {'Days Since':<12}\n"
                report += "-" * 70 + "\n"

                for equipment in neglected_equipment:
                    bfm_no, description, location, last_pm, days_since = equipment
                    desc_short = (description[:22] + '...') if description and len(description) > 22 else (description or 'N/A')
                    last_pm_str = last_pm if last_pm else 'Never'
                    days_str = f"{int(days_since)}" if days_since else 'N/A'
                    
                    report += f"{bfm_no:<15} {desc_short:<25} {last_pm_str:<12} {days_str:<12}\n"

            # Equipment performance by location
            cursor.execute('''
                SELECT COALESCE(e.location, 'Unknown') as location,
                       COUNT(pc.id) as total_pms,
                       COUNT(DISTINCT e.bfm_equipment_no) as equipment_count,
                       AVG(pc.labor_hours + pc.labor_minutes/60.0) as avg_hours,
                       ROUND(CAST(COUNT(pc.id) AS FLOAT) / COUNT(DISTINCT e.bfm_equipment_no), 2) as pms_per_equipment
                FROM equipment e
                LEFT JOIN pm_completions pc ON e.bfm_equipment_no = pc.bfm_equipment_no
                    AND pc.completion_date >= CURRENT_DATE - INTERVAL '365 days'
                WHERE e.status = 'Active'
                GROUP BY COALESCE(e.location, 'Unknown')
                HAVING equipment_count >= 3
                ORDER BY pms_per_equipment DESC
            ''')

            location_performance = cursor.fetchall()

            if location_performance:
                report += "\n\nPM PERFORMANCE BY LOCATION (Last 12 months):\n"
                report += "-" * 70 + "\n"
                report += f"{'Location':<20} {'Equipment':<10} {'Total PMs':<10} {'PMs/Equipment':<15} {'Avg Hours':<10}\n"
                report += "-" * 70 + "\n"

                for location_data in location_performance:
                    location, total_pms, equipment_count, avg_hours, pms_per_equipment = location_data
                    loc_short = (location[:17] + '...') if len(location) > 17 else location
                    avg_hours_str = f"{avg_hours:.1f}h" if avg_hours else "0.0h"
                    
                    report += f"{loc_short:<20} {equipment_count:<10} {total_pms:<10} {pms_per_equipment:<15} {avg_hours_str:<10}\n"

            equipment_text.insert('end', report)
            equipment_text.config(state='disabled')

            equipment_text.pack(side='left', fill='both', expand=True)
            scrollbar.pack(side='right', fill='y')

        except Exception as e:
            error_label = ttk.Label(parent_frame, text=f"Error generating equipment trends: {str(e)}")
            error_label.pack(pady=20)

    def generate_technician_trends_analysis(self, parent_frame):
        """Generate technician performance trends analysis"""
        try:
            cursor = self.conn.cursor()

            # Create text widget for technician trends
            tech_text = tk.Text(parent_frame, wrap='word', font=('Courier', 10))
            scrollbar = ttk.Scrollbar(parent_frame, orient='vertical', command=tech_text.yview)
            tech_text.configure(yscrollcommand=scrollbar.set)

            report = "TECHNICIAN PERFORMANCE TRENDS\n"
            report += f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            report += "=" * 80 + "\n\n"

            # Monthly performance trends for each technician
            cursor.execute('''
                SELECT technician_name,
                       TO_CHAR(completion_date::date, 'YYYY-MM') as month,
                       COUNT(*) as completions,
                       AVG(labor_hours + labor_minutes/60.0) as avg_hours
                FROM pm_completions
                WHERE completion_date::date >= CURRENT_DATE - INTERVAL '12 months'
                GROUP BY technician_name, TO_CHAR(completion_date::date, 'YYYY-MM')
                ORDER BY technician_name, month
            ''')

            monthly_tech_data = cursor.fetchall()

            # Organize data by technician
            tech_monthly = {}
            for row in monthly_tech_data:
                tech, month, completions, avg_hours = row
                if tech not in tech_monthly:
                    tech_monthly[tech] = []
                tech_monthly[tech].append((month, completions, avg_hours))

            if tech_monthly:
                report += "MONTHLY PERFORMANCE TRENDS BY TECHNICIAN:\n"
                report += "=" * 80 + "\n"

                for technician, monthly_data in tech_monthly.items():
                    report += f"\n{technician}:\n"
                    report += "-" * 50 + "\n"
                    report += f"{'Month':<10} {'Completions':<12} {'Avg Hours':<10} {'Trend':<10}\n"
                    report += "-" * 50 + "\n"

                    # Calculate trend
                    completions_list = [data[1] for data in monthly_data]
                    if len(completions_list) >= 3:
                        recent_avg = sum(completions_list[-3:]) / 3
                        earlier_avg = sum(completions_list[:-3]) / len(completions_list[:-3]) if len(completions_list) > 3 else sum(completions_list[:3]) / len(completions_list[:3])
                        trend = "CHECK:" if recent_avg > earlier_avg else "CHECK:" if recent_avg < earlier_avg else "CHECK:"
                    else:
                        trend = "CHECK:"

                    for month, completions, avg_hours in monthly_data[-6:]:  # Show last 6 months
                        avg_hours_str = f"{avg_hours:.1f}h" if avg_hours else "0.0h"
                        report += f"{month:<10} {completions:<12} {avg_hours_str:<10} {trend if month == monthly_data[-1][0] else '':<10}\n"

            # Overall technician comparison
            cursor.execute('''
                SELECT technician_name,
                       COUNT(*) as total_completions,
                       AVG(labor_hours + labor_minutes/60.0) as avg_hours_per_pm,
                       COUNT(DISTINCT bfm_equipment_no) as unique_equipment,
                       COUNT(CASE WHEN completion_date >= CURRENT_DATE - INTERVAL '30 days' THEN 1 END) as recent_completions,
                       MIN(completion_date) as first_completion,
                       MAX(completion_date) as last_completion
                FROM pm_completions
                WHERE completion_date >= CURRENT_DATE - INTERVAL '12 months'
                GROUP BY technician_name
                ORDER BY total_completions DESC
            ''')

            tech_comparison = cursor.fetchall()

            if tech_comparison:
                report += "\n\nTECHNICIAN PERFORMANCE COMPARISON (Last 12 months):\n"
                report += "=" * 90 + "\n"
                report += f"{'Technician':<20} {'Total PMs':<10} {'Avg Hrs':<10} {'Equipment':<10} {'Recent 30d':<12} {'Active Period':<15}\n"
                report += "=" * 90 + "\n"

                for tech_data in tech_comparison:
                    tech, total, avg_hours, equipment, recent, first, last = tech_data
                    avg_hours_str = f"{avg_hours:.1f}h" if avg_hours else "0.0h"
                    
                    # Calculate active period
                    if first and last:
                        first_date = datetime.strptime(first, '%Y-%m-%d')
                        last_date = datetime.strptime(last, '%Y-%m-%d')
                        active_days = (last_date - first_date).days
                        active_period = f"{active_days}d"
                    else:
                        active_period = "N/A"

                    tech_short = tech[:17] + '...' if len(tech) > 17 else tech
                    report += f"{tech_short:<20} {total:<10} {avg_hours_str:<10} {equipment:<10} {recent:<12} {active_period:<15}\n"

            # Efficiency metrics
            if tech_comparison:
                report += "\n\nEFFICIENCY METRICS:\n"
                report += "-" * 60 + "\n"
                report += f"{'Technician':<20} {'PMs/Day':<10} {'Productivity':<12} {'Specialization':<15}\n"
                report += "-" * 60 + "\n"

                for tech_data in tech_comparison:
                    tech, total, avg_hours, equipment, recent, first, last = tech_data
                
                    # Calculate PMs per day (approximate)
                    if first and last:
                        first_date = datetime.strptime(first, '%Y-%m-%d')
                        last_date = datetime.strptime(last, '%Y-%m-%d')
                        active_days = max(1, (last_date - first_date).days)
                        pms_per_day = total / active_days
                    else:
                        pms_per_day = 0

                    # Productivity score (PMs per hour)
                    productivity = total / (total * (avg_hours if avg_hours else 1)) if avg_hours else total
                
                    # Specialization (unique equipment ratio)
                    specialization = equipment / total if total > 0 else 0
                    spec_rating = "High" if specialization > 0.8 else "Medium" if specialization > 0.5 else "Low"

                    tech_short = tech[:17] + '...' if len(tech) > 17 else tech
                    report += f"{tech_short:<20} {pms_per_day:<9.2f} {productivity:<11.2f} {spec_rating:<15}\n"

            tech_text.insert('end', report)
            tech_text.config(state='disabled')

            tech_text.pack(side='left', fill='both', expand=True)
            scrollbar.pack(side='right', fill='y')

        except Exception as e:
            error_label = ttk.Label(parent_frame, text=f"Error generating technician trends: {str(e)}")
            error_label.pack(pady=20)

    def generate_pm_type_trends_analysis(self, parent_frame):
        """Generate PM type distribution and trends analysis"""
        try:
            cursor = self.conn.cursor()

            # Create text widget for PM type trends
            pm_type_text = tk.Text(parent_frame, wrap='word', font=('Courier', 10))
            scrollbar = ttk.Scrollbar(parent_frame, orient='vertical', command=pm_type_text.yview)
            pm_type_text.configure(yscrollcommand=scrollbar.set)

            report = "PM TYPE TRENDS ANALYSIS\n"
            report += f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            report += "=" * 80 + "\n\n"

            # Monthly PM type distribution
            cursor.execute('''
                SELECT TO_CHAR(completion_date::date, 'YYYY-MM') as month,
                       pm_type,
                       COUNT(*) as completions,
                       AVG(labor_hours + labor_minutes/60.0) as avg_hours
                FROM pm_completions
                WHERE completion_date::date >= CURRENT_DATE - INTERVAL '12 months'
                GROUP BY TO_CHAR(completion_date::date, 'YYYY-MM'), pm_type
                ORDER BY month, pm_type
            ''')

            monthly_pm_type_data = cursor.fetchall()

            # Organize by month
            monthly_pm_types = {}
            for row in monthly_pm_type_data:
                month, pm_type, completions, avg_hours = row
                if month not in monthly_pm_types:
                    monthly_pm_types[month] = {}
                monthly_pm_types[month][pm_type] = (completions, avg_hours)

            if monthly_pm_types:
                report += "MONTHLY PM TYPE DISTRIBUTION:\n"
                report += "=" * 80 + "\n"
                report += f"{'Month':<10} {'Monthly':<10} {'Annual':<10} {'Six Month':<12} {'Other':<8} {'Total':<8}\n"
                report += "=" * 80 + "\n"

                pm_type_totals = {}
                for month, pm_types in monthly_pm_types.items():
                    monthly_count = pm_types.get('Monthly', (0, 0))[0]
                    annual_count = pm_types.get('Annual', (0, 0))[0]
                    six_month_count = pm_types.get('Six Month', (0, 0))[0]
                    other_count = sum(data[0] for pm_type, data in pm_types.items() 
                                    if pm_type not in ['Monthly', 'Annual', 'Six Month'])
                    total_count = monthly_count + annual_count + six_month_count + other_count

                    # Track totals
                    for pm_type, (count, _) in pm_types.items():
                        pm_type_totals[pm_type] = pm_type_totals.get(pm_type, 0) + count

                    report += f"{month:<10} {monthly_count:<10} {annual_count:<10} {six_month_count:<12} {other_count:<8} {total_count:<8}\n"

            # Overall PM type statistics
            cursor.execute('''
                SELECT pm_type,
                    COUNT(*) as total_completions,
                    AVG(labor_hours + labor_minutes/60.0) as avg_hours,
                       MIN(completion_date) as first_completion,
                       MAX(completion_date) as last_completion,
                       COUNT(DISTINCT technician_name) as technicians_involved,
                       COUNT(DISTINCT bfm_equipment_no) as equipment_serviced
                FROM pm_completions
                WHERE completion_date >= CURRENT_DATE - INTERVAL '12 months'
                GROUP BY pm_type
                ORDER BY total_completions DESC
            ''')

            pm_type_stats = cursor.fetchall()

            if pm_type_stats:
                report += "\n\nPM TYPE PERFORMANCE SUMMARY (Last 12 months):\n"
                report += "=" * 90 + "\n"
                report += f"{'PM Type':<15} {'Total':<8} {'Avg Hours':<10} {'Technicians':<12} {'Equipment':<10} {'Period':<15}\n"
                report += "=" * 90 + "\n"

                total_all_pms = sum(row[1] for row in pm_type_stats)
            
                for pm_data in pm_type_stats:
                    pm_type, total, avg_hours, first, last, techs, equipment = pm_data
                    percentage = (total / total_all_pms * 100) if total_all_pms > 0 else 0
                    avg_hours_str = f"{avg_hours:.1f}h" if avg_hours else "0.0h"
                
                    # Calculate period
                    if first and last:
                        first_date = datetime.strptime(first, '%Y-%m-%d')
                        last_date = datetime.strptime(last, '%Y-%m-%d')
                        period_days = (last_date - first_date).days
                        period_str = f"{period_days}d"
                    else:
                        period_str = "N/A"

                    report += f"{pm_type:<15} {total:<8} {avg_hours_str:<10} {techs:<12} {equipment:<10} {period_str:<15}\n"
                    report += f"{'':>15} ({percentage:.1f}%)\n"

            # PM type efficiency analysis
            if pm_type_stats:
                report += "\n\nPM TYPE EFFICIENCY ANALYSIS:\n"
                report += "-" * 60 + "\n"
            
                # Calculate efficiency metrics
                for pm_data in pm_type_stats:
                    pm_type, total, avg_hours, first, last, techs, equipment = pm_data
                
                    # Equipment coverage (how many unique equipment per PM)
                    coverage = equipment / total if total > 0 else 0
                
                    # Time efficiency rating
                    if avg_hours:
                        if avg_hours <= 1.0:
                            efficiency = "Excellent"
                        elif avg_hours <= 1.5:
                            efficiency = "Good"
                        elif avg_hours <= 2.5:
                            efficiency = "Average"
                        else:
                            efficiency = "Needs Review"
                    else:
                        efficiency = "Unknown"
                
                    report += f"{pm_type} PM Analysis:\n"
                    report += f"  - Average completion time: {avg_hours:.1f}h ({efficiency})\n" if avg_hours else f"  - Average completion time: Unknown\n"
                    report += f"  - Equipment coverage ratio: {coverage:.2f}\n"
                    report += f"  - Technician utilization: {techs} different technicians\n"
                
                    # Frequency analysis
                    if first and last and total > 1:
                        first_date = datetime.strptime(first, '%Y-%m-%d')
                        last_date = datetime.strptime(last, '%Y-%m-%d')
                        total_days = (last_date - first_date).days
                        avg_days_between = total_days / (total - 1) if total > 1 else 0
                        report += f"  - Average interval: {avg_days_between:.1f} days between completions\n"
                
                    report += "\n"

            # Seasonal PM type patterns
            cursor.execute('''
                SELECT
                    CASE
                        WHEN EXTRACT(MONTH FROM completion_date::date) IN (12, 1, 2) THEN 'Winter'
                        WHEN EXTRACT(MONTH FROM completion_date::date) IN (3, 4, 5) THEN 'Spring'
                        WHEN EXTRACT(MONTH FROM completion_date::date) IN (6, 7, 8) THEN 'Summer'
                        WHEN EXTRACT(MONTH FROM completion_date::date) IN (9, 10, 11) THEN 'Fall'
                    END as season,
                    pm_type,
                    COUNT(*) as completions
                FROM pm_completions
                WHERE completion_date::date >= CURRENT_DATE - INTERVAL '12 months'
                GROUP BY season, pm_type
                ORDER BY season, pm_type
            ''')

            seasonal_data = cursor.fetchall()

            if seasonal_data:
                report += "SEASONAL PM TYPE PATTERNS:\n"
                report += "-" * 50 + "\n"
            
                # Organize by season
                seasons = {}
                for row in seasonal_data:
                    season, pm_type, completions = row
                    if season not in seasons:
                        seasons[season] = {}
                    seasons[season][pm_type] = completions

                for season in ['Winter', 'Spring', 'Summer', 'Fall']:
                    if season in seasons:
                        report += f"\n{season}:\n"
                        season_total = sum(seasons[season].values())
                        for pm_type, count in seasons[season].items():
                            percentage = (count / season_total * 100) if season_total > 0 else 0
                            report += f"  {pm_type}: {count} ({percentage:.1f}%)\n"

            # Recommendations based on PM type analysis
            report += "\n\nPM TYPE RECOMMENDATIONS:\n"
            report += "=" * 50 + "\n"
        
            if pm_type_stats:
                # Find the most and least efficient PM types
                sorted_by_hours = sorted(pm_type_stats, key=lambda x: x[2] if x[2] else 0)
                most_efficient = sorted_by_hours[0] if sorted_by_hours else None
                least_efficient = sorted_by_hours[-1] if sorted_by_hours else None
                
                if most_efficient and least_efficient and most_efficient[2] and least_efficient[2]:
                    if most_efficient[0] != least_efficient[0]:
                        report += f"- Most efficient PM type: {most_efficient[0]} ({most_efficient[2]:.1f}h avg)\n"
                        report += f"- Least efficient PM type: {least_efficient[0]} ({least_efficient[2]:.1f}h avg)\n"
                        report += f"- Consider reviewing procedures for {least_efficient[0]} PMs\n\n"
            
                # Check for imbalanced distribution
                monthly_pms = next((row[1] for row in pm_type_stats if row[0] == 'Monthly'), 0)
                annual_pms = next((row[1] for row in pm_type_stats if row[0] == 'Annual'), 0)
            
                if monthly_pms > 0 and annual_pms > 0:
                    ratio = monthly_pms / annual_pms
                    if ratio > 15:
                        report += "- High Monthly-to-Annual PM ratio detected\n"
                        report += "- Consider whether some Monthly PMs could be converted to Annual\n\n"
                    elif ratio < 3:
                        report += "- Low Monthly-to-Annual PM ratio detected\n"
                        report += "- Verify Monthly PM scheduling is adequate\n\n"
            
                # Check for types with long completion times
                long_pm_types = [row for row in pm_type_stats if row[2] and row[2] > 3.0]
                if long_pm_types:
                    report += "- PM types with long completion times (>3h):\n"
                    for pm_type, total, avg_hours, _, _, _, _ in long_pm_types:
                        report += f"  - {pm_type}: {avg_hours:.1f}h average\n"
                    report += "- Review these procedures for potential optimization\n\n"

            pm_type_text.insert('end', report)
            pm_type_text.config(state='disabled')

            pm_type_text.pack(side='left', fill='both', expand=True)
            scrollbar.pack(side='right', fill='y')

        except Exception as e:
            error_label = ttk.Label(parent_frame, text=f"Error generating PM type trends: {str(e)}")
            error_label.pack(pady=20)

    def get_season_from_month(self, month_num):
        """Helper function to get season from month number"""
        if month_num in [12, 1, 2]:
            return "Winter"
        elif month_num in [3, 4, 5]:
            return "Spring"
        elif month_num in [6, 7, 8]:
            return "Summer"
        else:
            return "Fall"

    def export_trends_analysis_pdf(self, parent_dialog):
        """Export trends analysis to PDF"""
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"PM_Trends_Analysis_{timestamp}.pdf"

            # Create PDF document
            doc = SimpleDocTemplate(filename, pagesize=letter,
                                rightMargin=36, leftMargin=36,
                                topMargin=36, bottomMargin=36)
        
            story = []
            styles = getSampleStyleSheet()

            # Title page
            title_style = ParagraphStyle('TitleStyle', parent=styles['Title'], 
                                    fontSize=20, textColor=colors.darkblue, alignment=1)
            story.append(Paragraph("AIT CMMS PM TRENDS ANALYSIS REPORT", title_style))
            story.append(Spacer(1, 30))

            # Report metadata
            story.append(Paragraph(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", styles['Normal']))
            story.append(Paragraph(f"Report ID: {timestamp}", styles['Normal']))
            story.append(Spacer(1, 20))

            # Executive Summary
            cursor = self.conn.cursor()
        
            # Get summary statistics
            cursor.execute("SELECT COUNT(*) FROM pm_completions WHERE completion_date >= CURRENT_DATE - INTERVAL '12 months'")
            total_pms_year = cursor.fetchone()[0]
        
            cursor.execute("SELECT COUNT(*) FROM pm_completions WHERE completion_date >= CURRENT_DATE - INTERVAL '30 days'")
            total_pms_month = cursor.fetchone()[0]
        
            cursor.execute("SELECT AVG(labor_hours + labor_minutes/60.0) FROM pm_completions WHERE completion_date >= CURRENT_DATE - INTERVAL '12 months'")
            avg_hours = cursor.fetchone()[0] or 0

            story.append(Paragraph("EXECUTIVE SUMMARY", styles['Heading1']))
            summary_text = f"""
            This comprehensive PM trends analysis covers the last 12 months of preventive maintenance activities.
        
            Key Metrics:
            - Total PM Completions (12 months): {total_pms_year}
            - Recent PM Completions (30 days): {total_pms_month}
            - Average PM Duration: {avg_hours:.1f} hours
            - Analysis Period: {(datetime.now() - timedelta(days=365)).strftime('%Y-%m-%d')} to {datetime.now().strftime('%Y-%m-%d')}
        
            This report provides insights into monthly completion trends, equipment performance patterns,
            technician productivity analysis, and PM type distribution to support data-driven maintenance decisions.
            """
        
            story.append(Paragraph(summary_text, styles['Normal']))
            story.append(PageBreak())

            # Add key findings sections
            story.append(Paragraph("DETAILED ANALYSIS", styles['Heading1']))
            story.append(Paragraph("The following sections provide comprehensive trends analysis across multiple dimensions of PM performance.", styles['Normal']))
            story.append(Spacer(1, 20))

            # Note about data sources
            story.append(Paragraph("Data Sources and Methodology", styles['Heading2']))
            methodology_text = """
            This analysis is based on PM completion records from the AIT CMMS database. 
            All calculations use standardized date formats and validated completion records.
            Trends are calculated using statistical methods appropriate for time series data.
            """
            story.append(Paragraph(methodology_text, styles['Normal']))

            # Build PDF
            doc.build(story)

            messagebox.showinfo("Success", f"PM trends analysis exported to: {filename}")
            self.update_status(f"PM trends analysis exported to {filename}")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to export trends analysis: {str(e)}")

    def refresh_trends_analysis(self, parent_dialog):
        """Refresh the trends analysis with current data"""
        try:
            # Destroy and recreate the dialog
            parent_dialog.destroy()
            self.show_pm_trends()
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to refresh trends analysis: {str(e)}")
    
    
    
    
    
    
    
    
    def export_analytics(self):
        """Export analytics to file"""
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"AIT_CMMS_Analytics_{timestamp}.txt"
            
            content = self.analytics_text.get('1.0', 'end-1c')
            
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(content)
            
            messagebox.showinfo("Success", f"Analytics exported to: {filename}")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export analytics: {str(e)}")
    
    # Replace your existing import_equipment_csv method with this enhanced version

    def import_equipment_csv(self):
        """Import equipment data from CSV file with PM dates"""
        file_path = filedialog.askopenfilename(
            title="Select Equipment CSV File",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
    
        if file_path:
            try:
                # Show column mapping dialog first
                self.show_csv_mapping_dialog(file_path)
            
            except Exception as e:
                messagebox.showerror("Error", f"Failed to import CSV file: {str(e)}")

    # Replace your show_csv_mapping_dialog method with this fixed version

    def show_csv_mapping_dialog(self, file_path):
        """Show dialog to map CSV columns to database fields"""
    
        try:
            # Read CSV to get column headers
            df = pd.read_csv(file_path, encoding='cp1252', nrows=5)  # Just read first 5 rows to see structure
            csv_columns = list(df.columns)
        
            dialog = tk.Toplevel(self.root)
            dialog.title("Map CSV Columns to Database Fields")
            dialog.geometry("700x600")  # Made it larger
            dialog.transient(self.root)
            dialog.grab_set()
        
            # Main container with scrollbar
            main_canvas = tk.Canvas(dialog)
            scrollbar = ttk.Scrollbar(dialog, orient="vertical", command=main_canvas.yview)
            scrollable_frame = ttk.Frame(main_canvas)
        
            scrollable_frame.bind(
                "<Configure>",
                lambda e: main_canvas.configure(scrollregion=main_canvas.bbox("all"))
            )
        
            main_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            main_canvas.configure(yscrollcommand=scrollbar.set)
        
            # Instructions
            ttk.Label(scrollable_frame, text="Map your CSV columns to the correct database fields:", 
                    font=('Arial', 12, 'bold')).pack(pady=10)
        
            # Create mapping frame
            mapping_frame = ttk.Frame(scrollable_frame)
            mapping_frame.pack(fill='both', expand=True, padx=20, pady=10)
        
            # Column mappings
            mappings = {}
        
            # Database fields that can be mapped
            db_fields = [
                ("SAP Material No", "sap_material_no"),
                ("BFM Equipment No", "bfm_equipment_no"), 
                ("Description", "description"),
                ("Tool ID/Drawing No", "tool_id_drawing_no"),
                ("Location", "location"),
                ("Master LIN", "master_lin"),
                ("Last Monthly PM (YYYY-MM-DD)", "last_monthly_pm"),
                ("Last Six Month PM (YYYY-MM-DD)", "last_six_month_pm"),
                ("Last Annual PM (YYYY-MM-DD)", "last_annual_pm"),
                ("Monthly PM Required (1/0 or Y/N)", "monthly_pm"),
                ("Six Month PM Required (1/0 or Y/N)", "six_month_pm"),
                ("Annual PM Required (1/0 or Y/N)", "annual_pm")
            ]
        
            # Add "None" option to CSV columns
            csv_options = ["(Not in CSV)"] + csv_columns
        
            row = 0
            for field_name, field_key in db_fields:
                ttk.Label(mapping_frame, text=field_name + ":").grid(row=row, column=0, sticky='w', pady=2)
            
                mapping_var = tk.StringVar()
                combo = ttk.Combobox(mapping_frame, textvariable=mapping_var, values=csv_options, width=30)
                combo.grid(row=row, column=1, padx=10, pady=2)
            
                # Try to auto-match common column names
                for csv_col in csv_columns:
                    csv_lower = csv_col.lower()
                    if field_key == 'sap_material_no' and 'sap' in csv_lower:
                        mapping_var.set(csv_col)
                        break
                    elif field_key == 'bfm_equipment_no' and 'bfm' in csv_lower:
                        mapping_var.set(csv_col)
                        break
                    elif field_key == 'description' and 'description' in csv_lower:
                        mapping_var.set(csv_col)
                        break
                    elif field_key == 'location' and 'location' in csv_lower:
                        mapping_var.set(csv_col)
                        break
                    elif field_key == 'master_lin' and 'lin' in csv_lower:
                        mapping_var.set(csv_col)
                        break
            
                mappings[field_key] = mapping_var
                row += 1
        
            # Show sample data
            sample_frame = ttk.LabelFrame(scrollable_frame, text="Sample Data from Your CSV", padding=10)
            sample_frame.pack(fill='x', padx=20, pady=10)
        
            sample_text = tk.Text(sample_frame, height=6, width=80)
            sample_text.pack()
            sample_text.insert('1.0', df.to_string())
            sample_text.config(state='disabled')
        
            def process_import():
                """Process the import with mapped columns"""
                try:
                    # Get the full CSV data
                    full_df = pd.read_csv(file_path, encoding='cp1252')
                    full_df.columns = full_df.columns.str.strip()
                
                    cursor = self.conn.cursor()
                    imported_count = 0
                    error_count = 0
                
                    for index, row in full_df.iterrows():
                        try:
                            # Extract mapped data
                            data = {}
                            for field_key, mapping_var in mappings.items():
                                csv_column = mapping_var.get()
                                if csv_column != "(Not in CSV)" and csv_column in full_df.columns:
                                    value = row[csv_column]
                                    if pd.isna(value):
                                        data[field_key] = None
                                    else:
                                        # Handle different data types
                                        if field_key in ['monthly_pm', 'six_month_pm', 'annual_pm']:
                                            # Convert Y/N or 1/0 to boolean
                                            if str(value).upper() in ['Y', 'YES', '1', 'TRUE']:
                                                data[field_key] = 1
                                            else:
                                                data[field_key] = 0
                                        elif field_key in ['last_monthly_pm', 'last_six_month_pm', 'last_annual_pm']:
                                            # Handle date fields
                                            try:
                                                # Try to parse date
                                                parsed_date = pd.to_datetime(value).strftime('%Y-%m-%d')
                                                data[field_key] = parsed_date
                                            except:
                                                data[field_key] = None
                                        else:
                                            data[field_key] = str(value)
                                else:
                                    # Set defaults for unmapped fields
                                    if field_key in ['monthly_pm', 'six_month_pm', 'annual_pm']:
                                        data[field_key] = 1  # Default to requiring all PM types
                                    else:
                                        data[field_key] = None
                        
                            # Only import if BFM number exists
                            if data.get('bfm_equipment_no'):
                                cursor.execute('''
                                    INSERT INTO equipment 
                                    (sap_material_no, bfm_equipment_no, description, tool_id_drawing_no, location, 
                                    master_lin, monthly_pm, six_month_pm, annual_pm, last_monthly_pm, 
                                    last_six_month_pm, last_annual_pm, next_monthly_pm, next_six_month_pm, next_annual_pm)
                                    VALUES (%s, %s, %s , %s , %s, %s, %s, %s, %s, %s, %s, %s,
                                        CASE WHEN %s IS NOT NULL THEN %s::date + INTERVAL '30 days' ELSE NULL END,
                                        CASE WHEN %s IS NOT NULL THEN %s::date + INTERVAL '180 days' ELSE NULL END,
                                        CASE WHEN %s IS NOT NULL THEN %s::date + INTERVAL '365 days' ELSE NULL END)
                                    ON CONFLICT (bfm_equipment_no) DO UPDATE SET
                                        sap_material_no = EXCLUDED.sap_material_no,
                                        description = EXCLUDED.description,
                                        tool_id_drawing_no = EXCLUDED.tool_id_drawing_no,
                                        location = EXCLUDED.location,
                                        master_lin = EXCLUDED.master_lin,
                                        monthly_pm = EXCLUDED.monthly_pm,
                                        six_month_pm = EXCLUDED.six_month_pm,
                                        annual_pm = EXCLUDED.annual_pm,
                                        last_monthly_pm = EXCLUDED.last_monthly_pm,
                                        last_six_month_pm = EXCLUDED.last_six_month_pm,
                                        last_annual_pm = EXCLUDED.last_annual_pm,
                                        next_monthly_pm = EXCLUDED.next_monthly_pm,
                                        next_six_month_pm = EXCLUDED.next_six_month_pm,
                                        next_annual_pm = EXCLUDED.next_annual_pm
                                ''', (
                                    data.get('sap_material_no'),
                                    data.get('bfm_equipment_no'),
                                    data.get('description'),
                                    data.get('tool_id_drawing_no'),
                                    data.get('location'),
                                    data.get('master_lin'),
                                    data.get('monthly_pm', 1),
                                    data.get('six_month_pm', 1),
                                    data.get('annual_pm', 1),
                                    data.get('last_monthly_pm'),
                                    data.get('last_six_month_pm'),
                                    data.get('last_annual_pm'),
                                    data.get('last_monthly_pm'),
                                    data.get('last_monthly_pm'),
                                    data.get('last_six_month_pm'),
                                    data.get('last_six_month_pm'),
                                    data.get('last_annual_pm'),
                                    data.get('last_annual_pm')
                                ))
                                imported_count += 1
                            else:
                                error_count += 1
                            
                        except Exception as e:
                            print(f"Error importing row {index}: {e}")
                            error_count += 1
                            continue
                
                    self.conn.commit()
                    dialog.destroy()
                
                    # Show results
                    result_msg = f"Import completed!\n\n"
                    result_msg += f"CHECK: Successfully imported: {imported_count} records\n"
                    if error_count > 0:
                        result_msg += f"WARNING: Skipped (errors): {error_count} records\n"
                    result_msg += f"\nTotal processed: {imported_count + error_count} records"
                
                    messagebox.showinfo("Import Results", result_msg)
                    self.refresh_equipment_list()
                    self.update_status(f"Imported {imported_count} equipment records")
                
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to process import: {str(e)}")
        
            def cancel_import():
                    """Cancel the import process"""
                    dialog.destroy()
        
            # WARNING: BUTTONS FRAME - This was missing!
            button_frame = ttk.Frame(scrollable_frame)
            button_frame.pack(side='bottom', fill='x', padx=20, pady=20)
        
            # Import button (green)
            import_button = ttk.Button(button_frame, text="Import with These Mappings", 
                                    command=process_import)
            import_button.pack(side='left', padx=10)
        
            # Cancel button
            cancel_button = ttk.Button(button_frame, text="Cancel", 
                                    command=cancel_import)
            cancel_button.pack(side='right', padx=10)
        
            # Pack the canvas and scrollbar
            main_canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
        
            # Make the dialog modal
            dialog.focus_set()
            dialog.grab_set()
        
        except Exception as e:
            messagebox.showerror("Error", f"Failed to read CSV file: {str(e)}")
            return

    def delete_equipment_dialog(self):
        """Delete selected equipment from database"""
        selected = self.equipment_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select equipment to delete")
            return

        # Support multiple selection
        if len(selected) > 1:
            # Multiple assets selected
            count = len(selected)
            response = messagebox.askyesno(
                "Confirm Delete",
                f"Are you sure you want to delete {count} selected assets?\n\n"
                f"This will permanently remove them and all their associated records:\n"
                f" PM schedules\n"
                f" PM completions\n"
                f" Corrective maintenance records\n\n"
                f"This action CANNOT be undone!",
                icon='warning'
            )
            if not response:
                return

            # Get all BFM numbers
            bfm_numbers = []
            for item in selected:
                item_data = self.equipment_tree.item(item)
                bfm_no = str(item_data['values'][1]).strip()
                bfm_numbers.append(bfm_no)

            # Delete all selected
            try:
                with db_pool.get_cursor(commit=True) as cursor:
                    for bfm_no in bfm_numbers:
                        self._delete_single_equipment(cursor, bfm_no)

                messagebox.showinfo("Success", f"Successfully deleted {count} assets!")
                self.refresh_equipment_list()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to delete assets: {str(e)}")

        else:
            # Single asset selected
            item = self.equipment_tree.item(selected[0])
            bfm_no = str(item['values'][1]).strip()
            description = str(item['values'][2])

            # Confirm deletion
            response = messagebox.askyesno(
                "Confirm Delete",
                f"Are you sure you want to delete this asset?\n\n"
                f"BFM Equipment No: {bfm_no}\n"
                f"Description: {description}\n\n"
                f"This will permanently remove:\n"
                f" The equipment record\n"
                f" All PM schedules\n"
                f" All PM completions\n"
                f" All corrective maintenance records\n\n"
                f"This action CANNOT be undone!",
                icon='warning'
            )

            if not response:
                return

            # Delete the asset
            try:
                with db_pool.get_cursor(commit=True) as cursor:
                    self._delete_single_equipment(cursor, bfm_no)

                messagebox.showinfo("Success", f"Equipment {bfm_no} deleted successfully!")
                self.refresh_equipment_list()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to delete equipment: {str(e)}")

    def _delete_single_equipment(self, cursor, bfm_no):
        """Helper function to delete a single equipment and all related records"""
        # Delete from all related tables first (foreign key constraints)
        # Use TRIM() to match BFM numbers even if they have whitespace/newlines

        # Delete PM schedules
        cursor.execute('DELETE FROM weekly_pm_schedules WHERE TRIM(bfm_equipment_no) = %s', (bfm_no,))

        # Delete PM completions
        cursor.execute('DELETE FROM pm_completions WHERE TRIM(bfm_equipment_no) = %s', (bfm_no,))

        # Delete from corrective maintenance
        cursor.execute('DELETE FROM corrective_maintenance WHERE TRIM(bfm_equipment_no) = %s', (bfm_no,))

        # Delete from special status tables
        cursor.execute('DELETE FROM cannot_find_assets WHERE TRIM(bfm_equipment_no) = %s', (bfm_no,))
        cursor.execute('DELETE FROM run_to_failure_assets WHERE TRIM(bfm_equipment_no) = %s', (bfm_no,))
        cursor.execute('DELETE FROM deactivated_assets WHERE TRIM(bfm_equipment_no) = %s', (bfm_no,))

        # Finally delete from equipment table
        cursor.execute('DELETE FROM equipment WHERE TRIM(bfm_equipment_no) = %s', (bfm_no,))

        # Log the deletion
        print(f"Deleted equipment with BFM: {bfm_no}")


    def add_equipment_dialog(self):
        """Dialog to add new equipment with photo upload and custom PM start date"""
        dialog = tk.Toplevel(self.root)
        dialog.title("Add New Equipment")
        dialog.geometry("600x750")
        dialog.transient(self.root)
        dialog.grab_set()

        # Create scrollable frame
        canvas = tk.Canvas(dialog)
        scrollbar = ttk.Scrollbar(dialog, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        # Form fields
        fields = [
            ("SAP Material No:", tk.StringVar()),
            ("BFM Equipment No:", tk.StringVar()),
            ("Description:", tk.StringVar()),
            ("Tool ID/Drawing No:", tk.StringVar()),
            ("Location:", tk.StringVar()),
            ("Master LIN:", tk.StringVar())
        ]

        entries = {}

        for i, (label, var) in enumerate(fields):
            ttk.Label(scrollable_frame, text=label).grid(row=i, column=0, sticky='w', padx=10, pady=5)
            entry = ttk.Entry(scrollable_frame, textvariable=var, width=30)
            entry.grid(row=i, column=1, padx=10, pady=5)
            entries[label] = var

        # Add note for BFM number (optional for deactivated assets)
        bfm_note_label = ttk.Label(scrollable_frame,
                                    text="(Optional for deactivated assets - auto-generated if blank)",
                                    font=('Arial', 8), foreground='gray')
        bfm_note_label.grid(row=1, column=2, sticky='w', padx=5, pady=5)

        # PM type checkboxes
        pm_frame = ttk.LabelFrame(scrollable_frame, text="PM Types", padding=10)
        pm_frame.grid(row=len(fields), column=0, columnspan=2, padx=10, pady=10, sticky='ew')

        weekly_var = tk.BooleanVar(value=False)
        monthly_var = tk.BooleanVar(value=True)
        six_month_var = tk.BooleanVar(value=True)
        annual_var = tk.BooleanVar(value=True)

        weekly_cb = ttk.Checkbutton(pm_frame, text="Weekly PM", variable=weekly_var)
        weekly_cb.pack(anchor='w')
        monthly_cb = ttk.Checkbutton(pm_frame, text="Monthly PM", variable=monthly_var)
        monthly_cb.pack(anchor='w')
        six_month_cb = ttk.Checkbutton(pm_frame, text="Six Month PM", variable=six_month_var)
        six_month_cb.pack(anchor='w')
        annual_cb = ttk.Checkbutton(pm_frame, text="Annual PM", variable=annual_var)
        annual_cb.pack(anchor='w')

        # Deactivated option
        deactivated_var = tk.BooleanVar(value=False)
        deact_cb = ttk.Checkbutton(pm_frame, text="Mark as Deactivated",
                            variable=deactivated_var,
                            command=lambda: toggle_deactivated())
        deact_cb.pack(anchor='w', pady=5)

        # Deactivated warning label
        deact_warning_label = ttk.Label(pm_frame, text="Status: Will be set to Deactivated (PMs disabled)",
                                    foreground='red', font=('Arial', 9, 'italic'))

        # Deactivated fields frame (appears when Deactivated is checked)
        deact_frame = ttk.Frame(pm_frame)
        ttk.Label(deact_frame, text="Deactivated By:").grid(row=0, column=0, sticky='w', padx=(0, 5))
        deact_tech_var = tk.StringVar()
        deact_tech_combo = ttk.Combobox(deact_frame, textvariable=deact_tech_var, width=20)
        deact_tech_combo['values'] = self.technicians if hasattr(self, 'technicians') else []
        deact_tech_combo.grid(row=0, column=1, sticky='w')

        ttk.Label(deact_frame, text="Reason:").grid(row=1, column=0, sticky='w', padx=(0, 5), pady=5)
        deact_reason_var = tk.StringVar()
        deact_reason_entry = ttk.Entry(deact_frame, textvariable=deact_reason_var, width=40)
        deact_reason_entry.grid(row=1, column=1, sticky='w', pady=5)

        def toggle_deactivated():
            """Enable/disable options based on deactivation status"""
            if deactivated_var.get():
                # Disable PM options when deactivated
                weekly_cb.config(state='disabled')
                monthly_cb.config(state='disabled')
                six_month_cb.config(state='disabled')
                annual_cb.config(state='disabled')
                weekly_var.set(False)
                monthly_var.set(False)
                six_month_var.set(False)
                annual_var.set(False)
                deact_warning_label.pack(anchor='w', padx=20)
                deact_frame.pack(anchor='w', pady=5, padx=20)
            else:
                # Re-enable PM options when not deactivated
                weekly_cb.config(state='normal')
                monthly_cb.config(state='normal')
                six_month_cb.config(state='normal')
                annual_cb.config(state='normal')
                monthly_var.set(True)
                six_month_var.set(True)
                annual_var.set(True)
                deact_warning_label.pack_forget()
                deact_frame.pack_forget()

        # First PM Date section
        date_frame = ttk.LabelFrame(scrollable_frame, text="Maintenance Start Date", padding=10)
        date_frame.grid(row=len(fields)+1, column=0, columnspan=2, padx=10, pady=10, sticky='ew')

        ttk.Label(date_frame, text="First PM Date:", font=('Arial', 9, 'bold')).grid(row=0, column=0, sticky='w', padx=5, pady=5)
        first_pm_date_var = tk.StringVar()
        date_entry = ttk.Entry(date_frame, textvariable=first_pm_date_var, width=20)
        date_entry.grid(row=0, column=1, sticky='w', padx=5, pady=5)

        ttk.Label(date_frame, text="Format: YYYY-MM-DD (e.g., 2026-05-01)",
                 font=('Arial', 8), foreground='gray').grid(row=1, column=0, columnspan=2, sticky='w', padx=5)
        ttk.Label(date_frame, text="Leave blank to start scheduling immediately",
                 font=('Arial', 8), foreground='gray').grid(row=2, column=0, columnspan=2, sticky='w', padx=5)

        # Photo upload section
        photo_frame = ttk.LabelFrame(scrollable_frame, text="Equipment Photos", padding=10)
        photo_frame.grid(row=len(fields)+2, column=0, columnspan=2, padx=10, pady=10, sticky='ew')

        picture_1_var = tk.StringVar()
        picture_2_var = tk.StringVar()

        def browse_image(var):
            """Browse for image file"""
            file_path = filedialog.askopenfilename(
                title="Select Image",
                filetypes=[("Image files", "*.png *.jpg *.jpeg *.gif *.bmp"), ("All files", "*.*")]
            )
            if file_path:
                var.set(file_path)

        ttk.Label(photo_frame, text="Picture 1:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        pic1_frame = ttk.Frame(photo_frame)
        pic1_frame.grid(row=0, column=1, sticky='w', padx=5, pady=5)
        ttk.Entry(pic1_frame, textvariable=picture_1_var, width=30).pack(side='left')
        ttk.Button(pic1_frame, text="Browse", command=lambda: browse_image(picture_1_var)).pack(side='left', padx=5)

        ttk.Label(photo_frame, text="Picture 2:").grid(row=1, column=0, sticky='w', padx=5, pady=5)
        pic2_frame = ttk.Frame(photo_frame)
        pic2_frame.grid(row=1, column=1, sticky='w', padx=5, pady=5)
        ttk.Entry(pic2_frame, textvariable=picture_2_var, width=30).pack(side='left')
        ttk.Button(pic2_frame, text="Browse", command=lambda: browse_image(picture_2_var)).pack(side='left', padx=5)

        def save_equipment():
            try:
                # Check if equipment is being marked as deactivated
                is_deactivated = deactivated_var.get()

                # Validate deactivation fields if marking as deactivated
                if is_deactivated:
                    deact_technician = deact_tech_var.get().strip()
                    if not deact_technician:
                        messagebox.showwarning("Missing Information", "Please select who is deactivating this asset")
                        return

                # Handle BFM number validation and auto-generation
                bfm_no = entries["BFM Equipment No:"].get().strip()

                # If no BFM number provided
                if not bfm_no:
                    if is_deactivated:
                        # Auto-generate BFM number for deactivated assets
                        timestamp = int(datetime.now().timestamp())
                        rand_suffix = random.randint(1000, 9999)
                        bfm_no = f"NO-BFM-{timestamp}-{rand_suffix}"

                        # Verify uniqueness (in case of collision)
                        cursor = self.conn.cursor()
                        cursor.execute('SELECT COUNT(*) FROM equipment WHERE bfm_equipment_no = %s', (bfm_no,))
                        result = cursor.fetchone()
                        if result and result[0] > 0:
                            # If collision, add another random suffix
                            bfm_no = f"NO-BFM-{timestamp}-{rand_suffix}-{random.randint(100, 999)}"
                        cursor.close()

                        # Update the entry field to show the generated number
                        entries["BFM Equipment No:"].set(bfm_no)
                    else:
                        # BFM number is required for non-deactivated assets
                        messagebox.showwarning("Missing Information", "BFM Equipment No. is required for active assets")
                        return
                else:
                    # Verify BFM number doesn't already exist
                    cursor = self.conn.cursor()
                    cursor.execute('SELECT COUNT(*) FROM equipment WHERE bfm_equipment_no = %s', (bfm_no,))
                    result = cursor.fetchone()
                    cursor.close()
                    if result and result[0] > 0:
                        messagebox.showerror("Duplicate BFM", f"BFM Equipment No '{bfm_no}' already exists. Please use a unique BFM number.")
                        return

                # Validate and parse First PM Date
                first_pm_date_str = first_pm_date_var.get().strip()
                next_weekly = None
                next_monthly = None
                next_six_month = None
                next_annual = None

                if first_pm_date_str:
                    # Parse date with flexible format handling
                    parsed_date = None
                    try:
                        # Try standard format first (YYYY-MM-DD)
                        parsed_date = datetime.strptime(first_pm_date_str, '%Y-%m-%d')
                    except ValueError:
                        # Try other common formats
                        formats = ['%m/%d/%Y', '%d/%m/%Y', '%Y/%m/%d', '%m-%d-%Y']
                        for fmt in formats:
                            try:
                                parsed_date = datetime.strptime(first_pm_date_str, fmt)
                                break
                            except ValueError:
                                continue

                    if not parsed_date:
                        messagebox.showerror("Error", "Invalid date format. Please use YYYY-MM-DD (e.g., 2026-05-01)")
                        return

                    # Calculate next PM dates based on first PM date and selected PM types
                    base_date_str = parsed_date.strftime('%Y-%m-%d')

                    if weekly_var.get():
                        next_weekly = (parsed_date + timedelta(days=7)).strftime('%Y-%m-%d')

                    if monthly_var.get():
                        next_monthly = (parsed_date + timedelta(days=30)).strftime('%Y-%m-%d')

                    if six_month_var.get():
                        next_six_month = (parsed_date + timedelta(days=180)).strftime('%Y-%m-%d')

                    if annual_var.get():
                        next_annual = (parsed_date + timedelta(days=365)).strftime('%Y-%m-%d')

                # Read image files as binary data
                pic1_path = picture_1_var.get()
                pic2_path = picture_2_var.get()

                pic1_data = None
                pic2_data = None

                if pic1_path and os.path.exists(pic1_path):
                    with open(pic1_path, 'rb') as f:
                        pic1_data = f.read()

                if pic2_path and os.path.exists(pic2_path):
                    with open(pic2_path, 'rb') as f:
                        pic2_data = f.read()

                # Set status based on deactivation
                equipment_status = 'Deactivated' if is_deactivated else 'Active'

                # Get equipment details for deactivated_assets table
                # Note: bfm_no already set above (validated or auto-generated)
                description = entries["Description:"].get().strip()
                location = entries["Location:"].get().strip()

                # Insert equipment with appropriate status
                cursor = self.conn.cursor()
                cursor.execute('''
                    INSERT INTO equipment
                    (sap_material_no, bfm_equipment_no, description, tool_id_drawing_no,
                     location, master_lin, weekly_pm, monthly_pm, six_month_pm, annual_pm,
                     next_weekly_pm, next_monthly_pm, next_six_month_pm, next_annual_pm,
                     picture_1_data, picture_2_data, status)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                ''', (
                    entries["SAP Material No:"].get().strip(),
                    bfm_no,
                    description,
                    entries["Tool ID/Drawing No:"].get().strip(),
                    location,
                    entries["Master LIN:"].get().strip(),
                    weekly_var.get(),
                    monthly_var.get(),
                    six_month_var.get(),
                    annual_var.get(),
                    next_weekly,
                    next_monthly,
                    next_six_month,
                    next_annual,
                    pic1_data,
                    pic2_data,
                    equipment_status
                ))

                # If marked as deactivated, add to deactivated_assets table
                if is_deactivated:
                    deact_technician = deact_tech_var.get().strip()
                    deact_reason = deact_reason_var.get().strip()
                    deactivated_date = datetime.now().strftime('%Y-%m-%d')

                    cursor.execute('''
                        INSERT INTO deactivated_assets
                        (bfm_equipment_no, description, location, deactivated_by,
                         deactivated_date, reason, status, notes)
                        VALUES (%s, %s, %s, %s, %s, %s, 'Deactivated', %s)
                    ''', (
                        bfm_no,
                        description,
                        location,
                        deact_technician,
                        deactivated_date,
                        deact_reason,
                        'Equipment marked as Deactivated when added via add equipment dialog'
                    ))

                # Commit the transaction
                self.conn.commit()
                cursor.close()

                # Show appropriate success message
                if is_deactivated:
                    success_msg = f"Equipment {bfm_no} added successfully!\n\n"
                    success_msg += "Status: Deactivated\n"
                    # Show if BFM was auto-generated
                    if bfm_no.startswith("NO-BFM-"):
                        success_msg += f"- BFM Number: {bfm_no} (auto-generated)\n"
                    success_msg += f"- Deactivated by: {deact_tech_var.get().strip()}\n"
                    if deact_reason_var.get().strip():
                        success_msg += f"- Reason: {deact_reason_var.get().strip()}\n"
                    success_msg += "- Equipment added to Deactivated list\n"
                    success_msg += "- Counted in total assets\n"
                    success_msg += "- All PM requirements disabled"
                    messagebox.showinfo("Success", success_msg)
                else:
                    messagebox.showinfo("Success", "Equipment added successfully!")

                dialog.destroy()
                self.refresh_equipment_list()

                # Refresh deactivated assets list if equipment was deactivated
                if is_deactivated and hasattr(self, 'load_deactivated_assets'):
                    self.load_deactivated_assets()

                # Update equipment statistics
                if hasattr(self, 'update_equipment_statistics'):
                    self.update_equipment_statistics()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to add equipment: {str(e)}")

        # Buttons
        button_frame = ttk.Frame(scrollable_frame)
        button_frame.grid(row=len(fields)+3, column=0, columnspan=2, pady=10)

        ttk.Button(button_frame, text="Save", command=save_equipment).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side='left', padx=5)

        # Pack canvas and scrollbar
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
    
    def edit_equipment_dialog(self):
        """Enhanced dialog to edit existing equipment with Run to Failure and Cannot Find options"""
        selected = self.equipment_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select equipment to edit")
            return

        # Get selected equipment data
        item = self.equipment_tree.item(selected[0])
        bfm_no = str(item['values'][1]).strip()  # BFM Equipment No. - strip whitespace!

        # Fetch full equipment data including photos
        try:
            with db_pool.get_cursor(commit=False) as cursor:
                cursor.execute('SELECT * FROM equipment WHERE bfm_equipment_no = %s', (bfm_no,))
                equipment_data = cursor.fetchone()

                if not equipment_data:
                    # Enhanced error message with diagnostic info
                    messagebox.showerror("Error",
                        f"Equipment not found in database\n\n"
                        f"Searched for BFM: '{bfm_no}'\n"
                        f"Length: {len(bfm_no)} characters\n\n"
                        f"This asset may have been deleted or the BFM number might have special characters.\n"
                        f"Please run diagnose_assets.py for detailed analysis.")
                    return
        except Exception as e:
            messagebox.showerror("Error", f"Database error: {str(e)}")
            return

        # Create edit dialog with scrollable frame
        dialog = tk.Toplevel(self.root)
        dialog.title("Edit Equipment")
        dialog.geometry("650x800")  # Made larger for photos and PM date section
        dialog.transient(self.root)
        dialog.grab_set()

        # Create scrollable frame
        canvas = tk.Canvas(dialog)
        scrollbar = ttk.Scrollbar(dialog, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        # Pre-populate fields
        fields = [
            ("SAP Material No:", tk.StringVar(value=equipment_data['sap_material_no'] or '')),
            ("BFM Equipment No:", tk.StringVar(value=equipment_data['bfm_equipment_no'] or '')),
            ("Description:", tk.StringVar(value=equipment_data['description'] or '')),
            ("Tool ID/Drawing No:", tk.StringVar(value=equipment_data['tool_id_drawing_no'] or '')),
            ("Location:", tk.StringVar(value=equipment_data['location'] or '')),
            ("Master LIN:", tk.StringVar(value=equipment_data['master_lin'] or ''))
        ]

        entries = {}

        for i, (label, var) in enumerate(fields):
            ttk.Label(scrollable_frame, text=label).grid(row=i, column=0, sticky='w', padx=10, pady=5)
            entry = ttk.Entry(scrollable_frame, textvariable=var, width=30)
            entry.grid(row=i, column=1, padx=10, pady=5)
            entries[label] = var

        current_row = len(fields)

        # Photo upload section
        photo_frame = ttk.LabelFrame(scrollable_frame, text="Equipment Photos", padding=10)
        photo_frame.grid(row=current_row, column=0, columnspan=2, padx=10, pady=10, sticky='ew')

        picture_1_var = tk.StringVar()
        picture_2_var = tk.StringVar()

        # Store existing photo data
        existing_pic1_data = equipment_data.get('picture_1_data')
        existing_pic2_data = equipment_data.get('picture_2_data')

        def browse_image(var):
            """Browse for image file"""
            file_path = filedialog.askopenfilename(
                title="Select Image",
                filetypes=[("Image files", "*.png *.jpg *.jpeg *.gif *.bmp"), ("All files", "*.*")]
            )
            if file_path:
                var.set(file_path)

        # Picture 1
        ttk.Label(photo_frame, text="Picture 1:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        pic1_frame = ttk.Frame(photo_frame)
        pic1_frame.grid(row=0, column=1, sticky='w', padx=5, pady=5)

        if existing_pic1_data:
            ttk.Label(pic1_frame, text="[Photo exists] ", foreground='green').pack(side='left')

        ttk.Entry(pic1_frame, textvariable=picture_1_var, width=25).pack(side='left')
        ttk.Button(pic1_frame, text="Browse", command=lambda: browse_image(picture_1_var)).pack(side='left', padx=5)

        # Picture 2
        ttk.Label(photo_frame, text="Picture 2:").grid(row=1, column=0, sticky='w', padx=5, pady=5)
        pic2_frame = ttk.Frame(photo_frame)
        pic2_frame.grid(row=1, column=1, sticky='w', padx=5, pady=5)

        if existing_pic2_data:
            ttk.Label(pic2_frame, text="[Photo exists] ", foreground='green').pack(side='left')

        ttk.Entry(pic2_frame, textvariable=picture_2_var, width=25).pack(side='left')
        ttk.Button(pic2_frame, text="Browse", command=lambda: browse_image(picture_2_var)).pack(side='left', padx=5)

        ttk.Label(photo_frame, text="Leave blank to keep existing photo",
                  font=('Arial', 8), foreground='gray').grid(row=2, column=0, columnspan=2, sticky='w', padx=5)

        current_row += 1

        # First PM Date section
        date_frame = ttk.LabelFrame(scrollable_frame, text="Maintenance Start Date", padding=10)
        date_frame.grid(row=current_row, column=0, columnspan=2, padx=10, pady=10, sticky='ew')

        ttk.Label(date_frame, text="First PM Date:", font=('Arial', 9, 'bold')).grid(row=0, column=0, sticky='w', padx=5, pady=5)
        first_pm_date_var = tk.StringVar()

        # Pre-populate with earliest next PM date if available
        current_next_dates = []
        if equipment_data.get('next_weekly_pm'):
            current_next_dates.append(equipment_data['next_weekly_pm'])
        if equipment_data.get('next_monthly_pm'):
            current_next_dates.append(equipment_data['next_monthly_pm'])
        if equipment_data.get('next_six_month_pm'):
            current_next_dates.append(equipment_data['next_six_month_pm'])
        if equipment_data.get('next_annual_pm'):
            current_next_dates.append(equipment_data['next_annual_pm'])

        # Set the earliest date as default if any exist
        if current_next_dates:
            earliest_date = min(current_next_dates)
            first_pm_date_var.set(earliest_date)

        date_entry = ttk.Entry(date_frame, textvariable=first_pm_date_var, width=20)
        date_entry.grid(row=0, column=1, sticky='w', padx=5, pady=5)

        ttk.Label(date_frame, text="Format: YYYY-MM-DD (e.g., 2026-05-01)",
                 font=('Arial', 8), foreground='gray').grid(row=1, column=0, columnspan=2, sticky='w', padx=5)
        ttk.Label(date_frame, text="This sets when PM scheduling should begin for this asset",
                 font=('Arial', 8), foreground='gray').grid(row=2, column=0, columnspan=2, sticky='w', padx=5)

        # Display current next PM dates for reference
        current_dates_text = "Current Next PM Dates: "
        date_parts = []
        if equipment_data.get('next_weekly_pm'):
            date_parts.append(f"Weekly: {equipment_data['next_weekly_pm']}")
        if equipment_data.get('next_monthly_pm'):
            date_parts.append(f"Monthly: {equipment_data['next_monthly_pm']}")
        if equipment_data.get('next_six_month_pm'):
            date_parts.append(f"6-Month: {equipment_data['next_six_month_pm']}")
        if equipment_data.get('next_annual_pm'):
            date_parts.append(f"Annual: {equipment_data['next_annual_pm']}")

        if date_parts:
            current_dates_text += ", ".join(date_parts)
        else:
            current_dates_text += "None set"

        ttk.Label(date_frame, text=current_dates_text,
                 font=('Arial', 8), foreground='blue').grid(row=3, column=0, columnspan=2, sticky='w', padx=5, pady=5)

        current_row += 1

        # PM type checkboxes and Equipment Status options
        pm_frame = ttk.LabelFrame(scrollable_frame, text="PM Types & Equipment Status", padding=10)
        pm_frame.grid(row=current_row, column=0, columnspan=2, padx=10, pady=10, sticky='ew')

        # Current equipment status
        current_status = equipment_data['status'] or 'Active'  # Status field

        # PM checkboxes
        weekly_var = tk.BooleanVar(value=bool(equipment_data.get('weekly_pm', False)))
        monthly_var = tk.BooleanVar(value=bool(equipment_data['monthly_pm']))
        six_month_var = tk.BooleanVar(value=bool(equipment_data['six_month_pm']))
        annual_var = tk.BooleanVar(value=bool(equipment_data['annual_pm']))

        weekly_cb = ttk.Checkbutton(pm_frame, text="Weekly PM", variable=weekly_var)
        weekly_cb.pack(anchor='w')

        monthly_cb = ttk.Checkbutton(pm_frame, text="Monthly PM", variable=monthly_var)
        monthly_cb.pack(anchor='w')

        six_month_cb = ttk.Checkbutton(pm_frame, text="Six Month PM", variable=six_month_var)
        six_month_cb.pack(anchor='w')

        annual_cb = ttk.Checkbutton(pm_frame, text="Annual PM", variable=annual_var)
        annual_cb.pack(anchor='w')

        # Disable PM checkboxes if currently Cannot Find, Run to Failure, or Deactivated
        if current_status in ['Run to Failure', 'Cannot Find', 'Deactivated']:
            weekly_cb.config(state='disabled')
            monthly_cb.config(state='disabled')
            six_month_cb.config(state='disabled')
            annual_cb.config(state='disabled')

        # Separator
        ttk.Separator(pm_frame, orient='horizontal').pack(fill='x', pady=10)

        # Run to Failure option
        run_to_failure_var = tk.BooleanVar(value=(current_status == 'Run to Failure'))
        rtf_cb = ttk.Checkbutton(pm_frame, text="Set as Run to Failure Equipment", 
                                variable=run_to_failure_var,
                                command=lambda: toggle_status_options())
        rtf_cb.pack(anchor='w', pady=5)
    
        # Run to Failure warning label
        rtf_warning_label = ttk.Label(pm_frame, text="Status: Will be set to Run to Failure", 
                                    foreground='red', font=('Arial', 9, 'italic'))
        if run_to_failure_var.get():
            rtf_warning_label.pack(anchor='w', padx=20)

        # Cannot Find option - NEW!
        cannot_find_var = tk.BooleanVar(value=(current_status == 'Cannot Find'))
        cf_cb = ttk.Checkbutton(pm_frame, text="Mark as Cannot Find",
                            variable=cannot_find_var,
                            command=lambda: toggle_status_options())
        cf_cb.pack(anchor='w', pady=5)

        # Cannot Find warning label
        cf_warning_label = ttk.Label(pm_frame, text="Status: Will be set to Cannot Find (PMs disabled)",
                                    foreground='red', font=('Arial', 9, 'italic'))
        if cannot_find_var.get():
            cf_warning_label.pack(anchor='w', padx=20)

        # Deactivated option
        deactivated_var = tk.BooleanVar(value=(current_status == 'Deactivated'))
        deact_cb = ttk.Checkbutton(pm_frame, text="Mark as Deactivated",
                            variable=deactivated_var,
                            command=lambda: toggle_status_options())
        deact_cb.pack(anchor='w', pady=5)

        # Deactivated warning label
        deact_warning_label = ttk.Label(pm_frame, text="Status: Will be set to Deactivated (PMs disabled)",
                                    foreground='red', font=('Arial', 9, 'italic'))
        if deactivated_var.get():
            deact_warning_label.pack(anchor='w', padx=20)

        # Status info
        status_label = ttk.Label(pm_frame, text=f"Current Status: {current_status}",
                                font=('Arial', 9, 'italic'))
        status_label.pack(anchor='w', pady=5)

        # Technician selection for Cannot Find (appears when Cannot Find is checked)
        tech_frame = ttk.Frame(pm_frame)
        ttk.Label(tech_frame, text="Reported By:").pack(side='left', padx=(0, 5))
        tech_var = tk.StringVar()

        # Pre-populate technician if asset is already Cannot Find
        if current_status == 'Cannot Find':
            try:
                with db_pool.get_cursor(commit=False) as cursor:
                    cursor.execute('SELECT technician_name FROM cannot_find_assets WHERE bfm_equipment_no = %s', (bfm_no,))
                    cf_data = cursor.fetchone()
                    if cf_data:
                        tech_var.set(cf_data[0])
            except Exception as e:
                print(f"Warning: Could not fetch technician data: {e}")

        tech_combo = ttk.Combobox(tech_frame, textvariable=tech_var, width=20)
        tech_combo['values'] = self.technicians if hasattr(self, 'technicians') else []
        tech_combo.pack(side='left')

        # Technician/Reason selection for Deactivated (appears when Deactivated is checked)
        deact_frame = ttk.Frame(pm_frame)
        ttk.Label(deact_frame, text="Deactivated By:").grid(row=0, column=0, sticky='w', padx=(0, 5))
        deact_tech_var = tk.StringVar()

        # Pre-populate technician if asset is already Deactivated
        deact_reason_var = tk.StringVar()
        if current_status == 'Deactivated':
            try:
                with db_pool.get_cursor(commit=False) as cursor:
                    cursor.execute('SELECT deactivated_by, reason FROM deactivated_assets WHERE bfm_equipment_no = %s', (bfm_no,))
                    deact_data = cursor.fetchone()
                    if deact_data:
                        deact_tech_var.set(deact_data[0])
                        deact_reason_var.set(deact_data[1] if deact_data[1] else '')
            except Exception as e:
                print(f"Warning: Could not fetch deactivated data: {e}")

        deact_tech_combo = ttk.Combobox(deact_frame, textvariable=deact_tech_var, width=20)
        deact_tech_combo['values'] = self.technicians if hasattr(self, 'technicians') else []
        deact_tech_combo.grid(row=0, column=1, sticky='w')

        ttk.Label(deact_frame, text="Reason:").grid(row=1, column=0, sticky='w', padx=(0, 5), pady=5)
        deact_reason_entry = ttk.Entry(deact_frame, textvariable=deact_reason_var, width=40)
        deact_reason_entry.grid(row=1, column=1, sticky='w', pady=5)
    
        # Show tech frame and warning if already Cannot Find
        if cannot_find_var.get():
            tech_frame.pack(anchor='w', pady=5, padx=20)
            cf_warning_label.pack(anchor='w', padx=20)
        if run_to_failure_var.get():
            rtf_warning_label.pack(anchor='w', padx=20)
        if deactivated_var.get():
            deact_frame.pack(anchor='w', pady=5, padx=20)
            deact_warning_label.pack(anchor='w', padx=20)

        def toggle_status_options():
            """Enable/disable options based on status selections and show/hide warnings"""
            # Only allow one status to be selected at a time
            if run_to_failure_var.get():
                cannot_find_var.set(False)
                deactivated_var.set(False)
            elif cannot_find_var.get():
                run_to_failure_var.set(False)
                deactivated_var.set(False)
            elif deactivated_var.get():
                run_to_failure_var.set(False)
                cannot_find_var.set(False)

            # Disable PM options if Run to Failure is selected
            if run_to_failure_var.get():
                weekly_cb.config(state='disabled')
                monthly_cb.config(state='disabled')
                six_month_cb.config(state='disabled')
                annual_cb.config(state='disabled')
                weekly_var.set(False)
                monthly_var.set(False)
                six_month_var.set(False)
                annual_var.set(False)
                rtf_warning_label.pack(anchor='w', padx=20)
                cf_warning_label.pack_forget()
                deact_warning_label.pack_forget()
                tech_frame.pack_forget()
                deact_frame.pack_forget()
            elif cannot_find_var.get():
                # ALSO disable PM options for Cannot Find assets
                weekly_cb.config(state='disabled')
                monthly_cb.config(state='disabled')
                six_month_cb.config(state='disabled')
                annual_cb.config(state='disabled')
                weekly_var.set(False)
                monthly_var.set(False)
                six_month_var.set(False)
                annual_var.set(False)
                cf_warning_label.pack(anchor='w', padx=20)
                rtf_warning_label.pack_forget()
                deact_warning_label.pack_forget()
                tech_frame.pack(anchor='w', pady=5, padx=20)
                deact_frame.pack_forget()
            elif deactivated_var.get():
                # ALSO disable PM options for Deactivated assets
                weekly_cb.config(state='disabled')
                monthly_cb.config(state='disabled')
                six_month_cb.config(state='disabled')
                annual_cb.config(state='disabled')
                weekly_var.set(False)
                monthly_var.set(False)
                six_month_var.set(False)
                annual_var.set(False)
                deact_warning_label.pack(anchor='w', padx=20)
                rtf_warning_label.pack_forget()
                cf_warning_label.pack_forget()
                tech_frame.pack_forget()
                deact_frame.pack(anchor='w', pady=5, padx=20)
            else:
                weekly_cb.config(state='normal')
                monthly_cb.config(state='normal')
                six_month_cb.config(state='normal')
                annual_cb.config(state='normal')
                rtf_warning_label.pack_forget()
                cf_warning_label.pack_forget()
                deact_warning_label.pack_forget()
                tech_frame.pack_forget()
                deact_frame.pack_forget()

        # Status note
        note_label = ttk.Label(pm_frame,
                              text="Run to Failure, Cannot Find, and Deactivated equipment will not be scheduled for PMs",
                              font=('Arial', 8), foreground='orange')
        note_label.pack(anchor='w', pady=(5, 0))

        def update_equipment():
            """Update equipment in database with Cannot Find support"""
            import os
            log_file = os.path.expanduser("~/Desktop/equipment_update_debug.log")

            def log_update(message):
                """Write debug message to log file"""
                try:
                    with open(log_file, 'a') as f:
                        from datetime import datetime as dt
                        timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S')
                        f.write(f"[{timestamp}] {message}\n")
                except:
                    pass

            try:
                log_update("="*80)
                log_update(f"UPDATE EQUIPMENT STARTED")
                log_update(f"Original BFM: '{bfm_no}' (length: {len(bfm_no)})")

                # Validate and parse First PM Date
                first_pm_date_str = first_pm_date_var.get().strip()
                next_weekly = None
                next_monthly = None
                next_six_month = None
                next_annual = None

                if first_pm_date_str:
                    # Parse date with flexible format handling
                    parsed_date = None
                    try:
                        # Try standard format first (YYYY-MM-DD)
                        parsed_date = datetime.strptime(first_pm_date_str, '%Y-%m-%d')
                    except ValueError:
                        # Try other common formats
                        formats = ['%m/%d/%Y', '%d/%m/%Y', '%Y/%m/%d', '%m-%d-%Y']
                        for fmt in formats:
                            try:
                                parsed_date = datetime.strptime(first_pm_date_str, fmt)
                                break
                            except ValueError:
                                continue

                    if not parsed_date:
                        messagebox.showerror("Error", "Invalid date format. Please use YYYY-MM-DD (e.g., 2026-05-01)")
                        return

                    # Calculate next PM dates based on first PM date and selected PM types
                    if weekly_var.get():
                        next_weekly = (parsed_date + timedelta(days=7)).strftime('%Y-%m-%d')

                    if monthly_var.get():
                        next_monthly = (parsed_date + timedelta(days=30)).strftime('%Y-%m-%d')

                    if six_month_var.get():
                        next_six_month = (parsed_date + timedelta(days=180)).strftime('%Y-%m-%d')

                    if annual_var.get():
                        next_annual = (parsed_date + timedelta(days=365)).strftime('%Y-%m-%d')

                # Determine new status
                if run_to_failure_var.get():
                    new_status = 'Run to Failure'
                elif cannot_find_var.get():
                    new_status = 'Cannot Find'
                elif deactivated_var.get():
                    new_status = 'Deactivated'
                else:
                    new_status = 'Active'

                # Handle photo uploads
                pic1_path = picture_1_var.get()
                pic2_path = picture_2_var.get()

                pic1_data = existing_pic1_data  # Keep existing by default
                pic2_data = existing_pic2_data

                # If new photo selected, read and replace
                if pic1_path and os.path.exists(pic1_path):
                    with open(pic1_path, 'rb') as f:
                        pic1_data = f.read()

                if pic2_path and os.path.exists(pic2_path):
                    with open(pic2_path, 'rb') as f:
                        pic2_data = f.read()

                # Use connection pool for database operations
                log_update("Starting database transaction")
                with db_pool.get_cursor(commit=True) as cursor:
                    # Get the new BFM number from the entry (might be changed)
                    new_bfm_no = entries["BFM Equipment No:"].get().strip()
                    log_update(f"New BFM: '{new_bfm_no}' (length: {len(new_bfm_no)})")

                    # Check if BFM number has changed
                    bfm_changed = (new_bfm_no != bfm_no)
                    log_update(f"BFM Changed: {bfm_changed}")

                    # If BFM changed, verify the new BFM doesn't already exist
                    if bfm_changed:
                        log_update(f"Checking if new BFM '{new_bfm_no}' already exists...")
                        cursor.execute('SELECT COUNT(*) as count FROM equipment WHERE bfm_equipment_no = %s', (new_bfm_no,))
                        result = cursor.fetchone()
                        if result['count'] > 0:
                            log_update(f"New BFM already exists! Count: {result['count']}")
                            messagebox.showerror("Error", f"BFM Equipment No '{new_bfm_no}' already exists. Please use a unique BFM number.")
                            return
                        log_update(f"New BFM is unique, proceeding with update")

                    # Update equipment table including photos, BFM number, and next PM dates
                    log_update(f"Executing UPDATE statement")
                    log_update(f"WHERE clause searching for BFM: '{bfm_no}'")
                    log_update(f"New status: {new_status}")

                    cursor.execute('''
                        UPDATE equipment
                        SET sap_material_no = %s,
                            bfm_equipment_no = %s,
                            description = %s,
                            tool_id_drawing_no = %s,
                            location = %s,
                            master_lin = %s,
                            weekly_pm = %s,
                            monthly_pm = %s,
                            six_month_pm = %s,
                            annual_pm = %s,
                            next_weekly_pm = %s,
                            next_monthly_pm = %s,
                            next_six_month_pm = %s,
                            next_annual_pm = %s,
                            status = %s,
                            picture_1_data = %s,
                            picture_2_data = %s
                        WHERE bfm_equipment_no = %s
                    ''', (
                        entries["SAP Material No:"].get().strip(),
                        new_bfm_no,  # New BFM number (already stripped above)
                        entries["Description:"].get().strip(),
                        entries["Tool ID/Drawing No:"].get().strip(),
                        entries["Location:"].get().strip(),
                        entries["Master LIN:"].get().strip(),
                        weekly_var.get(),
                        monthly_var.get(),
                        six_month_var.get(),
                        annual_var.get(),
                        next_weekly,
                        next_monthly,
                        next_six_month,
                        next_annual,
                        new_status,
                        pic1_data,
                        pic2_data,
                        bfm_no  # OLD BFM number in WHERE clause
                    ))

                    # Check if the UPDATE affected any rows
                    rows_updated = cursor.rowcount
                    log_update(f"UPDATE completed. Rows affected: {rows_updated}")

                    if rows_updated == 0:
                        log_update(f"ERROR: No rows updated! Equipment '{bfm_no}' not found in database")
                        raise Exception(f"Equipment with BFM '{bfm_no}' not found in database. The equipment may have been deleted by another user. Please refresh and try again.")

                    # If BFM changed, update all related tables with foreign keys
                    if bfm_changed:
                        # Update cannot_find_assets
                        cursor.execute('UPDATE cannot_find_assets SET bfm_equipment_no = %s WHERE bfm_equipment_no = %s',
                                     (new_bfm_no, bfm_no))

                        # Update deactivated_assets
                        cursor.execute('UPDATE deactivated_assets SET bfm_equipment_no = %s WHERE bfm_equipment_no = %s',
                                     (new_bfm_no, bfm_no))

                        # Update run_to_failure_assets
                        cursor.execute('UPDATE run_to_failure_assets SET bfm_equipment_no = %s WHERE bfm_equipment_no = %s',
                                     (new_bfm_no, bfm_no))

                        # Update PM schedules
                        cursor.execute('UPDATE weekly_pm_schedules SET bfm_equipment_no = %s WHERE bfm_equipment_no = %s',
                                     (new_bfm_no, bfm_no))
                        cursor.execute('UPDATE monthly_pm_schedules SET bfm_equipment_no = %s WHERE bfm_equipment_no = %s',
                                     (new_bfm_no, bfm_no))
                        cursor.execute('UPDATE six_month_pm_schedules SET bfm_equipment_no = %s WHERE bfm_equipment_no = %s',
                                     (new_bfm_no, bfm_no))
                        cursor.execute('UPDATE annual_pm_schedules SET bfm_equipment_no = %s WHERE bfm_equipment_no = %s',
                                     (new_bfm_no, bfm_no))

                        # Update PM completions
                        cursor.execute('UPDATE pm_completions SET bfm_equipment_no = %s WHERE bfm_equipment_no = %s',
                                     (new_bfm_no, bfm_no))

                        # Update corrective maintenance
                        cursor.execute('UPDATE corrective_maintenance SET bfm_equipment_no = %s WHERE bfm_equipment_no = %s',
                                     (new_bfm_no, bfm_no))

                    # Handle Run to Failure status
                    if run_to_failure_var.get() and current_status != 'Run to Failure':
                        cursor.execute('''
                            INSERT INTO run_to_failure_assets
                            (bfm_equipment_no, description, location, technician_name, completion_date, labor_hours, notes)
                            VALUES (%s, %s, %s, %s, %s, %s, %s)
                            ON CONFLICT (bfm_equipment_no)
                            DO UPDATE SET
                                description = EXCLUDED.description,
                                location = EXCLUDED.location,
                                technician_name = EXCLUDED.technician_name,
                                completion_date = EXCLUDED.completion_date,
                                labor_hours = EXCLUDED.labor_hours,
                                notes = EXCLUDED.notes
                        ''', (
                            new_bfm_no,
                            entries["Description:"].get(),
                            entries["Location:"].get(),
                            'System Change',
                            datetime.now().strftime('%Y-%m-%d'),
                            0.0,
                            'Equipment manually set to Run to Failure status via equipment edit dialog'
                        ))

                        # Remove from Cannot Find if it was there
                        cursor.execute('DELETE FROM cannot_find_assets WHERE bfm_equipment_no = %s', (new_bfm_no,))

                    elif not run_to_failure_var.get() and current_status == 'Run to Failure':
                        cursor.execute('DELETE FROM run_to_failure_assets WHERE bfm_equipment_no = %s', (new_bfm_no,))

                    # Handle Cannot Find status - NEW!
                    if cannot_find_var.get():
                        # Get technician name
                        technician = tech_var.get().strip()
                        if not technician:
                            messagebox.showwarning("Missing Information", "Please select who is reporting this asset as Cannot Find")
                            return

                        # Add or update in cannot_find_assets table
                        cursor.execute('''
                            INSERT INTO cannot_find_assets
                            (bfm_equipment_no, description, location, technician_name, reported_date, status, notes)
                            VALUES (%s, %s, %s, %s, %s, 'Missing', %s)
                            ON CONFLICT (bfm_equipment_no)
                            DO UPDATE SET
                                description = EXCLUDED.description,
                                location = EXCLUDED.location,
                                technician_name = EXCLUDED.technician_name,
                                reported_date = EXCLUDED.reported_date,
                                status = EXCLUDED.status,
                                notes = EXCLUDED.notes
                        ''', (
                            new_bfm_no,
                            entries["Description:"].get(),
                            entries["Location:"].get(),
                            technician,
                            datetime.now().strftime('%Y-%m-%d'),
                            'Equipment marked as Cannot Find via equipment edit dialog'
                        ))

                        # Remove from Run to Failure if it was there
                        cursor.execute('DELETE FROM run_to_failure_assets WHERE bfm_equipment_no = %s', (new_bfm_no,))

                        # Update any scheduled PMs for this asset to "Cannot Find" status
                        cursor.execute('''
                            UPDATE weekly_pm_schedules
                            SET status = 'Cannot Find'
                            WHERE bfm_equipment_no = %s AND status = 'Scheduled'
                        ''', (new_bfm_no,))

                    elif not cannot_find_var.get() and current_status == 'Cannot Find':
                        # Remove from Cannot Find table
                        cursor.execute('DELETE FROM cannot_find_assets WHERE bfm_equipment_no = %s', (new_bfm_no,))
                        technician = None  # Set to None when unmarking

                    # Handle Deactivated status - NEW!
                    if deactivated_var.get():
                        # Get technician name and reason
                        deact_technician = deact_tech_var.get().strip()
                        deact_reason = deact_reason_var.get().strip()
                        if not deact_technician:
                            messagebox.showwarning("Missing Information", "Please select who is deactivating this asset")
                            return

                        # Add or update in deactivated_assets table
                        cursor.execute('''
                            INSERT INTO deactivated_assets
                            (bfm_equipment_no, description, location, deactivated_by, deactivated_date, reason, status, notes)
                            VALUES (%s, %s, %s, %s, %s, %s, 'Deactivated', %s)
                            ON CONFLICT (bfm_equipment_no)
                            DO UPDATE SET
                                description = EXCLUDED.description,
                                location = EXCLUDED.location,
                                deactivated_by = EXCLUDED.deactivated_by,
                                deactivated_date = EXCLUDED.deactivated_date,
                                reason = EXCLUDED.reason,
                                status = EXCLUDED.status,
                                notes = EXCLUDED.notes
                        ''', (
                            new_bfm_no,
                            entries["Description:"].get(),
                            entries["Location:"].get(),
                            deact_technician,
                            datetime.now().strftime('%Y-%m-%d'),
                            deact_reason,
                            'Equipment marked as Deactivated via equipment edit dialog'
                        ))

                        # Remove from other tables if it was there
                        cursor.execute('DELETE FROM run_to_failure_assets WHERE bfm_equipment_no = %s', (new_bfm_no,))
                        cursor.execute('DELETE FROM cannot_find_assets WHERE bfm_equipment_no = %s', (new_bfm_no,))

                        # Update any scheduled PMs for this asset to "Deactivated" status
                        cursor.execute('''
                            UPDATE weekly_pm_schedules
                            SET status = 'Deactivated'
                            WHERE bfm_equipment_no = %s AND status = 'Scheduled'
                        ''', (new_bfm_no,))

                    elif not deactivated_var.get() and current_status == 'Deactivated':
                        # Remove from Deactivated table
                        cursor.execute('DELETE FROM deactivated_assets WHERE bfm_equipment_no = %s', (new_bfm_no,))

                # Show appropriate success message
                if run_to_failure_var.get():
                    success_msg = f"Equipment {new_bfm_no} updated successfully!\n\nStatus changed to: Run to Failure\n"
                    success_msg += "- All PM requirements disabled\n"
                    success_msg += "- Equipment moved to Run to Failure tab\n"
                    success_msg += "- No future PMs will be scheduled"
                elif cannot_find_var.get():
                    success_msg = f"Equipment {new_bfm_no} updated successfully!\n\nStatus changed to: Cannot Find\n"
                    success_msg += f"- Reported by: {technician}\n"
                    success_msg += "- Equipment moved to Cannot Find tab\n"
                    success_msg += "- All PM requirements disabled\n"
                    success_msg += "- No future PMs will be scheduled"
                elif deactivated_var.get():
                    success_msg = f"Equipment {new_bfm_no} updated successfully!\n\nStatus changed to: Deactivated\n"
                    success_msg += f"- Deactivated by: {deact_technician}\n"
                    if deact_reason:
                        success_msg += f"- Reason: {deact_reason}\n"
                    success_msg += "- Equipment moved to Deactivated tab\n"
                    success_msg += "- All PM requirements disabled\n"
                    success_msg += "- No future PMs will be scheduled"
                else:
                    success_msg = f"Equipment {new_bfm_no} updated successfully!\n\nStatus: Active"

                # Add note if BFM number was changed
                if bfm_changed:
                    success_msg += f"\n\nBFM number changed from {bfm_no} to {new_bfm_no}"

                messagebox.showinfo("Success", success_msg)
                dialog.destroy()

                # Refresh all relevant displays
                self.refresh_equipment_list()
                if hasattr(self, 'load_cannot_find_assets'):
                    self.load_cannot_find_assets()
                if hasattr(self, 'load_run_to_failure_assets'):
                    self.load_run_to_failure_assets()
                if hasattr(self, 'load_deactivated_assets'):
                    self.load_deactivated_assets()
                if hasattr(self, 'update_equipment_statistics'):
                    self.update_equipment_statistics()

                # Update status bar
                if run_to_failure_var.get():
                    self.update_status(f"Equipment {new_bfm_no} set to Run to Failure")
                elif cannot_find_var.get():
                    self.update_status(f"Equipment {new_bfm_no} marked as Cannot Find")
                elif deactivated_var.get():
                    self.update_status(f"Equipment {new_bfm_no} marked as Deactivated")
                else:
                    self.update_status(f"Equipment {new_bfm_no} reactivated")
            
            except Exception as e:
                import traceback
                log_update(f"EXCEPTION OCCURRED: {type(e).__name__}: {str(e)}")
                log_update(f"Full traceback:\n{traceback.format_exc()}")
                messagebox.showerror("Error", f"Failed to update equipment: {str(e)}")

        # Buttons
        button_frame = ttk.Frame(scrollable_frame)
        button_frame.grid(row=current_row+1, column=0, columnspan=2, pady=15)

        update_btn = ttk.Button(button_frame, text="Update Equipment", command=update_equipment)
        update_btn.pack(side='left', padx=10)

        cancel_btn = ttk.Button(button_frame, text="Cancel", command=dialog.destroy)
        cancel_btn.pack(side='left', padx=5)

        # Pack canvas and scrollbar
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
    
    
    
    def bulk_edit_pm_cycles(self):
        """Edit PM cycles for multiple selected assets"""
        # Get selected items
        selected_items = self.equipment_tree.selection()
    
        if not selected_items:
            messagebox.showwarning("No Selection", 
                                 "Please select one or more assets to edit.\n\n" +
                                 "Tip: Hold Ctrl to select multiple items, or Shift to select a range.")
            return
    
        # Get BFM numbers of selected items
        selected_bfms = []
        for item in selected_items:
            values = self.equipment_tree.item(item)['values']
            bfm_no = values[1]  # BFM is second column
            selected_bfms.append(bfm_no)
    
        # Create dialog
        dialog = tk.Toplevel(self.root)
        dialog.title("Bulk Edit PM Cycles")
        dialog.geometry("500x400")
        dialog.transient(self.root)
        dialog.grab_set()
    
        # Center dialog
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (250)
        y = (dialog.winfo_screenheight() // 2) - (200)
        dialog.geometry(f"500x400+{x}+{y}")
        
        # Header
        header_frame = ttk.Frame(dialog, padding=20)
        header_frame.pack(fill='x')
        
        ttk.Label(header_frame, text="Bulk Edit PM Cycles", 
                font=('Arial', 14, 'bold')).pack()
        ttk.Label(header_frame, text=f"Editing {len(selected_bfms)} selected asset(s)", 
                font=('Arial', 10), foreground='blue').pack(pady=5)
    
        # Separator
        ttk.Separator(dialog, orient='horizontal').pack(fill='x', pady=10)
        
        # Show selected assets
        assets_frame = ttk.LabelFrame(dialog, text="Selected Assets", padding=10)
        assets_frame.pack(fill='both', expand=True, padx=20, pady=10)
        
        # Scrollable list of selected assets
        assets_text = tk.Text(assets_frame, height=6, width=50, wrap='word')
        assets_scrollbar = ttk.Scrollbar(assets_frame, orient='vertical', command=assets_text.yview)
        assets_text.configure(yscrollcommand=assets_scrollbar.set)
        
        # Get asset details - OPTIMIZED: Bulk query instead of N+1
        cursor = self.conn.cursor()
        display_bfms = selected_bfms[:20]  # Show first 20

        if display_bfms:
            # Single query for all equipment instead of one query per equipment
            placeholders = ','.join(['%s'] * len(display_bfms))
            cursor.execute(f'SELECT bfm_equipment_no, description FROM equipment WHERE bfm_equipment_no IN ({placeholders})', tuple(display_bfms))
            equipment_details = cursor.fetchall()

            # Display equipment in original selection order
            equipment_dict = {row[0]: row[1] for row in equipment_details}
            for bfm in display_bfms:
                if bfm in equipment_dict:
                    assets_text.insert('end', f"- {bfm} - {equipment_dict[bfm][:40]}\n")
    
        if len(selected_bfms) > 20:
            assets_text.insert('end', f"\n... and {len(selected_bfms) - 20} more assets")
    
        assets_text.config(state='disabled')
        assets_text.pack(side='left', fill='both', expand=True)
        assets_scrollbar.pack(side='right', fill='y')
    
        # PM Cycle options
        pm_frame = ttk.LabelFrame(dialog, text="PM Cycle Settings", padding=15)
        pm_frame.pack(fill='x', padx=20, pady=10)
    
        ttk.Label(pm_frame, text="Select which PM cycles to apply:", 
                font=('Arial', 10, 'bold')).pack(anchor='w', pady=(0, 10))
    
        # Monthly PM
        monthly_var = tk.BooleanVar(value=False)
        monthly_check = ttk.Checkbutton(pm_frame, text="Monthly PM (every 30 days)", 
                                        variable=monthly_var)
        monthly_check.pack(anchor='w', pady=3)
        
        # Six Month PM
        six_month_var = tk.BooleanVar(value=False)
        six_month_check = ttk.Checkbutton(pm_frame, text="Six Month PM (every 180 days)", 
                                        variable=six_month_var)
        six_month_check.pack(anchor='w', pady=3)
    
        # Annual PM
        annual_var = tk.BooleanVar(value=True)  # Default to Annual
        annual_check = ttk.Checkbutton(pm_frame, text="Annual PM (every 365 days)", 
                                    variable=annual_var)
        annual_check.pack(anchor='w', pady=3)
    
        ttk.Label(pm_frame, text="Note: Unchecked cycles will be DISABLED for selected assets.", 
                font=('Arial', 9), foreground='gray').pack(anchor='w', pady=(10, 0))
    
        # Buttons
        button_frame = ttk.Frame(dialog, padding=10)
        button_frame.pack(fill='x', side='bottom')
    
        def apply_changes():
            """Apply PM cycle changes to all selected assets"""
            try:
                monthly_pm = True if monthly_var.get() else False
                six_month_pm = True if six_month_var.get() else False
                annual_pm = True if annual_var.get() else False
                
                # Confirm action
                pm_types = []
                if monthly_pm:
                    pm_types.append("Monthly")
                if six_month_pm:
                    pm_types.append("Six Month")
                if annual_pm:
                    pm_types.append("Annual")
            
                if not pm_types:
                    result = messagebox.askyesno(
                        "Warning - No PM Cycles Selected",
                        f"You are about to DISABLE ALL PM cycles for {len(selected_bfms)} asset(s).\n\n" +
                        "This means these assets will NOT be scheduled for any preventive maintenance.\n\n" +
                        "Are you sure you want to continue?",
                        icon='warning',
                        parent=dialog
                    )
                else:
                    pm_list = ", ".join(pm_types)
                    result = messagebox.askyesno(
                        "Confirm Changes",
                        f"Apply the following PM cycles to {len(selected_bfms)} asset(s)?\n\n" +
                        f"PM Cycles: {pm_list}\n\n" +
                        "This will update all selected assets.",
                        parent=dialog
                    )
            
                if not result:
                    return
            
                # Apply changes
                cursor = self.conn.cursor()
                updated_count = 0
                
                for bfm in selected_bfms:
                    cursor.execute('''
                        UPDATE equipment 
                        SET monthly_pm = %s, six_month_pm = %s, annual_pm = %s
                        WHERE bfm_equipment_no = %s
                    ''', (monthly_pm, six_month_pm, annual_pm, bfm))
                
                    if cursor.rowcount > 0:
                        updated_count += 1
            
                self.conn.commit()
            
                # Success message
                messagebox.showinfo(
                    "Success",
                    f"Successfully updated PM cycles for {updated_count} asset(s)!",
                    parent=dialog
                )
            
                # Close dialog and refresh
                dialog.destroy()
                self.refresh_equipment_list()
                self.update_status(f"Bulk updated PM cycles for {updated_count} assets")
            
            except Exception as e:
                messagebox.showerror("Error", f"Failed to update PM cycles:\n\n{str(e)}", parent=dialog)
    
        ttk.Button(button_frame, text="Apply to All Selected", 
                command=apply_changes,
                style='Accent.TButton').pack(side='left', padx=5)
    
        ttk.Button(button_frame, text="Cancel", 
                command=dialog.destroy).pack(side='right', padx=5)


    def enable_multiselect_on_equipment_tree(self):
        """Enable multiple selection on equipment tree (call this after creating the tree)"""
        self.equipment_tree.configure(selectmode='extended')  # Enable multi-select
    
    
    
    
    def refresh_equipment_list(self):
        """OPTIMIZED: Refresh equipment list using SQL-based filtering"""
        try:
            # Update statistics
            self.update_equipment_statistics()

            # Update location filter dropdown
            self.populate_location_filter()

            # Use the optimized filter method which now uses SQL
            self.filter_equipment_list()

        except Exception as e:
            print(f"Error refreshing equipment list: {e}")
            messagebox.showerror("Error", f"Failed to refresh equipment list: {str(e)}")
    
    def filter_equipment_list(self, *args, reset=True):
        """OPTIMIZED: Filter equipment list with pagination - SQL WHERE clauses + LIMIT/OFFSET"""
        try:
            print("DEBUG: filter_equipment_list called")

            # Check if equipment tree exists yet (might be called during tab creation)
            if not hasattr(self, 'equipment_tree'):
                print("DEBUG: equipment_tree not created yet, skipping filter")
                return

            # Initialize pagination state if not already done
            if not hasattr(self, 'equip_offset'):
                self.equip_offset = 0
                self.equip_page_size = 200
                self.equip_total_count = 0
                self.equip_loaded_count = 0

            # Update status bar to show function is being called
            if hasattr(self, 'update_status'):
                self.update_status("Filtering equipment...")

            # Populate location filter if not done yet
            if hasattr(self, 'equipment_location_combo') and not hasattr(self, '_location_filter_populated'):
                self.populate_location_filter()
                self._location_filter_populated = True

            # Read filter values
            search_term = self.equipment_search_entry.get().strip() if hasattr(self, 'equipment_search_entry') else ''
            selected_status = self.equipment_status_var.get() if hasattr(self, 'equipment_status_var') else "All Assets"
            selected_location = self.equipment_location_var.get() if hasattr(self, 'equipment_location_var') else "All Locations"

            # Get PM cycle filter states
            monthly_filter = self.monthly_pm_filter_var.get() if hasattr(self, 'monthly_pm_filter_var') else False
            six_month_filter = self.six_month_pm_filter_var.get() if hasattr(self, 'six_month_pm_filter_var') else False
            annual_filter = self.annual_pm_filter_var.get() if hasattr(self, 'annual_pm_filter_var') else False

            print(f"DEBUG: Search term: '{search_term}', Status: '{selected_status}', Location: '{selected_location}', PM Filters: Monthly={monthly_filter}, 6-Month={six_month_filter}, Annual={annual_filter}")

            # Reset pagination when filters change
            if reset:
                self.equip_offset = 0
                self.equip_loaded_count = 0
                # Clear existing items
                for item in self.equipment_tree.get_children():
                    self.equipment_tree.delete(item)

            cursor = self.conn.cursor()

            # Build SQL query with filters - Show ALL assets with calculated ACTIVE/INACTIVE status
            # ACTIVE = Must have at least ONE PM schedule enabled (weekly OR monthly OR 6-month OR annual)
            # INACTIVE = No PM schedules OR in tracking tables OR bad status
            query = '''
                SELECT e.sap_material_no, e.bfm_equipment_no, e.description, e.location, e.master_lin,
                       e.monthly_pm, e.six_month_pm, e.annual_pm, e.status,
                       CASE
                           WHEN (COALESCE(e.weekly_pm, FALSE) = FALSE
                                 AND COALESCE(e.monthly_pm, FALSE) = FALSE
                                 AND COALESCE(e.six_month_pm, FALSE) = FALSE
                                 AND COALESCE(e.annual_pm, FALSE) = FALSE) THEN 'INACTIVE'
                           WHEN d.bfm_equipment_no IS NOT NULL THEN 'INACTIVE'
                           WHEN c.bfm_equipment_no IS NOT NULL THEN 'INACTIVE'
                           WHEN r.bfm_equipment_no IS NOT NULL THEN 'INACTIVE'
                           WHEN e.status IN ('Run to Failure', 'Missing', 'Deactivated') THEN 'INACTIVE'
                           ELSE 'ACTIVE'
                       END as calculated_status
                FROM equipment e
                LEFT JOIN deactivated_assets d ON e.bfm_equipment_no = d.bfm_equipment_no AND d.status = 'Deactivated'
                LEFT JOIN cannot_find_assets c ON e.bfm_equipment_no = c.bfm_equipment_no AND c.status = 'Missing'
                LEFT JOIN run_to_failure_assets r ON e.bfm_equipment_no = r.bfm_equipment_no
                WHERE 1=1
            '''
            params = []

            # Status filter (ACTIVE/INACTIVE)
            if selected_status == "ACTIVE":
                query += '''
                    AND (e.weekly_pm = TRUE OR e.monthly_pm = TRUE OR e.six_month_pm = TRUE OR e.annual_pm = TRUE)
                    AND d.bfm_equipment_no IS NULL
                    AND c.bfm_equipment_no IS NULL
                    AND r.bfm_equipment_no IS NULL
                    AND (e.status NOT IN ('Run to Failure', 'Missing', 'Deactivated') OR e.status IS NULL)
                '''
            elif selected_status == "INACTIVE":
                query += '''
                    AND ((COALESCE(e.weekly_pm, FALSE) = FALSE
                          AND COALESCE(e.monthly_pm, FALSE) = FALSE
                          AND COALESCE(e.six_month_pm, FALSE) = FALSE
                          AND COALESCE(e.annual_pm, FALSE) = FALSE)
                         OR d.bfm_equipment_no IS NOT NULL
                         OR c.bfm_equipment_no IS NOT NULL
                         OR r.bfm_equipment_no IS NOT NULL
                         OR e.status IN ('Run to Failure', 'Missing', 'Deactivated'))
                '''

            # Location filter
            if selected_location != "All Locations":
                query += " AND e.location = %s"
                params.append(selected_location)

            # PM cycle filters (OR logic - equipment must have at least one selected PM type)
            if monthly_filter or six_month_filter or annual_filter:
                pm_conditions = []
                if monthly_filter:
                    pm_conditions.append("e.monthly_pm = TRUE")
                if six_month_filter:
                    pm_conditions.append("e.six_month_pm = TRUE")
                if annual_filter:
                    pm_conditions.append("e.annual_pm = TRUE")
                query += f" AND ({' OR '.join(pm_conditions)})"

            # Search term filter - use LOWER() for case-insensitive search
            if search_term:
                query += ''' AND (
                    LOWER(e.sap_material_no) LIKE LOWER(%s) OR
                    LOWER(e.bfm_equipment_no) LIKE LOWER(%s) OR
                    LOWER(e.description) LIKE LOWER(%s) OR
                    LOWER(e.location) LIKE LOWER(%s) OR
                    LOWER(e.master_lin) LIKE LOWER(%s)
                )'''
                search_param = f'%{search_term}%'
                params.extend([search_param] * 5)

            # Get total count for pagination (only on reset/filter change)
            if reset or self.equip_total_count == 0:
                # Build count query with same JOINs and WHERE clause
                count_query = '''
                    SELECT COUNT(DISTINCT e.bfm_equipment_no)
                    FROM equipment e
                    LEFT JOIN deactivated_assets d ON e.bfm_equipment_no = d.bfm_equipment_no AND d.status = 'Deactivated'
                    LEFT JOIN cannot_find_assets c ON e.bfm_equipment_no = c.bfm_equipment_no AND c.status = 'Missing'
                    LEFT JOIN run_to_failure_assets r ON e.bfm_equipment_no = r.bfm_equipment_no
                    WHERE 1=1
                '''
                # Add same filters as main query
                count_params = []

                # Status filter
                if selected_status == "ACTIVE":
                    count_query += '''
                        AND (e.weekly_pm = TRUE OR e.monthly_pm = TRUE OR e.six_month_pm = TRUE OR e.annual_pm = TRUE)
                        AND d.bfm_equipment_no IS NULL
                        AND c.bfm_equipment_no IS NULL
                        AND r.bfm_equipment_no IS NULL
                        AND (e.status NOT IN ('Run to Failure', 'Missing', 'Deactivated') OR e.status IS NULL)
                    '''
                elif selected_status == "INACTIVE":
                    count_query += '''
                        AND ((COALESCE(e.weekly_pm, FALSE) = FALSE
                              AND COALESCE(e.monthly_pm, FALSE) = FALSE
                              AND COALESCE(e.six_month_pm, FALSE) = FALSE
                              AND COALESCE(e.annual_pm, FALSE) = FALSE)
                             OR d.bfm_equipment_no IS NOT NULL
                             OR c.bfm_equipment_no IS NOT NULL
                             OR r.bfm_equipment_no IS NOT NULL
                             OR e.status IN ('Run to Failure', 'Missing', 'Deactivated'))
                    '''

                if selected_location != "All Locations":
                    count_query += " AND e.location = %s"
                    count_params.append(selected_location)
                if monthly_filter or six_month_filter or annual_filter:
                    pm_conditions = []
                    if monthly_filter:
                        pm_conditions.append("e.monthly_pm = TRUE")
                    if six_month_filter:
                        pm_conditions.append("e.six_month_pm = TRUE")
                    if annual_filter:
                        pm_conditions.append("e.annual_pm = TRUE")
                    count_query += f" AND ({' OR '.join(pm_conditions)})"
                if search_term:
                    count_query += ''' AND (
                        LOWER(e.sap_material_no) LIKE LOWER(%s) OR
                        LOWER(e.bfm_equipment_no) LIKE LOWER(%s) OR
                        LOWER(e.description) LIKE LOWER(%s) OR
                        LOWER(e.location) LIKE LOWER(%s) OR
                        LOWER(e.master_lin) LIKE LOWER(%s)
                    )'''
                    search_param = f'%{search_term}%'
                    count_params.extend([search_param] * 5)

                cursor.execute(count_query, count_params)
                self.equip_total_count = cursor.fetchone()[0]

            # Add pagination
            query += f" ORDER BY e.bfm_equipment_no LIMIT {self.equip_page_size} OFFSET {self.equip_offset}"

            # Execute optimized query
            cursor.execute(query, params)

            # Display results (append to existing if loading more)
            records_added = 0
            for idx, equipment in enumerate(cursor.fetchall()):
                sap, bfm, desc, location, master_lin, monthly_pm, six_month_pm, annual_pm, status, calculated_status = equipment

                self.equipment_tree.insert('', 'end', values=(
                    sap or '',
                    bfm or '',
                    desc or '',
                    location or '',
                    master_lin or '',
                    'Yes' if monthly_pm else 'No',
                    'Yes' if six_month_pm else 'No',
                    'Yes' if annual_pm else 'No',
                    calculated_status or 'ACTIVE'
                ))
                records_added += 1

                # Yield to event loop every 100 items to keep UI responsive
                if idx % 100 == 0:
                    self.root.update_idletasks()

            # Update pagination state
            self.equip_loaded_count += records_added
            self.equip_offset += records_added

            print(f"DEBUG: Loaded {records_added} records, total: {self.equip_loaded_count}/{self.equip_total_count}")

            # Update pagination UI
            if hasattr(self, 'equip_record_label'):
                self.equip_record_label.config(
                    text=f"Showing {self.equip_loaded_count} of {self.equip_total_count} records"
                )

            if hasattr(self, 'equip_load_more_btn'):
                if self.equip_loaded_count >= self.equip_total_count:
                    self.equip_load_more_btn.config(state='disabled', text="All Records Loaded")
                else:
                    remaining = self.equip_total_count - self.equip_loaded_count
                    self.equip_load_more_btn.config(
                        state='normal',
                        text=f" Load More ({remaining} remaining)"
                    )

            # Update status bar with results
            if hasattr(self, 'update_status'):
                if search_term:
                    self.update_status(f"Showing {self.equip_loaded_count} of {self.equip_total_count} equipment matching '{search_term}'")
                else:
                    self.update_status(f"Showing {self.equip_loaded_count} of {self.equip_total_count} equipment items")

        except Exception as e:
            print(f"ERROR in filter_equipment_list: {e}")
            if hasattr(self, 'update_status'):
                self.update_status(f"Error filtering equipment: {str(e)}")
            import traceback
            traceback.print_exc()

    def load_more_equipment_records(self):
        """Load next batch of equipment records"""
        self.filter_equipment_list(reset=False)

    def populate_location_filter(self):
        """Populate location filter dropdown with distinct locations from database"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('SELECT DISTINCT location FROM equipment WHERE location IS NOT NULL AND location != \'\' ORDER BY location')
            locations = [row[0] for row in cursor.fetchall()]

            # Add "All Locations" as the first option
            location_values = ["All Locations"] + locations
            self.equipment_location_combo['values'] = location_values

            # Set default to "All Locations"
            if self.equipment_location_var.get() not in location_values:
                self.equipment_location_var.set("All Locations")

        except Exception as e:
            print(f"Error populating location filter: {e}")

    def clear_equipment_filters(self):
        """Clear all equipment filters and show all equipment"""
        if hasattr(self, 'equipment_search_entry'):
            self.equipment_search_entry.delete(0, 'end')
        self.equipment_search_var.set('')
        self.equipment_status_var.set("All Assets")
        self.equipment_location_var.set("All Locations")

        # Clear PM cycle filters
        if hasattr(self, 'monthly_pm_filter_var'):
            self.monthly_pm_filter_var.set(False)
        if hasattr(self, 'six_month_pm_filter_var'):
            self.six_month_pm_filter_var.set(False)
        if hasattr(self, 'annual_pm_filter_var'):
            self.annual_pm_filter_var.set(False)

        self.filter_equipment_list()

    def on_equipment_double_click(self, event):
        """Handle double-click on equipment to schedule and print PM"""
        selection = self.equipment_tree.selection()
        if not selection:
            return

        # Get the selected item's values
        item = self.equipment_tree.item(selection[0])
        values = item['values']

        if len(values) >= 2:
            bfm_no = str(values[1])  # BFM Equipment No. is at index 1, convert to string
            self.show_equipment_pm_actions_dialog(bfm_no)

    def show_equipment_pm_actions_dialog(self, bfm_no):
        """Show dialog for scheduling and printing PM for specific equipment"""
        try:
            # Ensure bfm_no is a string for database comparison
            bfm_no = str(bfm_no)
            cursor = self.conn.cursor()

            # Get equipment information
            cursor.execute('''
                SELECT sap_material_no, bfm_equipment_no, description, tool_id_drawing_no,
                    location, master_lin, weekly_pm, monthly_pm, six_month_pm, annual_pm,
                    last_weekly_pm, last_monthly_pm, last_six_month_pm, last_annual_pm,
                    next_weekly_pm, next_monthly_pm, next_six_month_pm, next_annual_pm, status
                FROM equipment
                WHERE bfm_equipment_no = %s
            ''', (bfm_no,))

            equipment_data = cursor.fetchone()

            if not equipment_data:
                messagebox.showerror("Error", f"Equipment '{bfm_no}' not found in database")
                return

            # Create dialog
            dialog = tk.Toplevel(self.root)
            dialog.title(f"PM Actions - {bfm_no}")
            dialog.geometry("700x600")
            dialog.transient(self.root)
            dialog.grab_set()

            # Equipment details frame
            details_frame = ttk.LabelFrame(dialog, text="Equipment Details", padding=15)
            details_frame.pack(fill='x', padx=10, pady=10)

            # Unpack equipment data
            (sap_no, bfm, description, tool_id, location, master_lin, weekly_pm, monthly_pm,
             six_month_pm, annual_pm, last_weekly, last_monthly, last_six_month, last_annual,
             next_weekly, next_monthly, next_six_month, next_annual, status) = equipment_data

            # Display equipment details
            row = 0
            details = [
                ("BFM Equipment No.:", bfm),
                ("SAP Material No.:", sap_no or 'N/A'),
                ("Description:", description or 'N/A'),
                ("Location:", location or 'N/A'),
                ("Master LIN:", master_lin or 'N/A'),
                ("Status:", status or 'Active'),
            ]

            for label_text, value_text in details:
                ttk.Label(details_frame, text=label_text, font=('Arial', 10, 'bold')).grid(
                    row=row, column=0, sticky='w', pady=5)
                ttk.Label(details_frame, text=str(value_text), font=('Arial', 10)).grid(
                    row=row, column=1, sticky='w', padx=10, pady=5)
                row += 1

            # PM Schedule Information
            pm_frame = ttk.LabelFrame(dialog, text="PM Schedule Information", padding=15)
            pm_frame.pack(fill='both', expand=True, padx=10, pady=5)

            # Create text widget for PM info
            pm_text = tk.Text(pm_frame, height=10, width=70, wrap='word', font=('Arial', 10))
            pm_text.pack(fill='both', expand=True, padx=5, pady=5)

            # Add PM schedule information
            pm_info = []
            if weekly_pm:
                pm_info.append(f"Weekly PM: Enabled")
                pm_info.append(f"  Last Completed: {last_weekly or 'Never'}")
                pm_info.append(f"  Next Due: {next_weekly or 'Not Scheduled'}")
                pm_info.append("")

            if monthly_pm:
                pm_info.append(f"Monthly PM: Enabled")
                pm_info.append(f"  Last Completed: {last_monthly or 'Never'}")
                pm_info.append(f"  Next Due: {next_monthly or 'Not Scheduled'}")
                pm_info.append("")

            if six_month_pm:
                pm_info.append(f"Six Month PM: Enabled")
                pm_info.append(f"  Last Completed: {last_six_month or 'Never'}")
                pm_info.append(f"  Next Due: {next_six_month or 'Not Scheduled'}")
                pm_info.append("")

            if annual_pm:
                pm_info.append(f"Annual PM: Enabled")
                pm_info.append(f"  Last Completed: {last_annual or 'Never'}")
                pm_info.append(f"  Next Due: {next_annual or 'Not Scheduled'}")

            if not pm_info:
                pm_info.append("No PM schedule configured for this equipment.")

            pm_text.insert('1.0', '\n'.join(pm_info))
            pm_text.config(state='disabled')

            # Action buttons frame
            actions_frame = ttk.Frame(dialog, padding=10)
            actions_frame.pack(fill='x', padx=10, pady=10)

            # Schedule PM button
            ttk.Button(actions_frame, text="Schedule PM",
                      command=lambda: self.schedule_equipment_pm_dialog(bfm_no, equipment_data, dialog)).pack(
                side='left', padx=5)

            # Print PM Form button
            ttk.Button(actions_frame, text="Print PM Form",
                      command=lambda: self.print_equipment_pm_form(bfm_no, equipment_data)).pack(
                side='left', padx=5)

            # Close button
            ttk.Button(actions_frame, text="Close", command=dialog.destroy).pack(side='right', padx=5)

        except Exception as e:
            messagebox.showerror("Error", f"Failed to show equipment PM actions: {str(e)}")
            traceback.print_exc()

    def schedule_equipment_pm_dialog(self, bfm_no, equipment_data, parent_dialog):
        """Dialog to schedule a PM for specific equipment"""
        try:
            # Create schedule dialog
            schedule_dialog = tk.Toplevel(parent_dialog)
            schedule_dialog.title(f"Schedule PM - {bfm_no}")
            schedule_dialog.geometry("500x400")
            schedule_dialog.transient(parent_dialog)
            schedule_dialog.grab_set()

            # Form frame
            form_frame = ttk.LabelFrame(schedule_dialog, text="PM Scheduling", padding=15)
            form_frame.pack(fill='both', expand=True, padx=10, pady=10)

            # PM Type selection
            ttk.Label(form_frame, text="PM Type:", font=('Arial', 10, 'bold')).grid(
                row=0, column=0, sticky='w', pady=10)

            pm_type_var = tk.StringVar()
            pm_types = []

            # Determine available PM types based on equipment configuration
            (sap_no, bfm, description, tool_id, location, master_lin, weekly_pm, monthly_pm,
             six_month_pm, annual_pm, *_) = equipment_data

            if weekly_pm:
                pm_types.append('Weekly')
            if monthly_pm:
                pm_types.append('Monthly')
            if six_month_pm:
                pm_types.append('Six Month')
            if annual_pm:
                pm_types.append('Annual')

            if not pm_types:
                ttk.Label(form_frame, text="No PM types configured for this equipment",
                         foreground='red').grid(row=0, column=1, sticky='w', padx=10)
            else:
                pm_type_combo = ttk.Combobox(form_frame, textvariable=pm_type_var,
                                             values=pm_types, state='readonly', width=20)
                pm_type_combo.grid(row=0, column=1, sticky='w', padx=10)
                pm_type_combo.current(0)

            # Week Start Date
            ttk.Label(form_frame, text="Week Start Date:", font=('Arial', 10, 'bold')).grid(
                row=1, column=0, sticky='w', pady=10)

            week_start_var = tk.StringVar()
            # Calculate next Monday
            today = datetime.now()
            days_ahead = 0 - today.weekday()  # Monday is 0
            if days_ahead <= 0:
                days_ahead += 7
            next_monday = today + timedelta(days=days_ahead)
            week_start_var.set(next_monday.strftime('%Y-%m-%d'))

            ttk.Entry(form_frame, textvariable=week_start_var, width=20).grid(
                row=1, column=1, sticky='w', padx=10)

            # Scheduled Date
            ttk.Label(form_frame, text="Scheduled Date:", font=('Arial', 10, 'bold')).grid(
                row=2, column=0, sticky='w', pady=10)

            scheduled_date_var = tk.StringVar()
            scheduled_date_var.set(next_monday.strftime('%Y-%m-%d'))

            ttk.Entry(form_frame, textvariable=scheduled_date_var, width=20).grid(
                row=2, column=1, sticky='w', padx=10)

            # Technician assignment
            ttk.Label(form_frame, text="Assign Technician:", font=('Arial', 10, 'bold')).grid(
                row=3, column=0, sticky='w', pady=10)

            tech_var = tk.StringVar()
            tech_combo = ttk.Combobox(form_frame, textvariable=tech_var,
                                     values=self.technicians, state='readonly', width=20)
            tech_combo.grid(row=3, column=1, sticky='w', padx=10)
            if self.technicians:
                tech_combo.current(0)

            # Buttons
            button_frame = ttk.Frame(schedule_dialog, padding=10)
            button_frame.pack(fill='x', padx=10, pady=10)

            def save_schedule():
                if not pm_types:
                    messagebox.showerror("Error", "No PM types configured for this equipment")
                    return

                pm_type = pm_type_var.get()
                week_start = week_start_var.get()
                scheduled_date = scheduled_date_var.get()
                technician = tech_var.get()

                if not all([pm_type, week_start, scheduled_date, technician]):
                    messagebox.showwarning("Warning", "Please fill in all fields")
                    return

                try:
                    cursor = self.conn.cursor()

                    # Insert into weekly_pm_schedules
                    cursor.execute('''
                        INSERT INTO weekly_pm_schedules
                        (bfm_equipment_no, pm_type, week_start_date, scheduled_date,
                         assigned_technician, status, created_date)
                        VALUES (%s, %s, %s, %s, %s, %s, %s)
                    ''', (bfm_no, pm_type, week_start, scheduled_date, technician,
                          'Scheduled', datetime.now()))

                    self.conn.commit()

                    messagebox.showinfo("Success",
                                       f"PM scheduled for {bfm_no}\n"
                                       f"Type: {pm_type}\n"
                                       f"Date: {scheduled_date}\n"
                                       f"Technician: {technician}")

                    schedule_dialog.destroy()

                except Exception as e:
                    self.conn.rollback()
                    messagebox.showerror("Error", f"Failed to schedule PM: {str(e)}")
                    traceback.print_exc()

            ttk.Button(button_frame, text="Save Schedule", command=save_schedule).pack(
                side='left', padx=5)
            ttk.Button(button_frame, text="Cancel", command=schedule_dialog.destroy).pack(
                side='right', padx=5)

        except Exception as e:
            messagebox.showerror("Error", f"Failed to create schedule dialog: {str(e)}")
            traceback.print_exc()

    def show_pm_type_selection_dialog(self, bfm_no, equipment_data, available_pm_types):
        """Show dialog to select which PM type to print"""
        dialog = tk.Toplevel(self.root)
        dialog.title("Select PM Type")
        dialog.geometry("400x300")
        dialog.transient(self.root)
        dialog.grab_set()

        # Center the dialog
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (dialog.winfo_width() // 2)
        y = (dialog.winfo_screenheight() // 2) - (dialog.winfo_height() // 2)
        dialog.geometry(f"+{x}+{y}")

        # Main frame
        main_frame = ttk.Frame(dialog, padding="20")
        main_frame.pack(fill='both', expand=True)

        # Title
        ttk.Label(main_frame, text="Select PM Type to Print",
                 font=('Helvetica', 12, 'bold')).pack(pady=(0, 20))

        # Equipment info
        (sap_no, bfm, description, *_) = equipment_data
        info_text = f"Equipment: {bfm}\n{description}"
        ttk.Label(main_frame, text=info_text, wraplength=350).pack(pady=(0, 20))

        # PM type selection
        selected_type = tk.StringVar(value=available_pm_types[0])

        for pm_type in available_pm_types:
            ttk.Radiobutton(main_frame, text=f"{pm_type} PM",
                          variable=selected_type, value=pm_type).pack(anchor='w', pady=5)

        # Buttons frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(side='bottom', fill='x', pady=(20, 0))

        def on_print():
            dialog.destroy()
            self.print_equipment_pm_form(bfm_no, equipment_data, selected_type.get())

        def on_cancel():
            dialog.destroy()

        ttk.Button(button_frame, text="Print", command=on_print).pack(side='left', padx=5)
        ttk.Button(button_frame, text="Cancel", command=on_cancel).pack(side='left', padx=5)

        # Bind escape key to cancel
        dialog.bind('<Escape>', lambda e: on_cancel())

    def print_equipment_pm_form(self, bfm_no, equipment_data, selected_pm_type=None):
        """Generate and print PM form for specific equipment using standard format"""
        try:
            cursor = self.conn.cursor()

            # Unpack equipment data
            (sap_no, bfm, description, tool_id, location, master_lin, monthly_pm,
             six_month_pm, annual_pm, *_) = equipment_data

            # If multiple PM types exist and none selected, show selection dialog
            if selected_pm_type is None:
                available_pm_types = []
                if monthly_pm:
                    available_pm_types.append('Monthly')
                if six_month_pm:
                    available_pm_types.append('Six Month')
                if annual_pm:
                    available_pm_types.append('Annual')

                if len(available_pm_types) > 1:
                    # Show selection dialog
                    self.show_pm_type_selection_dialog(bfm_no, equipment_data, available_pm_types)
                    return
                elif len(available_pm_types) == 1:
                    selected_pm_type = available_pm_types[0]
                else:
                    messagebox.showwarning("No PM Types", "This equipment has no PM types configured.")
                    return

            # Ask user where to save the PM form
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            default_filename = f"PM_Form_{bfm_no}_{selected_pm_type}_{timestamp}.pdf"

            file_path = filedialog.asksaveasfilename(
                title="Save PM Form",
                initialdir=os.path.expanduser("~/Documents"),
                initialfile=default_filename,
                defaultextension=".pdf",
                filetypes=[("PDF files", "*.pdf"), ("All files", "*.*")]
            )

            if not file_path:
                return  # User cancelled

            # Create assignment tuple in the format expected by create_pm_forms_pdf
            # Format: (bfm_no, sap_no, description, tool_id, location, master_lin, pm_type, scheduled_date, technician)
            scheduled_date = datetime.now().strftime('%Y-%m-%d')
            assignment = (bfm_no, sap_no, description, tool_id, location, master_lin, selected_pm_type, scheduled_date, 'To Be Assigned')

            # Use the standard PM form creation function
            self.create_pm_forms_pdf(file_path, 'To Be Assigned', [assignment])

            messagebox.showinfo("Success", f"PM form generated: {file_path}")
            self.update_status(f"PM form created for {bfm_no}")

            # Open the PDF
            import subprocess
            import platform
            if platform.system() == 'Darwin':  # macOS
                subprocess.call(('open', file_path))
            elif platform.system() == 'Windows':
                os.startfile(file_path)
            else:  # Linux
                subprocess.call(('xdg-open', file_path))

        except Exception as e:
            messagebox.showerror("Error", f"Failed to generate PM form: {str(e)}")
            traceback.print_exc()

    def export_equipment_list(self):
        """Export equipment list to CSV"""
        try:
            file_path = filedialog.asksaveasfilename(
                title="Export Equipment List",
                defaultextension=".csv",
                filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
            )
        
            if file_path:
                cursor = self.conn.cursor()
                # SELECT specific columns instead of SELECT *
                cursor.execute('''
                    SELECT id, sap_material_no, bfm_equipment_no, description, 
                           tool_id_drawing_no, location, master_lin, monthly_pm, 
                           six_month_pm, annual_pm, last_monthly_pm, last_six_month_pm, 
                           last_annual_pm, next_monthly_pm, next_six_month_pm, 
                           next_annual_pm, status, created_date, updated_date
                    FROM equipment 
                    ORDER BY bfm_equipment_no
                ''')
                equipment_data = cursor.fetchall()
            
                # Create DataFrame
                columns = ['ID', 'SAP Material No', 'BFM Equipment No', 'Description', 
                          'Tool ID/Drawing No', 'Location', 'Master LIN', 'Monthly PM', 
                          'Six Month PM', 'Annual PM', 'Last Monthly PM', 'Last Six Month PM', 
                          'Last Annual PM', 'Next Monthly PM', 'Next Six Month PM', 
                          'Next Annual PM', 'Status', 'Created Date', 'Updated Date']
            
                df = pd.DataFrame(equipment_data, columns=columns)
                df.to_csv(file_path, index=False)
            
                messagebox.showinfo("Success", f"Equipment list exported to {file_path}")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export equipment list: {str(e)}")
    
    # REMOVED: load_equipment_data() and ensure_equipment_loaded()
    # These methods cached equipment data in memory, which is no longer needed
    # Equipment filtering now uses direct SQL queries for better performance

    
    def generate_weekly_assignments(self):
        """
        NEW SOLID PM assignment generation - prevents duplicates
        """
        try:
            # Validate that technicians are configured
            if not hasattr(self, 'technicians') or not self.technicians or len(self.technicians) == 0:
                messagebox.showerror(
                    "Configuration Error",
                    "No technicians configured in the system.\n\n"
                    "Please contact your system administrator."
                )
                return

            # Get excluded technicians
            excluded_techs = self.get_excluded_technicians()

            # Filter technicians to exclude selected ones
            available_technicians = [tech for tech in self.technicians if tech not in excluded_techs]

            # Validate that at least one technician is available
            if len(available_technicians) == 0:
                messagebox.showerror(
                    "Configuration Error",
                    "All technicians are excluded from scheduling.\n\n"
                    "Please ensure at least one technician is available for PM assignment."
                )
                return

            # Show info if technicians are excluded
            if excluded_techs:
                excluded_names = ", ".join(excluded_techs)
                messagebox.showinfo(
                    "Technician Exclusions",
                    f"The following technician(s) will be excluded from this week's schedule:\n\n"
                    f"{excluded_names}\n\n"
                    f"PMs will be distributed among the remaining {len(available_technicians)} technician(s)."
                )

            # Create the new PM scheduling service with filtered technicians
            pm_service = PMSchedulingService(self.conn, available_technicians, self.root)

            # Get the week start date
            week_start = self.week_start_var.get()

            # Get the weekly PM target from the UI (user-configurable)
            weekly_target = self.weekly_pm_target_var.get()

            # Generate the schedule
            result = pm_service.generate_weekly_schedule(week_start, weekly_target)

            if result['success']:
                # Check if there's a special message (like no equipment or no assignments)
                if 'message' in result and result['total_assignments'] == 0:
                    messagebox.showinfo(
                        "Scheduling Complete",
                        f"{result['message']}\n\n"
                        f"Week: {week_start}"
                    )
                else:
                    messagebox.showinfo(
                        "NEW SYSTEM - Scheduling Complete",
                        f"Generated {result['total_assignments']} PM assignments for week {week_start}\n\n"
                        f"Unique assets: {result['unique_assets']}\n\n"
                        f"This new system prevents duplicate assignments!"
                    )

                # Refresh displays
                self.refresh_technician_schedules()
                self.update_status(f"NEW SYSTEM: Generated {result['total_assignments']} PM assignments")
            else:
                messagebox.showerror("NEW SYSTEM Error", f"Failed to generate assignments: {result['error']}")

        except Exception as e:
            messagebox.showerror("NEW SYSTEM Error", f"Failed to generate assignments: {str(e)}")
            import traceback
            traceback.print_exc()

    def populate_technician_exclusion_list(self):
        """Populate the exclusion listbox with all technicians"""
        if hasattr(self, 'excluded_technicians_listbox'):
            self.excluded_technicians_listbox.delete(0, tk.END)
            for tech in self.technicians:
                self.excluded_technicians_listbox.insert(tk.END, tech)

    def clear_all_exclusions(self):
        """Clear all technician exclusions"""
        if hasattr(self, 'excluded_technicians_listbox'):
            self.excluded_technicians_listbox.selection_clear(0, tk.END)

    def get_excluded_technicians(self):
        """Get list of excluded technicians based on listbox selection"""
        if not hasattr(self, 'excluded_technicians_listbox'):
            return []

        excluded = []
        selected_indices = self.excluded_technicians_listbox.curselection()
        for idx in selected_indices:
            excluded.append(self.excluded_technicians_listbox.get(idx))
        return excluded


    def refresh_technician_schedules(self):
        """Refresh all technician schedule displays - OPTIMIZED: Single query instead of N queries"""
        week_start = self.week_start_var.get()

        # Clear all existing items first
        for technician, tree in self.technician_trees.items():
            for item in tree.get_children():
                tree.delete(item)

        # PERFORMANCE OPTIMIZATION: Fetch all schedules in ONE query instead of N separate queries
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT ws.bfm_equipment_no, e.description, ws.pm_type, ws.scheduled_date,
                   ws.status, ws.assigned_technician
            FROM weekly_pm_schedules ws
            JOIN equipment e ON ws.bfm_equipment_no = e.bfm_equipment_no
            WHERE ws.week_start_date = %s
            ORDER BY ws.assigned_technician, ws.scheduled_date
        ''', (week_start,))

        all_assignments = cursor.fetchall()

        # Group assignments by technician and populate trees
        for idx, assignment in enumerate(all_assignments):
            bfm_no, description, pm_type, scheduled_date, status, technician = assignment

            # Only add to tree if technician exists in our trees dict
            if technician in self.technician_trees:
                tree = self.technician_trees[technician]
                tree.insert('', 'end', values=(bfm_no, description, pm_type, scheduled_date, status))

            # Yield to event loop every 20 items to keep UI responsive
            if idx % 20 == 0:
                self.root.update_idletasks()

        # Final yield to event loop
        self.root.update_idletasks()

    def mark_pm_cannot_find(self):
        """Mark a selected PM as Cannot Find from the scheduling tab"""
        # Get the current technician tab
        current_tab = self.technician_notebook.select()
        if not current_tab:
            messagebox.showwarning("Warning", "No technician tab selected")
            return

        # Get the technician name from the tab
        tab_index = self.technician_notebook.index(current_tab)
        technician_name = self.technician_notebook.tab(tab_index, "text")

        # Get the selected PM from the tree
        if technician_name not in self.technician_trees:
            messagebox.showwarning("Warning", "Invalid technician selection")
            return

        tree = self.technician_trees[technician_name]
        selected = tree.selection()

        if not selected:
            messagebox.showwarning("Warning", "Please select a PM to mark as Cannot Find")
            return

        # Get the PM details
        item = tree.item(selected[0])
        values = item['values']
        bfm_no = values[0]
        description = values[1] if len(values) > 1 else "N/A"
        pm_type = values[2] if len(values) > 2 else "N/A"
        scheduled_date = values[3] if len(values) > 3 else "N/A"
        current_status = values[4] if len(values) > 4 else "N/A"

        # Check if already marked as Cannot Find
        if current_status == "Cannot Find":
            messagebox.showinfo("Info", f"PM for {bfm_no} is already marked as Cannot Find")
            return

        # Confirm action
        confirm_msg = (f"Mark PM as Cannot Find?\n\n"
                      f"BFM Equipment No: {bfm_no}\n"
                      f"Description: {description}\n"
                      f"PM Type: {pm_type}\n"
                      f"Scheduled Date: {scheduled_date}\n"
                      f"Technician: {technician_name}\n\n"
                      f"This will:\n"
                      f" Update PM status to 'Cannot Find'\n"
                      f" Add asset to Cannot Find list\n"
                      f" Update equipment status to 'Cannot Find'\n\n"
                      f"Continue?")

        result = messagebox.askyesno("Confirm Cannot Find", confirm_msg)

        if not result:
            return

        # Prompt for notes
        notes_dialog = tk.Toplevel(self.root)
        notes_dialog.title("Cannot Find Notes")
        notes_dialog.geometry("400x200")
        notes_dialog.transient(self.root)
        notes_dialog.grab_set()

        ttk.Label(notes_dialog, text="Please provide details (optional):").pack(pady=10)
        notes_text = tk.Text(notes_dialog, width=50, height=6)
        notes_text.pack(pady=10, padx=10)
        notes_text.insert('1.0', "Asset could not be located during scheduled PM")

        def save_cannot_find():
            notes = notes_text.get("1.0", tk.END).strip()
            try:
                cursor = self.conn.cursor()
                today = datetime.now().strftime('%Y-%m-%d')

                # Get equipment info
                cursor.execute('SELECT description, location FROM equipment WHERE bfm_equipment_no = %s', (bfm_no,))
                equipment_info = cursor.fetchone()
                if equipment_info:
                    eq_description, location = equipment_info
                else:
                    eq_description = description
                    location = "Unknown"

                # Check if already in cannot_find_assets
                cursor.execute('SELECT bfm_equipment_no FROM cannot_find_assets WHERE bfm_equipment_no = %s', (bfm_no,))
                existing = cursor.fetchone()

                if existing:
                    # Update existing record
                    cursor.execute('''
                        UPDATE cannot_find_assets
                        SET status = 'Missing',
                            technician_name = %s,
                            reported_date = %s,
                            notes = %s,
                            updated_date = CURRENT_TIMESTAMP
                        WHERE bfm_equipment_no = %s
                    ''', (technician_name, today, notes, bfm_no))
                else:
                    # Insert new record
                    cursor.execute('''
                        INSERT INTO cannot_find_assets
                        (bfm_equipment_no, description, location, technician_name, reported_date, status, notes)
                        VALUES (%s, %s, %s, %s, %s, 'Missing', %s)
                    ''', (bfm_no, eq_description, location, technician_name, today, notes))

                # Update equipment status
                cursor.execute('UPDATE equipment SET status = %s WHERE bfm_equipment_no = %s',
                             ('Cannot Find', bfm_no))

                # Update PM schedule status to "Cannot Find"
                week_start = self.week_start_var.get()
                cursor.execute('''
                    UPDATE weekly_pm_schedules
                    SET status = 'Cannot Find',
                        completion_date = %s,
                        notes = %s
                    WHERE bfm_equipment_no = %s
                      AND assigned_technician = %s
                      AND week_start_date = %s
                      AND pm_type = %s
                      AND status = 'Scheduled'
                ''', (today, notes, bfm_no, technician_name, week_start, pm_type))

                self.conn.commit()

                messagebox.showinfo("Success", f"PM for {bfm_no} marked as Cannot Find")

                # Refresh displays
                self.refresh_technician_schedules()
                if hasattr(self, 'load_cannot_find_assets'):
                    self.load_cannot_find_assets()
                if hasattr(self, 'update_equipment_statistics'):
                    self.update_equipment_statistics()

                notes_dialog.destroy()

            except Exception as e:
                self.conn.rollback()
                messagebox.showerror("Error", f"Failed to mark PM as Cannot Find: {str(e)}")
                print(f"Error details: {e}")

        ttk.Button(notes_dialog, text="Save", command=save_cannot_find).pack(side='left', padx=60, pady=10)
        ttk.Button(notes_dialog, text="Cancel", command=notes_dialog.destroy).pack(side='left', pady=10)

    def print_weekly_pm_forms(self):
        """Generate and print PM forms for the week"""
        try:
            week_start = self.week_start_var.get()
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')

            # Ask user where to save PM forms
            forms_dir = filedialog.askdirectory(
                title="Select folder to save PM Forms",
                initialdir=os.path.expanduser("~/Documents")
            )

            if not forms_dir:
                return  # User cancelled

            # Create subdirectory for this week's forms
            week_dir = os.path.join(forms_dir, f"PM_Forms_Week_{week_start}_{timestamp}")
            os.makedirs(week_dir, exist_ok=True)
        
            cursor = self.conn.cursor()
        
            # Generate forms for each technician
            for technician in self.technicians:
                cursor.execute('''
                    SELECT ws.bfm_equipment_no, e.sap_material_no, e.description, e.tool_id_drawing_no,
                        e.location, e.master_lin, ws.pm_type, ws.scheduled_date, ws.assigned_technician
                    FROM weekly_pm_schedules ws
                    JOIN equipment e ON ws.bfm_equipment_no = e.bfm_equipment_no
                    WHERE ws.assigned_technician = %s AND ws.week_start_date = %s
                    ORDER BY ws.scheduled_date
                ''', (technician, week_start))
            
                assignments = cursor.fetchall()
            
                if assignments:
                    # Create PDF for this technician
                    filename = os.path.join(week_dir, f"{technician.replace(' ', '_')}_PM_Forms.pdf")
                    self.create_pm_forms_pdf(filename, technician, assignments)

            messagebox.showinfo("Success", f"PM forms generated in directory: {week_dir}")
            self.update_status(f"PM forms generated for week {week_start}")
        
        except Exception as e:
            messagebox.showerror("Error", f"Failed to generate PM forms: {str(e)}")
    
    def create_pm_forms_pdf(self, filename, technician, assignments):
        """Create PDF with PM forms for a technician - ENHANCED WITH CUSTOM TEMPLATES"""
        try:
            doc = SimpleDocTemplate(filename, pagesize=letter,
                                rightMargin=36, leftMargin=36,
                                topMargin=36, bottomMargin=36)

            styles = getSampleStyleSheet()
            story = []

        # Custom styles for better text wrapping
            cell_style = ParagraphStyle(
                'CellStyle',
                parent=styles['Normal'],
                fontSize=8,
                leading=10,
                wordWrap='LTR'
            )

            header_cell_style = ParagraphStyle(
                'HeaderCellStyle',
                parent=styles['Normal'],
                fontSize=9,
                fontName='Helvetica-Bold',
                leading=11,
                wordWrap='LTR'
            )

            company_style = ParagraphStyle(
                'CompanyStyle',
                parent=styles['Heading1'],
                fontSize=14,
                fontName='Helvetica-Bold',
                alignment=1,
                textColor=colors.darkblue
            )

            print(f"DEBUG: Creating PDF for {technician}")
            print(f"DEBUG: Total assignments: {len(assignments)}")

            for i, assignment in enumerate(assignments):
                print(f"DEBUG: Processing assignment {i}: {assignment}")
        
            # Safety check for assignment data
                if not assignment or len(assignment) < 8:
                    print(f"DEBUG: Skipping invalid assignment {i}")
                    continue

            # Extract variables from assignment
                bfm_no, sap_no, description, tool_id, location, master_lin, pm_type, scheduled_date, assigned_tech = assignment
        
            # Add None checks for all variables
                bfm_no = bfm_no or ''
                sap_no = sap_no or ''
                description = description or ''
                tool_id = tool_id or ''
                location = location or ''
                master_lin = master_lin or ''
                pm_type = pm_type or 'Monthly'
                scheduled_date = scheduled_date or ''
                assigned_tech = assigned_tech or technician
        
                print(f"DEBUG: Processing {bfm_no} - {pm_type}")

            # =================== LOGO SECTION ===================
            # Dynamic logo path that works on any computer
                script_dir = os.path.dirname(os.path.abspath(__file__))
                # Try multiple possible logo locations
                possible_logo_paths = [
                    os.path.join(script_dir, "ait_Logo.png"),
                    os.path.join(script_dir, "img", "ait_logo.png"),
                    os.path.join(script_dir, "img", "ait_Logo.png"),
                    os.path.join(script_dir, "ait_logo.png")
                ]

                logo_path = None
                for path in possible_logo_paths:
                    if os.path.exists(path):
                        logo_path = path
                        break

                try:
                    if logo_path and os.path.exists(logo_path):
                        # Create centered logo
                        logo_image = Image(logo_path, width=4*inch, height=1.2*inch)

                        # Center the logo in a table
                        logo_data = [[logo_image]]
                        logo_table = Table(logo_data, colWidths=[7*inch])
                        logo_table.setStyle(TableStyle([
                            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                            ('TOPPADDING', (0, 0), (-1, -1), 10),
                            ('BOTTOMPADDING', (0, 0), (-1, -1), 15),
                        ]))

                        story.append(logo_table)
                    else:
                        print(f"Logo file not found at: {logo_path}")
                        # Fallback to text if logo file not found
                        story.append(Paragraph("AIT - BUILDING THE FUTURE OF AEROSPACE", company_style))
                        story.append(Spacer(1, 15))

                except Exception as e:
                    print(f"Could not load logo: {e}")
                    # Fallback to text header
                    story.append(Paragraph("AIT - BUILDING THE FUTURE OF AEROSPACE", company_style))
                    story.append(Spacer(1, 15))

            # =================== FETCH CUSTOM PM TEMPLATE ===================
            # Retrieve custom template data BEFORE building the equipment table
                checklist_items = []
                estimated_hours = 1.0
                special_instructions = None
                safety_notes = None

                cursor = self.conn.cursor()
                cursor.execute('''
                    SELECT checklist_items, estimated_hours, special_instructions, safety_notes
                    FROM pm_templates
                    WHERE bfm_equipment_no = %s AND pm_type = %s
                    ORDER BY updated_date DESC LIMIT 1
                ''', (bfm_no, pm_type))

                template_result = cursor.fetchone()

                if template_result and template_result[0]:
                    try:
                        checklist_items = json.loads(template_result[0])
                        estimated_hours = template_result[1] or 1.0
                        special_instructions = template_result[2]
                        safety_notes = template_result[3]
                        print(f"DEBUG: Using custom template for {bfm_no} - {pm_type} with {len(checklist_items)} items, {estimated_hours}h estimated")
                    except Exception as e:
                        print(f"DEBUG: Error loading custom template: {e}")
                        checklist_items = []

                # Use default checklist if no custom template
                if not checklist_items:
                    print(f"DEBUG: No custom template found for {bfm_no} - {pm_type}, using default checklist")
                    checklist_items = [
                        "Special Equipment Used (List):",
                        "Validate your maintenance with Date / Stamp / Hours",
                        "Refer to drawing when performing maintenance",
                        "Make sure all instruments are properly calibrated",
                        "Make sure tool is properly identified",
                        "Make sure all mobile mechanisms move fluidly",
                        "Visually inspect the welds",
                        "Take note of any anomaly or defect (create a CM if needed)",
                        "Check all screws. Tighten if needed.",
                        "Check the pins for wear",
                        "Make sure all tooling is secured to the equipment with cable",
                        "Ensure all tags (BFM and SAP) are applied and securely fastened",
                        "All documentation are picked up from work area",
                        "All parts and tools have been picked up",
                        "Workspace has been cleaned up",
                        "Dry runs have been performed (tests, restarts, etc.)",
                        "Ensure that AIT Sticker is applied"
                    ]

            # =================== FETCH EQUIPMENT PHOTOS ===================
                # Retrieve equipment photos from database
                cursor.execute('''
                    SELECT picture_1_data, picture_2_data
                    FROM equipment
                    WHERE bfm_equipment_no = %s
                ''', (bfm_no,))

                photo_result = cursor.fetchone()
                picture_1_data = None
                picture_2_data = None

                if photo_result:
                    picture_1_data = photo_result[0]
                    picture_2_data = photo_result[1]
                    if picture_1_data or picture_2_data:
                        print(f"DEBUG: Equipment {bfm_no} has photos - Pic1: {'Yes' if picture_1_data else 'No'}, Pic2: {'Yes' if picture_2_data else 'No'}")

            # =================== EQUIPMENT INFORMATION TABLE ===================
                equipment_data = [
                    [
                        Paragraph('(SAP) Material Number:', header_cell_style), 
                        Paragraph(str(sap_no), cell_style), 
                        Paragraph('Tool ID / Drawing Number:', header_cell_style), 
                        Paragraph(str(tool_id), cell_style)
                    ],
                    [
                        Paragraph('(BFM) Equipment Number:', header_cell_style), 
                        Paragraph(str(bfm_no), cell_style), 
                        Paragraph('Description of Equipment:', header_cell_style), 
                        Paragraph(str(description), cell_style)
                    ],
                    [
                        Paragraph('Date of Last PM:', header_cell_style), 
                        Paragraph('', cell_style), 
                        Paragraph('Location of Equipment:', header_cell_style), 
                        Paragraph(str(location), cell_style)
                    ],
                    [
                        Paragraph('Maintenance Technician:', header_cell_style), 
                        Paragraph(str(assigned_tech), cell_style), 
                        Paragraph('PM Cycle:', header_cell_style), 
                        Paragraph(str(pm_type), cell_style)
                    ],
                    [
                        Paragraph('Estimated Hours:', header_cell_style),
                        Paragraph(f'{estimated_hours:.1f}h', cell_style),
                        Paragraph('Date of PM Completion:', header_cell_style),
                        Paragraph('', cell_style)
                    ],
                    [
                        Paragraph('Signature of Technician:', header_cell_style), 
                        Paragraph('', cell_style), 
                        Paragraph('', cell_style), 
                        Paragraph('', cell_style)
                    ],
                    [
                        Paragraph('Safety: Always be aware of both Airbus and AIT safety policies and ensure safety policies are followed.', cell_style), 
                        Paragraph('', cell_style), 
                        Paragraph('', cell_style), 
                        Paragraph('', cell_style)
                    ],
                    [
                        Paragraph(f'Printed: {datetime.now().strftime("%m/%d/%Y")}', cell_style), 
                        '', '', ''
                    ]
                ]
        
                equipment_table = Table(equipment_data, colWidths=[1.8*inch, 1.7*inch, 1.8*inch, 1.7*inch])
                equipment_table.setStyle(TableStyle([
                    ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                    ('FONTSIZE', (0, 0), (-1, -1), 8),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black),
                    ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                    ('LEFTPADDING', (0, 0), (-1, -1), 3),
                    ('RIGHTPADDING', (0, 0), (-1, -1), 3),
                    ('TOPPADDING', (0, 0), (-1, -1), 3),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
                    ('SPAN', (0, -2), (-1, -2)),  # Safety spans all columns
                    ('SPAN', (0, -1), (-1, -1)),  # Printed date spans all columns
                ]))
        
                story.append(equipment_table)
                story.append(Spacer(1, 15))

            # =================== EQUIPMENT PHOTOS SECTION ===================
                # Display equipment photos if available
                if picture_1_data or picture_2_data:
                    try:
                        photo_elements = []

                        # Add section header
                        photo_header_style = ParagraphStyle(
                            'PhotoHeader',
                            parent=styles['Heading2'],
                            fontSize=11,
                            fontName='Helvetica-Bold',
                            alignment=1,  # Center
                            textColor=colors.darkblue,
                            spaceAfter=10
                        )
                        story.append(Paragraph("EQUIPMENT PHOTOS", photo_header_style))
                        story.append(Spacer(1, 10))

                        # Process photos
                        photos_to_display = []

                        if picture_1_data:
                            try:
                                from PIL import Image as PILImage
                                import io

                                # Convert binary data to PIL Image
                                img_stream = io.BytesIO(picture_1_data)
                                pil_img = PILImage.open(img_stream)

                                # Resize if needed (max width 3 inches, max height 2.5 inches)
                                max_width = 3 * inch
                                max_height = 2.5 * inch

                                # Calculate aspect ratio
                                img_width, img_height = pil_img.size
                                aspect = img_width / img_height

                                if img_width > max_width or img_height > max_height:
                                    if aspect > 1:  # Wider than tall
                                        new_width = max_width
                                        new_height = max_width / aspect
                                    else:  # Taller than wide
                                        new_height = max_height
                                        new_width = max_height * aspect
                                else:
                                    new_width = img_width
                                    new_height = img_height

                                # Save to temp BytesIO for ReportLab
                                temp_io = io.BytesIO(picture_1_data)

                                # Create ReportLab Image
                                from reportlab.platypus import Image as RLImage
                                photo1 = RLImage(temp_io, width=new_width, height=new_height)
                                photos_to_display.append(photo1)

                                print(f"DEBUG: Added Photo 1 to PDF ({new_width/inch:.2f}\" x {new_height/inch:.2f}\")")
                            except Exception as e:
                                print(f"WARNING: Could not process Picture 1: {e}")

                        if picture_2_data:
                            try:
                                from PIL import Image as PILImage
                                import io

                                # Convert binary data to PIL Image
                                img_stream = io.BytesIO(picture_2_data)
                                pil_img = PILImage.open(img_stream)

                                # Resize if needed
                                max_width = 3 * inch
                                max_height = 2.5 * inch

                                img_width, img_height = pil_img.size
                                aspect = img_width / img_height

                                if img_width > max_width or img_height > max_height:
                                    if aspect > 1:
                                        new_width = max_width
                                        new_height = max_width / aspect
                                    else:
                                        new_height = max_height
                                        new_width = max_height * aspect
                                else:
                                    new_width = img_width
                                    new_height = img_height

                                temp_io = io.BytesIO(picture_2_data)

                                from reportlab.platypus import Image as RLImage
                                photo2 = RLImage(temp_io, width=new_width, height=new_height)
                                photos_to_display.append(photo2)

                                print(f"DEBUG: Added Photo 2 to PDF ({new_width/inch:.2f}\" x {new_height/inch:.2f}\")")
                            except Exception as e:
                                print(f"WARNING: Could not process Picture 2: {e}")

                        # Display photos in a table (side by side if 2 photos, centered if 1 photo)
                        if len(photos_to_display) == 2:
                            # Two photos side by side
                            photo_table_data = [[photos_to_display[0], photos_to_display[1]]]
                            photo_table = Table(photo_table_data, colWidths=[3.5*inch, 3.5*inch])
                            photo_table.setStyle(TableStyle([
                                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                            ]))
                            story.append(photo_table)
                        elif len(photos_to_display) == 1:
                            # Single photo centered
                            photo_table_data = [[photos_to_display[0]]]
                            photo_table = Table(photo_table_data, colWidths=[7*inch])
                            photo_table.setStyle(TableStyle([
                                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                            ]))
                            story.append(photo_table)

                        story.append(Spacer(1, 15))

                    except Exception as e:
                        print(f"WARNING: Error displaying equipment photos: {e}")
                        # Continue with PDF generation even if photos fail

            # =================== PM CHECKLIST TABLE ===================
                checklist_data = [
                    [
                        Paragraph('', header_cell_style), 
                        Paragraph('PM CHECKLIST:', header_cell_style), 
                        Paragraph('', header_cell_style), 
                        Paragraph('Complete', header_cell_style), 
                        Paragraph('Labor Time', header_cell_style)
                    ]
                ]
        
                # Add checklist items
                for idx, item in enumerate(checklist_items, 1):
                    checklist_data.append([
                        Paragraph(str(idx), cell_style), 
                        Paragraph(item, cell_style), 
                        Paragraph('', cell_style), 
                        Paragraph('', cell_style), 
                        Paragraph('', cell_style)
                    ])
        
                checklist_table = Table(checklist_data, colWidths=[0.3*inch, 3.5*inch, 1.5*inch, 0.8*inch, 0.9*inch])
                checklist_table.setStyle(TableStyle([
                    ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                    ('FONTSIZE', (0, 0), (-1, -1), 8),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black),
                    ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                    ('LEFTPADDING', (0, 0), (-1, -1), 3),
                    ('RIGHTPADDING', (0, 0), (-1, -1), 3),
                    ('TOPPADDING', (0, 0), (-1, -1), 3),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
                    ('SPAN', (1, 0), (2, 0)),  # PM CHECKLIST spans 2 columns
                ]))
        
                story.append(checklist_table)
                story.append(Spacer(1, 15))

            # =================== SPECIAL INSTRUCTIONS & SAFETY NOTES ===================
            # Add special instructions from custom template if available
                if special_instructions and special_instructions.strip():
                    instructions_style = ParagraphStyle(
                        'InstructionsStyle',
                        parent=styles['Normal'],
                        fontSize=9,
                        leading=11,
                        textColor=colors.darkblue,
                        fontName='Helvetica-Bold'
                    )
                    content_style = ParagraphStyle(
                        'ContentStyle',
                        parent=styles['Normal'],
                        fontSize=8,
                        leading=10
                    )

                    story.append(Paragraph("SPECIAL INSTRUCTIONS:", instructions_style))
                    story.append(Paragraph(special_instructions, content_style))
                    story.append(Spacer(1, 10))

            # Add safety notes from custom template if available
                if safety_notes and safety_notes.strip():
                    safety_style = ParagraphStyle(
                        'SafetyStyle',
                        parent=styles['Normal'],
                        fontSize=9,
                        leading=11,
                        textColor=colors.red,
                        fontName='Helvetica-Bold'
                    )
                    safety_content_style = ParagraphStyle(
                        'SafetyContentStyle',
                        parent=styles['Normal'],
                        fontSize=8,
                        leading=10,
                        textColor=colors.black
                    )

                    story.append(Paragraph("SAFETY NOTES:", safety_style))
                    story.append(Paragraph(safety_notes, safety_content_style))
                    story.append(Spacer(1, 10))

            # =================== COMPLETION INFORMATION TABLE ===================
                completion_data = [
                    [
                        Paragraph('Notes from Technician:', header_cell_style), 
                        Paragraph('', cell_style), 
                        Paragraph('Next Annual PM Date:', header_cell_style)
                    ],
                    [
                        Paragraph('', cell_style), 
                        Paragraph('', cell_style), 
                        Paragraph('', cell_style)
                    ],
                    [
                        Paragraph('All Data Entered Into System:', header_cell_style), 
                        Paragraph('', cell_style), 
                        Paragraph('Total Time', header_cell_style)
                    ],
                    [
                        Paragraph('Document Name', header_cell_style), 
                        Paragraph('Revision', header_cell_style), 
                        Paragraph('', cell_style)
                    ],
                    [
                        Paragraph('Preventive_Maintenance_Form', cell_style), 
                        Paragraph('A2', cell_style), 
                        Paragraph('', cell_style)
                    ]
                ]

                completion_table = Table(completion_data, colWidths=[2.8*inch, 2.2*inch, 2*inch])
                completion_table.setStyle(TableStyle([
                    ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                    ('FONTSIZE', (0, 0), (-1, -1), 8),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black),
                    ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                    ('LEFTPADDING', (0, 0), (-1, -1), 3),
                    ('RIGHTPADDING', (0, 0), (-1, -1), 3),
                    ('TOPPADDING', (0, 0), (-1, -1), 3),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
                ]))

                story.append(completion_table)
            
                # Add page break after each PM form (except the last one)
                if i < len(assignments) - 1:
                    story.append(PageBreak())

            # Build PDF
            print(f"DEBUG: Building PDF with {len(story)} elements")
            doc.build(story)
            print(f"DEBUG: PDF created successfully: {filename}")

        except Exception as e:
            print(f"Error creating PM forms PDF: {e}")
            import traceback
            traceback.print_exc()
            raise
    
    def export_weekly_schedule(self):
        """Export weekly schedule to Excel"""
        try:
            week_start = self.week_start_var.get()
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"Weekly_PM_Schedule_{week_start}_{timestamp}.xlsx"
            
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT ws.assigned_technician, ws.bfm_equipment_no, e.description, 
                       ws.pm_type, ws.scheduled_date, ws.status
                FROM weekly_pm_schedules ws
                JOIN equipment e ON ws.bfm_equipment_no = e.bfm_equipment_no
                WHERE ws.week_start_date = %s
                ORDER BY ws.assigned_technician, ws.scheduled_date
            ''', (week_start,))
            
            schedule_data = cursor.fetchall()
            
            # Create DataFrame
            df = pd.DataFrame(schedule_data, columns=[
                'Technician', 'BFM Equipment No', 'Description', 'PM Type', 'Scheduled Date', 'Status'
            ])
            
            # Export to Excel
            with pd.ExcelWriter(filename, engine='openpyxl') as writer:
                df.to_excel(writer, sheet_name='Weekly Schedule', index=False)
                
                # Create summary sheet
                summary_data = []
                for tech in self.technicians:
                    tech_count = len(df[df['Technician'] == tech])
                    summary_data.append([tech, tech_count])
                
                summary_df = pd.DataFrame(summary_data, columns=['Technician', 'Assigned PMs'])
                summary_df.to_excel(writer, sheet_name='Summary', index=False)
            
            messagebox.showinfo("Success", f"Weekly schedule exported to {filename}")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export weekly schedule: {str(e)}")
    
    def check_for_conflicts(self):
        """Check if SharePoint database was updated during this session"""
        try:
            if not hasattr(self, 'backup_sync_dir') or not self.backup_sync_dir:
                return False
        
            # Get latest backup in SharePoint
            latest_backup = self.get_latest_sharepoint_backup()
            if not latest_backup:
                return False
        
            backup_path, backup_time = latest_backup
        
            # If backup is newer than our session start, someone else updated it
            if backup_time > self.session_start_time:
                print(f"CHECK: CONFLICT DETECTED!")
                print(f"  Session started: {self.session_start_time}")
                print(f"  Latest backup: {backup_time}")
                print(f"  Someone updated the database during your session!")
                return True
        
            return False
        
        except Exception as e:
            print(f"Error checking for conflicts: {e}")
            return False
    
    def get_latest_sharepoint_backup(self):
        """Get the latest backup file from SharePoint"""
        try:
            backup_files = []
        
            for filename in os.listdir(self.backup_sync_dir):
                if filename.endswith('.db'):
                    filepath = os.path.join(self.backup_sync_dir, filename)
                    modified_time = os.path.getmtime(filepath)
                    backup_files.append((filepath, modified_time))
        
            if not backup_files:
                return None
        
            backup_files.sort(key=lambda x: x[1], reverse=True)
            latest_file, latest_time = backup_files[0]
            return (latest_file, datetime.fromtimestamp(latest_time))
        
        except Exception as e:
            print(f"Error getting latest backup: {e}")
            return None
    
    def show_smart_merge_dialog(self):
        """Show dialog explaining conflict and offering merge options - NOW WITH SCROLLBAR"""
    
        dialog = tk.Toplevel(self.root)
        dialog.title("WARNING: Database Conflict Detected")
        dialog.geometry("750x700")
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Center dialog
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (750 // 2)
        y = (dialog.winfo_screenheight() // 2) - (700 // 2)
        dialog.geometry(f"750x700+{x}+{y}")
        
        result = {"action": "cancel"}
        
        # Main container with scrollbar
        main_canvas = tk.Canvas(dialog)
        scrollbar = ttk.Scrollbar(dialog, orient="vertical", command=main_canvas.yview)
        scrollable_frame = ttk.Frame(main_canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: main_canvas.configure(scrollregion=main_canvas.bbox("all"))
        )
    
        main_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        main_canvas.configure(yscrollcommand=scrollbar.set)

        # Header with warning
        header_frame = ttk.Frame(scrollable_frame, padding=20)
        header_frame.pack(fill='x')

        ttk.Label(header_frame, text="Database Conflict Detected!", 
                font=('Arial', 16, 'bold'), foreground='red').pack()
        ttk.Label(header_frame, text="Team members updated the database while you were working", 
                font=('Arial', 11), foreground='orange').pack(pady=5)

        ttk.Separator(scrollable_frame, orient='horizontal').pack(fill='x', pady=10)

        # Situation explanation
        situation_frame = ttk.LabelFrame(scrollable_frame, text="What Happened", padding=15)
        situation_frame.pack(fill='x', padx=20, pady=10)

        session_duration = datetime.now() - self.session_start_time
        hours, remainder = divmod(int(session_duration.total_seconds()), 3600)
        minutes, _ = divmod(remainder, 60)

        situation_text = f"""
    You opened the program at: {self.session_start_time.strftime('%I:%M %p')}
    You worked for: {hours}h {minutes}m

    During this time, other team members:
    - Completed PMs
    - Created/updated CMs
    - Modified equipment records
    - Updated inventory
    - Made other changes

    Their changes were saved to SharePoint.

    If you close now without merging, their work will be LOST! CHECK:
        """

        ttk.Label(situation_frame, text=situation_text, justify='left').pack(anchor='w')

        # Merge explanation
        merge_frame = ttk.LabelFrame(scrollable_frame, text="How Smart Merge Works", padding=15)
        merge_frame.pack(fill='x', padx=20, pady=10)

        merge_explanation = """
    SMART MERGE PROCESS:

    1. Downloads latest database from SharePoint
    2. Identifies ALL changes you made:
       - PM Completions you entered
       - CMs you created/updated
       - Equipment records you modified
       - MRO inventory you changed
       - Cannot Find/Run to Failure updates

    3. Intelligently merges:
       - ADDS your new PM completions to their database
       - ADDS your new CMs to their database
       - MERGES equipment updates (newest wins)
       - MERGES MRO inventory (your changes win)
       - Preserves all their work too!

    4. Result: Combined database with EVERYONE'S work! CHECK:
        """
    
        ttk.Label(merge_frame, text=merge_explanation, justify='left',
                font=('Courier', 9)).pack(anchor='w')

        # Options
        options_frame = ttk.LabelFrame(scrollable_frame, text="Your Options", padding=15)
        options_frame.pack(fill='x', padx=20, pady=10)

        options_text = """
    OPTION 1: SMART MERGE (Recommended) CHECK:
      CHECK: Combines everyone's work safely
      CHECK: Nothing gets lost

    OPTION 2: OVERRIDE (Dangerous) CHECK:
    CHECK: Overwrites their work with yours only
    CHECK: Their PMs, CMs, updates will be LOST!

    OPTION 3: CANCEL
    CHECK: Don't close yet
    CHECK: Coordinate with team first
        """

        ttk.Label(options_frame, text=options_text, justify='left').pack(anchor='w')

        # Buttons
        button_frame = ttk.Frame(scrollable_frame, padding=15)
        button_frame.pack(fill='x', side='bottom')

        def do_merge():
            result["action"] = "merge"
            dialog.destroy()

        def do_override():
            confirm = messagebox.askyesno(
                "WARNING: CONFIRM OVERRIDE",
                "You are about to OVERWRITE other users' work!\n\n"
                "Their PM completions, CMs, and updates will be LOST!\n\n"
                "Are you ABSOLUTELY SURE?",
                icon='warning',
                parent=dialog
            )
            if confirm:
                result["action"] = "override"
                dialog.destroy()

        def do_cancel():
            result["action"] = "cancel"
            dialog.destroy()

        ttk.Button(button_frame, text="Smart Merge (Recommended)", 
                command=do_merge,
                style='Accent.TButton').pack(side='left', padx=5)

        ttk.Button(button_frame, text="Cancel", 
                command=do_cancel).pack(side='left', padx=5)

        ttk.Button(button_frame, text="Override Their Work", 
                command=do_override).pack(side='right', padx=5)

        # Pack the canvas and scrollbar
        main_canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
    
        # Enable mousewheel scrolling
        def on_mousewheel(event):
            main_canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        main_canvas.bind_all("<MouseWheel>", on_mousewheel)

        dialog.wait_window()
        return result["action"]


# ========== UPDATED METHOD 6: show_closing_sync_dialog ==========
    def show_closing_sync_dialog(self):
        """Show dialog when closing program normally - NOW WITH SCROLLBAR"""
    
        dialog = tk.Toplevel(self.root)
        dialog.title("Close AIT CMMS")
        dialog.geometry("650x600")
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Center dialog
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (650 // 2)
        y = (dialog.winfo_screenheight() // 2) - (600 // 2)
        dialog.geometry(f"650x600+{x}+{y}")
        
        result = {"action": "cancel"}
        
        # Main container with scrollbar
        main_canvas = tk.Canvas(dialog)
        scrollbar = ttk.Scrollbar(dialog, orient="vertical", command=main_canvas.yview)
        scrollable_frame = ttk.Frame(main_canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: main_canvas.configure(scrollregion=main_canvas.bbox("all"))
        )
    
        main_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        main_canvas.configure(yscrollcommand=scrollbar.set)
        
        # Header
        header_frame = ttk.Frame(scrollable_frame, padding=20)
        header_frame.pack(fill='x')

        ttk.Label(header_frame, text="Close AIT CMMS", 
                font=('Arial', 14, 'bold')).pack()

        ttk.Separator(scrollable_frame, orient='horizontal').pack(fill='x', pady=10)

        # Session info
        info_frame = ttk.LabelFrame(scrollable_frame, text="Session Information", padding=15)
        info_frame.pack(fill='x', padx=20, pady=10)

        session_duration = datetime.now() - self.session_start_time
        hours, remainder = divmod(int(session_duration.total_seconds()), 3600)
        minutes, seconds = divmod(remainder, 60)

        info_text = f"""
    User: {self.user_name}
    Role: {self.current_user_role}

    Session Start: {self.session_start_time.strftime('%Y-%m-%d %H:%M:%S')}
    Session Duration: {hours}h {minutes}m {seconds}s

    Current Database: ait_cmms_database.db
    SharePoint Folder: {os.path.basename(self.backup_sync_dir) if hasattr(self, 'backup_sync_dir') and self.backup_sync_dir else 'Not Connected'}
        """

        ttk.Label(info_frame, text=info_text, justify='left', 
                font=('Courier', 9)).pack(anchor='w')

        # Sync explanation
        sync_frame = ttk.LabelFrame(scrollable_frame, text="What Happens Next", padding=15)
        sync_frame.pack(fill='x', padx=20, pady=10)

        sync_text = """When you click 'Backup and Close':

    1. CHECK: Your database will be backed up to SharePoint
    2. CHECK: Timestamped backup will be created
    3. CHECK: Other users can access your latest changes
    4. CHECK: Program will close safely

    This ensures all your work is saved.
        """
    
        ttk.Label(sync_frame, text=sync_text, justify='left').pack(anchor='w')

        # Important note
        note_frame = ttk.Frame(scrollable_frame, padding=10)
        note_frame.pack(fill='x', padx=20)

        ttk.Label(note_frame, 
                  text="Note: Last person to close the program pushes the final database state",
                  foreground='blue', font=('Arial', 9),
                  wraplength=550).pack()

        # Buttons
        button_frame = ttk.Frame(scrollable_frame, padding=15)
        button_frame.pack(fill='x', side='bottom')

        def sync_and_close():
            result["action"] = "sync_and_close"
            dialog.destroy()

        def cancel_close():
            result["action"] = "cancel"
            dialog.destroy()

        def close_without_sync():
            confirm = messagebox.askyesno(
                "Confirm Close Without Backup",
                "Close without backing up to SharePoint?\n\n"
                "WARNING: WARNING: Your changes will NOT be saved!\n"
                "WARNING: Other users will NOT see your work!\n\n"
                "Are you sure?",
                icon='warning',
                parent=dialog
            )
            if confirm:
                result["action"] = "close_without_sync"
                dialog.destroy()

        ttk.Button(button_frame, text="Backup and Close", 
                command=sync_and_close,
                style='Accent.TButton').pack(side='left', padx=5)

        ttk.Button(button_frame, text="Cancel", 
                command=cancel_close).pack(side='left', padx=5)

        ttk.Button(button_frame, text="Close Without Backup", 
                command=close_without_sync).pack(side='right', padx=5)

        # Pack the canvas and scrollbar
        main_canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
    
        # Enable mousewheel scrolling
        def on_mousewheel(event):
            main_canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        main_canvas.bind_all("<MouseWheel>", on_mousewheel)

        dialog.wait_window()
        return result["action"]

    
    
    def perform_comprehensive_merge_and_close(self):
        """Comprehensively merge all changes from both databases - NOW WITH SCROLLBAR"""
        try:
            # Show progress
            progress = tk.Toplevel(self.root)
            progress.title("Comprehensive Smart Merge in Progress...")
            progress.geometry("650x500")
            progress.transient(self.root)
            progress.grab_set()
            
            # Center progress
            progress.update_idletasks()
            x = (progress.winfo_screenwidth() // 2) - (650 // 2)
            y = (progress.winfo_screenheight() // 2) - (500 // 2)
            progress.geometry(f"650x500+{x}+{y}")
            
            # Main container with scrollbar
            main_canvas = tk.Canvas(progress)
            scrollbar = ttk.Scrollbar(progress, orient="vertical", command=main_canvas.yview)
            scrollable_frame = ttk.Frame(main_canvas)
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: main_canvas.configure(scrollregion=main_canvas.bbox("all"))
            )
        
            main_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            main_canvas.configure(yscrollcommand=scrollbar.set)
        
            status_var = tk.StringVar(value="Preparing comprehensive merge...")
    
            ttk.Label(scrollable_frame, text="Comprehensive Smart Merge", 
                    font=('Arial', 14, 'bold')).pack(pady=20)
    
            status_label = ttk.Label(scrollable_frame, textvariable=status_var, 
                                    font=('Arial', 10), wraplength=600)
            status_label.pack(pady=10)
    
            progress_bar = ttk.Progressbar(scrollable_frame, mode='indeterminate', length=550)
            progress_bar.pack(pady=10)
            progress_bar.start()
    
            log_text = tk.Text(scrollable_frame, height=15, width=75, font=('Courier', 8))
            log_text.pack(pady=10, padx=20)
    
            def log(message):
                log_text.insert('end', message + '\n')
                log_text.see('end')
                progress.update()
        
            # Pack the canvas and scrollbar
            main_canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # Enable mousewheel scrolling
            def on_mousewheel(event):
                main_canvas.yview_scroll(int(-1*(event.delta/120)), "units")
            main_canvas.bind_all("<MouseWheel>", on_mousewheel)
    
            progress.update()
    
            # Step 1: Save current database
            status_var.set("Step 1/6: Saving your changes...")
            log("CHECK: Saving your current work...")
            
            my_changes_db = 'temp_my_changes.db'
            if hasattr(self, 'conn'):
                self.conn.close()
    
            shutil.copy2('ait_cmms_database.db', my_changes_db)
            log(f"CHECK: Your changes saved to: {my_changes_db}")
        
            # Step 2: Pull latest from SharePoint
            status_var.set("Step 2/6: Pulling latest database from SharePoint...")
            log("CHECK: Downloading latest team database...")
        
            latest_backup = self.get_latest_sharepoint_backup()
            if not latest_backup:
                raise Exception("Could not find SharePoint backup")
        
            shutil.copy2(latest_backup[0], 'ait_cmms_latest.db')
            log(f"CHECK: Downloaded: {os.path.basename(latest_backup[0])}")
        
            # Step 3: Open both databases
            status_var.set("Step 3/6: Opening databases...")
            log("CHECK: Opening both databases for comparison...")
        
            my_conn = sqlite3.connect(my_changes_db)
            latest_conn = sqlite3.connect('ait_cmms_latest.db')
            log("CHECK: Both databases opened successfully")
            
            # Step 4-5: Perform merges
            status_var.set("Step 4/6: Merging PM completions...")
            log("\nCHECK: Merging PM Completions...")
            pm_count = self.merge_pm_completions(my_conn, latest_conn)
            log(f"  CHECK: Merged {pm_count} PM completion(s)")
            
            status_var.set("Step 5/6: Merging CMs and other records...")
            log("CHECK: Merging Corrective Maintenance records...")
            cm_count = self.merge_corrective_maintenance(my_conn, latest_conn)
            log(f"  CHECK: Merged {cm_count} CM record(s)")
            
            log("CHECK: Merging MRO inventory...")
            mro_count = self.merge_mro_inventory(my_conn, latest_conn)
            log(f"  CHECK: Merged {mro_count} MRO item(s)")
            
            log("CHECK: Merging Equipment updates...")
            equip_count = self.merge_equipment_updates(my_conn, latest_conn)
            log(f"  CHECK: Merged {equip_count} equipment update(s)")
            
            log("CHECK: Merging Cannot Find assets...")
            cf_count = self.merge_cannot_find_assets(my_conn, latest_conn)
            log(f"  CHECK: Merged {cf_count} Cannot Find record(s)")
            
            log("CHECK: Merging Run to Failure assets...")
            rtf_count = self.merge_run_to_failure_assets(my_conn, latest_conn)
            log(f"  CHECK: Merged {rtf_count} Run to Failure record(s)")
            
            my_conn.close()
            latest_conn.close()
        
            # Save merged database
            status_var.set("Step 6/6: Saving merged database to SharePoint...")
            log("\nCHECK: Pushing merged database to SharePoint...")
            shutil.copy2('ait_cmms_latest.db', 'ait_cmms_database.db')
            
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            backup_filename = f"ait_cmms_backup_{timestamp}.db"
            backup_path = os.path.join(self.backup_sync_dir, backup_filename)
            shutil.copy2('ait_cmms_database.db', backup_path)
            
            log(f"CHECK: Saved to SharePoint: {backup_filename}")
    
            # Cleanup
            try:
                os.remove(my_changes_db)
                os.remove('ait_cmms_latest.db')
            except:
                pass
    
            status_var.set("CHECK: Merge Complete!")
            progress_bar.stop()
        
            total_merged = pm_count + cm_count + mro_count + equip_count + cf_count + rtf_count
            log(f"\nCHECK: SUCCESS! Merged {total_merged} total changes!")
            log("Everyone's work has been preserved!")
    
            # Wait then close
            progress.after(3000, lambda: self.finish_close(progress))
    
        except Exception as e:
            messagebox.showerror("Merge Error", 
                               f"Error during merge:\n{str(e)}\n\n"
                               "Your work is saved locally.\n"
                               "Contact support for help.")


   
    
    
    def merge_pm_completions(self, my_conn, latest_conn):
        """Merge PM completions from my database to latest"""
        try:
            my_cursor = my_conn.cursor()
            latest_cursor = latest_conn.cursor()
        
            # Get PM completions from my database that aren't in latest
            my_cursor.execute('''
                SELECT bfm_equipment_no, pm_type, technician_name, completion_date,
                    labor_hours, labor_minutes, pm_due_date, special_equipment, notes,
                    next_annual_pm_date
                FROM pm_completions
            ''')
        
            my_pms = my_cursor.fetchall()
            merged_count = 0
        
            for pm in my_pms:
                bfm_no, pm_type, tech, comp_date, hours, mins, due_date, special, notes, next_annual = pm
            
                # Check if this exact PM already exists in latest
                latest_cursor.execute('''
                    SELECT id FROM pm_completions 
                    WHERE bfm_equipment_no = %s AND pm_type = %s
                    AND technician_name = %s AND completion_date = %s
                ''', (bfm_no, pm_type, tech, comp_date))
            
                if not latest_cursor.fetchone():
                    # Insert this PM into latest database
                    latest_cursor.execute('''
                        INSERT INTO pm_completions 
                        (bfm_equipment_no, pm_type, technician_name, completion_date,
                        labor_hours, labor_minutes, pm_due_date, special_equipment, notes,
                        next_annual_pm_date)
                        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                    ''', (bfm_no, pm_type, tech, comp_date, hours, mins, due_date, special, notes, next_annual))
                    merged_count += 1
        
            latest_conn.commit()
            return merged_count
        
        except Exception as e:
            print(f"Error merging PM completions: {e}")
            return 0
    
    def merge_corrective_maintenance(self, my_conn, latest_conn):
        """Merge CM records from my database to latest"""
        try:
            my_cursor = my_conn.cursor()
            latest_cursor = latest_conn.cursor()
            
            # Get CMs from my database
            my_cursor.execute('SELECT * FROM corrective_maintenance')
            my_cms = my_cursor.fetchall()
            
            # Get column info
            my_cursor.execute('PRAGMA table_info(corrective_maintenance)')
            columns = [col[1] for col in my_cursor.fetchall()]
            
            merged_count = 0
        
            for cm in my_cms:
                cm_number = cm[1]  # Assuming cm_number is second column
            
                # Check if CM exists in latest
                latest_cursor.execute(
                    'SELECT id FROM corrective_maintenance WHERE cm_number = %s',
                    (cm_number,)
                )
            
                exists = latest_cursor.fetchone()
            
                if not exists:
                    # Insert new CM
                    placeholders = ', '.join(['%s' for _ in columns])
                    latest_cursor.execute(
                        f'INSERT INTO corrective_maintenance VALUES ({placeholders})',
                        cm
                    )
                    merged_count += 1
                else:
                    # Update existing CM (user's version is newer)
                    set_clause = ', '.join([f'{col} = %s' for col in columns[2:]])  # Skip id and cm_number
                    latest_cursor.execute(
                        f'UPDATE corrective_maintenance SET {set_clause} WHERE cm_number = %s',
                        cm[2:] + (cm_number,)
                    )
                    merged_count += 1
        
            latest_conn.commit()
            return merged_count
        
        except Exception as e:
            print(f"Error merging CMs: {e}")
            return 0
    
    
    
    def merge_mro_inventory(self, my_conn, latest_conn):
        """Merge MRO inventory from my database to latest"""
        try:
            my_cursor = my_conn.cursor()
            latest_cursor = latest_conn.cursor()
            
            # Get MRO items from my database
            my_cursor.execute('SELECT * FROM mro_inventory')
            my_items = my_cursor.fetchall()
        
            # Get columns
            my_cursor.execute('PRAGMA table_info(mro_inventory)')
            columns = [col[1] for col in my_cursor.fetchall()]
            
            merged_count = 0
        
            for item in my_items:
                part_number = item[1]  # Assuming part_number is second column
            
                # Check if exists in latest
                latest_cursor.execute(
                    'SELECT id FROM mro_inventory WHERE part_number = %s',
                    (part_number,)
                )
            
                exists = latest_cursor.fetchone()
            
                if not exists:
                    # Insert new item
                    placeholders = ', '.join(['%s' for _ in columns])
                    latest_cursor.execute(
                        f'INSERT INTO mro_inventory VALUES ({placeholders})',
                        item
                    )
                    merged_count += 1
                else:
                    # Update existing (user's changes win for MRO)
                    set_clause = ', '.join([f'{col} = %s' for col in columns[2:]])
                    latest_cursor.execute(
                        f'UPDATE mro_inventory SET {set_clause} WHERE part_number = %s',
                        item[2:] + (part_number,)
                    )
                    merged_count += 1
        
            latest_conn.commit()
            return merged_count
        
        except Exception as e:
            print(f"Error merging MRO: {e}")
            return 0
    
    
    def merge_equipment_updates(self, my_conn, latest_conn):
        """Merge equipment updates (take most recent changes)"""
        try:
            my_cursor = my_conn.cursor()
            latest_cursor = latest_conn.cursor()
            
            # Get equipment from my database
            my_cursor.execute('SELECT * FROM equipment')
            my_equipment = my_cursor.fetchall()
            
            # Get columns
            my_cursor.execute('PRAGMA table_info(equipment)')
            columns = [col[1] for col in my_cursor.fetchall()]
        
            merged_count = 0
        
            for equip in my_equipment:
                bfm_no = equip[1]  # Assuming bfm_equipment_no is second column
            
                # Check if exists in latest
                latest_cursor.execute(
                    'SELECT id FROM equipment WHERE bfm_equipment_no = %s',
                    (bfm_no,)
                )
            
                exists = latest_cursor.fetchone()
            
                if not exists:
                    # Insert new equipment
                    placeholders = ', '.join(['%s' for _ in columns])
                    latest_cursor.execute(
                        f'INSERT INTO equipment VALUES ({placeholders})',
                        equip
                    )
                    merged_count += 1
                # For existing equipment, we keep latest version (don't overwrite)
                # This is safer - equipment records are usually setup data
        
            latest_conn.commit()
            return merged_count
        
        except Exception as e:
            print(f"Error merging equipment: {e}")
            return 0
    
    
    def merge_cannot_find_assets(self, my_conn, latest_conn):
        """Merge Cannot Find assets"""
        try:
            my_cursor = my_conn.cursor()
            latest_cursor = latest_conn.cursor()
            
            my_cursor.execute('SELECT * FROM cannot_find_assets')
            my_assets = my_cursor.fetchall()
            
            my_cursor.execute('PRAGMA table_info(cannot_find_assets)')
            columns = [col[1] for col in my_cursor.fetchall()]
            
            merged_count = 0
            
            for asset in my_assets:
                bfm_no = asset[1]  # Assuming bfm_equipment_no is second column
            
                latest_cursor.execute(
                    'SELECT id FROM cannot_find_assets WHERE bfm_equipment_no = %s',
                    (bfm_no,)
                )
            
                if not latest_cursor.fetchone():
                    placeholders = ', '.join(['%s' for _ in columns])
                    latest_cursor.execute(
                        f'INSERT INTO cannot_find_assets VALUES ({placeholders})',
                        asset
                    )
                    merged_count += 1
        
            latest_conn.commit()
            return merged_count
        
        except Exception as e:
            print(f"Error merging Cannot Find: {e}")
            return 0
    
    
    
    def merge_run_to_failure_assets(self, my_conn, latest_conn):
        """Merge Run to Failure assets"""
        try:
            my_cursor = my_conn.cursor()
            latest_cursor = latest_conn.cursor()
            
            my_cursor.execute('SELECT * FROM run_to_failure_assets')
            my_assets = my_cursor.fetchall()
            
            my_cursor.execute('PRAGMA table_info(run_to_failure_assets)')
            columns = [col[1] for col in my_cursor.fetchall()]
            
            merged_count = 0
        
            for asset in my_assets:
                bfm_no = asset[1]  # Assuming bfm_equipment_no is second column
            
                latest_cursor.execute(
                    'SELECT id FROM run_to_failure_assets WHERE bfm_equipment_no = %s',
                    (bfm_no,)
                )
            
                if not latest_cursor.fetchone():
                    placeholders = ', '.join(['%s' for _ in columns])
                    latest_cursor.execute(
                        f'INSERT INTO run_to_failure_assets VALUES ({placeholders})',
                        asset
                    )
                    merged_count += 1
        
            latest_conn.commit()
            return merged_count
        
        except Exception as e:
            print(f"Error merging Run to Failure: {e}")
            return 0
    
    
    def backup_and_close_normal(self):
        """Normal backup and close (no conflicts)"""
        if hasattr(self, 'backup_sync_dir'):
            print("Creating backup...")
            self.sharepoint_only_backup(self.backup_sync_dir)
            print("Backup completed")
    
        if hasattr(self, 'conn'):
            self.conn.close()
    
        self.root.destroy()
    
    
    def finish_close(self, progress_dialog):
        """Final cleanup and close"""
        progress_dialog.destroy()
    
        if hasattr(self, 'conn'):
            try:
                self.conn.close()
            except:
                pass
    
        self.root.destroy()
    
    def clear_all_mro_inventory(self):
        """Clear ALL MRO stock inventory items from the database"""
    
        # First, get count of items to show in confirmation
        cursor = self.conn.cursor()
        cursor.execute('SELECT COUNT(*) FROM mro_inventory')
        total_count = cursor.fetchone()[0]
    
        if total_count == 0:
            messagebox.showinfo("No Items", "There are no MRO inventory items to clear.")
            return
    
        # Show confirmation dialog with count
        result = messagebox.askyesno(
            "WARNING: Confirm Clear All MRO Inventory",
            f"Are you sure you want to DELETE ALL {total_count} MRO inventory items?\n\n"
            "WARNING: WARNING: This action cannot be undone!\n"
            "WARNING: ALL stock records will be permanently deleted!\n\n"
            "This will remove:\n"
            "- All part numbers\n"
            "- All quantity records\n"
            "- All stock locations\n"
            "- All inventory data\n\n"
            "Are you ABSOLUTELY SURE?",
            icon='warning'
        )
    
        if not result:
            return
    
        # Double confirmation for safety
        double_check = messagebox.askyesno(
            "WARNING: Final Confirmation",
            f"FINAL WARNING!\n\n"
            f"You are about to permanently delete {total_count} inventory items.\n\n"
            "This cannot be reversed!\n\n"
            "Click YES to proceed with deletion.",
            icon='warning'
        )
    
        if not double_check:
            messagebox.showinfo("Cancelled", "Clear operation cancelled. No items were deleted.")
            return
    
        try:
            # Delete all MRO inventory items
            cursor.execute('DELETE FROM mro_inventory')
            self.conn.commit()
            
            # Refresh the MRO display if the method exists
            if hasattr(self.mro_manager, 'load_mro_inventory'):
                self.mro_manager.load_mro_inventory()
        
            # Update status bar
            self.update_status(f"CHECK: Successfully cleared {total_count} MRO inventory items")
        
            # Show success message
            messagebox.showinfo(
                "Success", 
                f"All {total_count} MRO inventory items have been permanently deleted.\n\n"
                "The MRO inventory is now empty."
            )
        
        except Exception as e:
            self.conn.rollback()
            messagebox.showerror("Error", f"Failed to clear MRO inventory: {str(e)}")
            print(f"Clear MRO inventory error: {e}")

    # ========================================================================
    # NEW MODULAR FEATURES - Callback Methods
    # ========================================================================


# Main application startup
if __name__ == "__main__":
    root = tk.Tk()
    app = AITCMMSSystem(root)
    root.mainloop()